--- NodeManager.cpp
+++ NodeManager.cpp
@@ -211,17 +211,6 @@ char* Request::getValueString() {
     Sensors
 */
 
-/*
- Child class
- */
-
-Child::Child(int child_id, int presentation, int type, int value_type, char* description) {
-  _child_id = child_id;
-  _presentation = presentation;
-  _value_type = value_type;
-  _description = description;
-}
-
 /*
    Sensor class
 */
@@ -1286,10 +1275,6 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
-//  _children = new Child[2];
-  _children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
-  _children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
-  
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
   if (_sensor_type == SensorSHT21::TEMPERATURE) {
@@ -1318,14 +1303,6 @@ void SensorSHT21::onSetup() {
 
 // what to do during loop
 void SensorSHT21::onLoop() {
-  for (int i = 0; i < MAX_CHILDREN; i++) {
-    if (_children[i] == 0) break;
-    if (i == temperature) {
-      // read the temperature
-      float temperature = SHT2x.GetTemperature();
-    }
-  }
-  
   // temperature sensor
   if (_sensor_type == SensorSHT21::TEMPERATURE) {
     // read the temperature
@@ -3957,7 +3934,7 @@ void NodeManager::sleepOrWait(long value) {
       Serial.println(value);
     #endif
     // report signal level
-	//_sendSignalChild(_msg.set(value));
+	_sendSignalChild(_msg.set(value));
   }
 #endif
 
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -215,9 +215,6 @@ char* Request::getValueString() {
  Child class
  */
 
-Child::Child() {
-  
-}
 Child::Child(int child_id, int presentation, int type, int value_type, char* description) {
   _child_id = child_id;
   _presentation = presentation;
@@ -1290,10 +1287,8 @@ void SensorDHT::onInterrupt() {
 // contructor
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
 //  _children = new Child[2];
-  //_children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
-  //_children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
-  myList.push_back(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  myList.push_back(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+  _children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
+  _children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
   
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -1292,8 +1292,8 @@ SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_typ
 //  _children = new Child[2];
   //_children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
   //_children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
-  myList.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  myList.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+  myList.push_back(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  myList.push_back(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
@@ -4161,4 +4161,3 @@ void NodeManager::_saveConfig() {
   saveState(EEPROM_SLEEP_2,bit_2);
   saveState(EEPROM_SLEEP_3,bit_3);
 }
-
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -218,11 +218,11 @@ char* Request::getValueString() {
 Child::Child() {
   
 }
-Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
-  child_id = _child_id;
-  presentation = _presentation;
-  value_type = _value_type;
-  description = _description;
+Child::Child(int child_id, int presentation, int type, int value_type, char* description) {
+  _child_id = child_id;
+  _presentation = presentation;
+  _value_type = value_type;
+  _description = description;
 }
 
 /*
@@ -394,9 +394,6 @@ void Sensor::loop(const MyMessage & message) {
     // turn the sensor on
     if (_auto_power_pins) powerOn();
   #endif
-  
-  // FOR ALL CHILD
-  
   // for numeric sensor requiring multiple samples, keep track of the total
   double total = 0;
   // collect multiple samples if needed
@@ -1292,8 +1289,11 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
-  _children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  _children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+//  _children = new Child[2];
+  //_children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
+  //_children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
+  myList.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  myList.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
@@ -1323,37 +1323,42 @@ void SensorSHT21::onSetup() {
 
 // what to do during loop
 void SensorSHT21::onLoop() {
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    // temperature sensor
-    Child c = (*itr);
-    if (c.type == V_TEMP) {
+  for (int i = 0; i < MAX_CHILDREN; i++) {
+    if (_children[i] == 0) break;
+    if (i == temperature) {
       // read the temperature
       float temperature = SHT2x.GetTemperature();
-      // convert it
-      temperature = _node_manager->celsiusToFahrenheit(temperature);
-      #if DEBUG == 1
-        Serial.print(F("SHT I="));
-        Serial.print((*itr).child_id);
-        Serial.print(F(" T="));
-        Serial.println(temperature);
-      #endif
-      // store the value
-      if (! isnan(temperature)) _value_float = temperature;
-    }
-    // Humidity Sensor
-    else if ((*itr).type == V_HUM) {
-      // read humidity
-      float humidity = SHT2x.GetHumidity();
-      if (isnan(humidity)) return;
-      #if DEBUG == 1
-        Serial.print(F("SHT I="));
-        Serial.print((*itr).child_id);
-        Serial.print(F(" H="));
-        Serial.println(humidity);
-      #endif
-      // store the value
-      if (! isnan(humidity)) _value_float = humidity;
     }
+  }
+  
+  // temperature sensor
+  if (_sensor_type == SensorSHT21::TEMPERATURE) {
+    // read the temperature
+    float temperature = SHT2x.GetTemperature();
+    // convert it
+    temperature = _node_manager->celsiusToFahrenheit(temperature);
+    #if DEBUG == 1
+      Serial.print(F("SHT I="));
+      Serial.print(_child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) _value_float = temperature;
+  }
+  // Humidity Sensor
+  else if (_sensor_type == SensorSHT21::HUMIDITY) {
+    // read humidity
+    float humidity = SHT2x.GetHumidity();
+    if (isnan(humidity)) return;
+    #if DEBUG == 1
+      Serial.print(F("SHT I="));
+      Serial.print(_child_id);
+      Serial.print(F(" H="));
+      Serial.println(humidity);
+    #endif
+    // store the value
+    if (! isnan(humidity)) _value_float = humidity;
   }
 }
 
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -396,69 +396,67 @@ void Sensor::loop(const MyMessage & message) {
   #endif
   
   // FOR ALL CHILD
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    Child child = (*itr);
-    // for numeric sensor requiring multiple samples, keep track of the total
-    double total = 0;
-    // collect multiple samples if needed
-    for (int i = 0; i < _samples; i++) {
-      // call the sensor-specific implementation of the main task which will store the result in the _value variable
-      if (_isReceive(message)) {
-        // we've been called from receive(), pass the message along
-        onReceive(message);
-      }
-      else {
-        // we'be been called from loop()
-        onLoop(child);
-      }
-      // for integers, floats and doubles, keep track of the total
-      if (_value_type == TYPE_INTEGER) total += (float)_value_int;
-      else if (_value_type == TYPE_FLOAT) total += _value_float;
-      else if (_value_type == TYPE_DOUBLE) total += _value_double;
-      // wait between samples
-      if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
+  
+  // for numeric sensor requiring multiple samples, keep track of the total
+  double total = 0;
+  // collect multiple samples if needed
+  for (int i = 0; i < _samples; i++) {
+    // call the sensor-specific implementation of the main task which will store the result in the _value variable
+    if (_isReceive(message)) {
+      // we've been called from receive(), pass the message along
+      onReceive(message);
+    }
+    else {
+      // we'be been called from loop()
+      onLoop();
     }
-    // process the result and send a response back
-    if (_value_type == TYPE_INTEGER && total > -1) {
-      // if the value is an integer, calculate the average value of the samples
-      int avg = (int) (total / _samples);
-      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(avg != _last_value_int))  {
-        _last_value_int = avg;
-        _sendSensorMessage(_msg->set(avg));
-        _value_int = -1;
-      }
+    // for integers, floats and doubles, keep track of the total
+    if (_value_type == TYPE_INTEGER) total += (float)_value_int;
+    else if (_value_type == TYPE_FLOAT) total += _value_float;
+    else if (_value_type == TYPE_DOUBLE) total += _value_double;
+    // wait between samples
+    if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
+  }
+  // process the result and send a response back
+  if (_value_type == TYPE_INTEGER && total > -1) {
+    // if the value is an integer, calculate the average value of the samples
+    int avg = (int) (total / _samples);
+    // if track last value is disabled or if enabled and the current value is different then the old value, send it back
+    if (_isReceive(message) || _isWorthSending(avg != _last_value_int))  {
+      _last_value_int = avg;
+      _sendSensorMessage(_msg->set(avg));
+      _value_int = -1;
     }
-    // process a float value
-    else if (_value_type == TYPE_FLOAT && total > -1) {
-      // calculate the average value of the samples
-      float avg = total / _samples;
-      // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != _last_value_float))  {
-        _last_value_float = avg;
-        _sendSensorMessage(_msg->set(avg, _float_precision));
-        _value_float = -1;
-      }
+  }
+  // process a float value
+  else if (_value_type == TYPE_FLOAT && total > -1) {
+    // calculate the average value of the samples
+    float avg = total / _samples;
+    // report the value back
+    if (_isReceive(message) || _isWorthSending(avg != _last_value_float))  {
+      _last_value_float = avg;
+      _sendSensorMessage(_msg->set(avg, _float_precision));
+      _value_float = -1;
     }
-    // process a double value
-    else if (_value_type == TYPE_DOUBLE && total > -1) {
-      // calculate the average value of the samples
-      double avg = total / _samples;
-      // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != _last_value_double))  {
-        _last_value_double = avg;
-        _sendSensorMessage(_msg->set(avg, _double_precision));
-        _value_double = -1;
-      }
+  }
+  // process a double value
+  else if (_value_type == TYPE_DOUBLE && total > -1) {
+    // calculate the average value of the samples
+    double avg = total / _samples;
+    // report the value back
+    if (_isReceive(message) || _isWorthSending(avg != _last_value_double))  {
+      _last_value_double = avg;
+      _sendSensorMessage(_msg->set(avg, _double_precision));
+      _value_double = -1;
     }
-    // process a string value
-    else if (_value_type == TYPE_STRING) {
-      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(strcmp(_value_string, _last_value_string) != 0))  {
-        _last_value_string = _value_string;
-        _sendSensorMessage(_msg->set(_value_string));
-        _value_string = "";
-      }
+  }
+  // process a string value
+  else if (_value_type == TYPE_STRING) {
+    // if track last value is disabled or if enabled and the current value is different then the old value, send it back
+    if (_isReceive(message) || _isWorthSending(strcmp(_value_string, _last_value_string) != 0))  {
+      _last_value_string = _value_string;
+      _sendSensorMessage(_msg->set(_value_string));
+      _value_string = "";
     }
   }
   // turn the sensor off
@@ -599,7 +597,7 @@ void SensorAnalogInput::onSetup() {
 }
 
 // what to do during loop
-void SensorAnalogInput::onLoop(Child child) {
+void SensorAnalogInput::onLoop() {
   // read the input
   int adc = _getAnalogRead();
   // calculate the percentage
@@ -619,7 +617,7 @@ void SensorAnalogInput::onLoop() {
 
 // what to do during loop
 void SensorAnalogInput::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -720,7 +718,7 @@ void SensorThermistor::onSetup() {
 }
 
 // what to do during loop
-void SensorThermistor::onLoop(Child child) {
+void SensorThermistor::onLoop() {
   // read the voltage across the thermistor
   float adc = analogRead(_pin);
   // calculate the temperature
@@ -748,7 +746,7 @@ void SensorThermistor::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorThermistor::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -792,7 +790,7 @@ void SensorML8511::onSetup() {
 }
 
 // what to do during loop
-void SensorML8511::onLoop(Child child) {
+void SensorML8511::onLoop() {
   // read the voltage 
   int uvLevel = analogRead(_pin);
   int refLevel = _node_manager->getVcc()*1024/3.3;
@@ -814,7 +812,7 @@ void SensorML8511::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorML8511::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -861,7 +859,7 @@ void SensorACS712::onSetup() {
 }
 
 // what to do during loop
-void SensorACS712::onLoop(Child child) {
+void SensorACS712::onLoop() {
   int value = analogRead(_pin);
   // convert the analog read in mV
   double voltage = (value / 1024.0) * 5000; 
@@ -877,7 +875,7 @@ void SensorACS712::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorACS712::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -947,7 +945,7 @@ void SensorDigitalInput::onSetup() {
 }
 
 // what to do during loop
-void SensorDigitalInput::onLoop(Child child) {
+void SensorDigitalInput::onLoop() {
   // read the value
   int value = digitalRead(_pin);
   #if DEBUG == 1
@@ -964,7 +962,7 @@ void SensorDigitalInput::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorDigitalInput::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -1017,7 +1015,7 @@ void SensorDigitalOutput::setWaitAfterSet(int value) {
 }
 
 // main task
-void SensorDigitalOutput::onLoop(Child child) {
+void SensorDigitalOutput::onLoop() {
   // set the value to -1 so to avoid reporting to the gateway during loop
   _value_int = -1;
   _last_value_int = -1;
@@ -1242,7 +1240,7 @@ void SensorDHT::onSetup() {
 }
 
 // what to do during loop
-void SensorDHT::onLoop(Child child) {
+void SensorDHT::onLoop() {
   _node_manager->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
@@ -1276,7 +1274,7 @@ void SensorDHT::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorDHT::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -1296,6 +1294,21 @@ void SensorDHT::onInterrupt() {
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
   _children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
   _children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+  
+  // store the sensor type (0: temperature, 1: humidity)
+  _sensor_type = sensor_type;
+  if (_sensor_type == SensorSHT21::TEMPERATURE) {
+    // temperature sensor
+    setPresentation(S_TEMP);
+    setType(V_TEMP);
+    setValueType(TYPE_FLOAT);
+  }
+  else if (_sensor_type == SensorSHT21::HUMIDITY) {
+    // humidity sensor
+    setPresentation(S_HUM);
+    setType(V_HUM);
+    setValueType(TYPE_FLOAT);
+  }
 }
 
 // what to do during before
@@ -1309,44 +1322,44 @@ void SensorSHT21::onSetup() {
 }
 
 // what to do during loop
-void SensorSHT21::onLoop(Child child) {
-  // temperature sensor
-  if (child.type == V_TEMP) {
-    // read the temperature
-    float temperature = SHT2x.GetTemperature();
-    // convert it
-    temperature = _node_manager->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
-      Serial.print(F("SHT I="));
-      Serial.print(child.child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) _value_float = temperature;
-  }
-  // Humidity Sensor
-  else if (child.type == V_HUM) {
-    // read humidity
-    float humidity = SHT2x.GetHumidity();
-    if (isnan(humidity)) return;
-    #if DEBUG == 1
-      Serial.print(F("SHT I="));
-      Serial.print(child.child_id);
-      Serial.print(F(" H="));
-      Serial.println(humidity);
-    #endif
-    // store the value
-   if (! isnan(humidity)) _value_float = humidity;
+void SensorSHT21::onLoop() {
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    // temperature sensor
+    Child c = (*itr);
+    if (c.type == V_TEMP) {
+      // read the temperature
+      float temperature = SHT2x.GetTemperature();
+      // convert it
+      temperature = _node_manager->celsiusToFahrenheit(temperature);
+      #if DEBUG == 1
+        Serial.print(F("SHT I="));
+        Serial.print((*itr).child_id);
+        Serial.print(F(" T="));
+        Serial.println(temperature);
+      #endif
+      // store the value
+      if (! isnan(temperature)) _value_float = temperature;
+    }
+    // Humidity Sensor
+    else if ((*itr).type == V_HUM) {
+      // read humidity
+      float humidity = SHT2x.GetHumidity();
+      if (isnan(humidity)) return;
+      #if DEBUG == 1
+        Serial.print(F("SHT I="));
+        Serial.print((*itr).child_id);
+        Serial.print(F(" H="));
+        Serial.println(humidity);
+      #endif
+      // store the value
+      if (! isnan(humidity)) _value_float = humidity;
+    }
   }
 }
 
 // what to do as the main task when receiving a message
 void SensorSHT21::onReceive(const MyMessage & message) {
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    Child child = (*itr);
-    if (message.getCommand() == C_REQ && child.child_id == message.sensor) onLoop(child);
-  }
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -1402,7 +1415,7 @@ void SensorSwitch::onSetup() {
 }
 
 // what to do during loop
-void SensorSwitch::onLoop(Child child) {
+void SensorSwitch::onLoop() {
 }
 
 // what to do as the main task when receiving a message
@@ -1491,7 +1504,7 @@ void SensorDs18b20::onSetup() {
 }
 
 // what to do during loop
-void SensorDs18b20::onLoop(Child child) {
+void SensorDs18b20::onLoop() {
   // do not wait for conversion, will sleep manually during it
   if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
   // request the temperature
@@ -1517,7 +1530,7 @@ void SensorDs18b20::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorDs18b20::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -1582,7 +1595,7 @@ void SensorBH1750::onSetup() {
 }
 
 // what to do during loop
-void SensorBH1750::onLoop(Child child) {
+void SensorBH1750::onLoop() {
   // request the light level
   _value_int = _lightSensor->readLightLevel();
   #if DEBUG == 1
@@ -1595,7 +1608,7 @@ void SensorBH1750::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorBH1750::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -1639,7 +1652,7 @@ void SensorMLX90614::onSetup() {
 }
 
 // what to do during loop
-void SensorMLX90614::onLoop(Child child) {
+void SensorMLX90614::onLoop() {
   float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -1654,7 +1667,7 @@ void SensorMLX90614::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorMLX90614::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -1716,12 +1729,12 @@ void SensorBosch::onSetup() {
 }
 
 // what to do during loop
-void SensorBosch::onLoop(Child child) {
+void SensorBosch::onLoop() {
 }
 
 // what to do as the main task when receiving a message
 void SensorBosch::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -1855,7 +1868,7 @@ SensorBME280::SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME
   _bme = bme;
 }
 
-void SensorBME280::onLoop(Child child) {
+void SensorBME280::onLoop() {
   // temperature sensor
   if (_sensor_type == SensorBME280::TEMPERATURE) {
     // read the temperature
@@ -1919,7 +1932,7 @@ SensorBMP085::SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP
 }
 
 // what to do during loop
-void SensorBMP085::onLoop(Child child) {
+void SensorBMP085::onLoop() {
   // temperature sensor
   if (_sensor_type == SensorBMP085::TEMPERATURE) {
     // read the temperature
@@ -1966,7 +1979,7 @@ SensorBMP280::SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP
   _bmp = bmp;
 }
 
-void SensorBMP280::onLoop(Child child) {
+void SensorBMP280::onLoop() {
   // temperature sensor
   if (_sensor_type == SensorBMP280::TEMPERATURE) {
     // read the temperature
@@ -2041,7 +2054,7 @@ void SensorHCSR04::onSetup() {
 }
 
 // what to do during loop
-void SensorHCSR04::onLoop(Child child) {
+void SensorHCSR04::onLoop() {
   int distance = _node_manager->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
   #if DEBUG == 1
     Serial.print(F("HC I="));
@@ -2054,7 +2067,7 @@ void SensorHCSR04::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorHCSR04::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -2116,7 +2129,7 @@ void SensorSonoff::onSetup() {
 }
 
 // what to do during loop
-void SensorSonoff::onLoop(Child child) {
+void SensorSonoff::onLoop() {
   _debouncer.update();
   // Get the update value from the button
   int value = _debouncer.read();
@@ -2209,7 +2222,7 @@ void SensorMCP9808::onSetup() {
 }
 
 // what to do during loop
-void SensorMCP9808::onLoop(Child child) {
+void SensorMCP9808::onLoop() {
   float temperature = _mcp->readTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -2225,7 +2238,7 @@ void SensorMCP9808::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorMCP9808::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -2302,7 +2315,7 @@ void SensorMQ::onSetup() {
 }
 
 // what to do during loop
-void SensorMQ::onLoop(Child child) {
+void SensorMQ::onLoop() {
   if (_pin == -1) return;
   // calculate rs/ro
   float mq = _MQRead()/_ro;
@@ -2333,7 +2346,7 @@ void SensorMQ::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorMQ::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -2442,7 +2455,7 @@ void SensorMHZ19::onSetup() {
 }
 
 // what to do during loop
-void SensorMHZ19::onLoop(Child child) {
+void SensorMHZ19::onLoop() {
   // Read the ppm value
   int co2ppm = readCO2(); // This is there the function gets called that talks to the Co2 sensor.
   #if DEBUG == 1
@@ -2496,7 +2509,7 @@ int SensorMHZ19::readCO2() {
 
 // what to do as the main task when receiving a message
 void SensorMHZ19::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -2546,7 +2559,7 @@ void SensorAM2320::onSetup() {
 }
 
 // what do to during loop
-void SensorAM2320::onLoop(Child child) {
+void SensorAM2320::onLoop() {
   switch(_th->Read()) {
     case 0:
       // temperature sensor
@@ -2584,7 +2597,7 @@ void SensorAM2320::onLoop() {
 
 // what do to as the main task when receiving a message
 void SensorAM2320::onReceive(const MyMessage & message) {
-  onLoop(NULL);
+  onLoop();
 }
 
 // what to do when receiving a remote message
@@ -2664,7 +2677,7 @@ void SensorTSL2561::onSetup() {
 }
 
 // what do to during loop
-void SensorTSL2561::onLoop(Child child) {
+void SensorTSL2561::onLoop() {
   // request the light level
    switch (_tsl_spectrum) {
     case SensorTSL2561::VISIBLE:
@@ -2709,7 +2722,7 @@ void SensorTSL2561::onLoop() {
 
 // what do to as the main task when receiving a message
 void SensorTSL2561::onReceive(const MyMessage & message) {
-  onLoop(NULL);
+  onLoop();
 }
 
 // what to do when receiving a remote message
@@ -2759,7 +2772,7 @@ void SensorPT100::onSetup() {
 }
 
 // what to do during loop
-void SensorPT100::onLoop(Child child) {
+void SensorPT100::onLoop() {
   // read the PT100 sensor
   int temperature = _PT100->readTemperature(_pin);  
   #if DEBUG == 1
@@ -2774,7 +2787,7 @@ void SensorPT100::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorPT100::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
+  if (message.getCommand() == C_REQ) onLoop();
 }
 
 // what to do when receiving a remote message
@@ -2825,7 +2838,7 @@ void SensorDimmer::onSetup() {
 }
 
 // what to do during loop
-void SensorDimmer::onLoop(Child child) {
+void SensorDimmer::onLoop() {
 }
 
 // what to do as the main task when receiving a message
@@ -2925,7 +2938,7 @@ void SensorPulseMeter::onSetup() {
 }
 
 // what to do during loop
-void SensorPulseMeter::onLoop(Child child) {
+void SensorPulseMeter::onLoop() {
   // do not report anything if called by an interrupt
   if (_node_manager->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
@@ -3189,8 +3202,8 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
       // register temperature sensor
       registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
       // register humidity sensor
-      //child_id = _getAvailableChildId();
-      //return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
+      child_id = _getAvailableChildId();
+      return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
     }
     else if (sensor_type == SENSOR_HTU21D) {
       // register temperature sensor
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -221,7 +221,6 @@ Child::Child() {
 Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
   child_id = _child_id;
   presentation = _presentation;
-  type = _type;
   value_type = _value_type;
   description = _description;
 }
@@ -355,17 +354,13 @@ void Sensor::setInterrupt(int pin, int mode, int initial) {
 
 // present the sensor to the gateway and controller
 void Sensor::presentation() {
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    Child child = (*itr);
   #if DEBUG == 1
     Serial.print(F("PRES I="));
-    Serial.print(child.child_id);
+    Serial.print(_child_id);
     Serial.print(F(" T="));
-    Serial.println(child.presentation);
+    Serial.println(_presentation);
   #endif
-  present(child.child_id, child.presentation,child.description,_node_manager->getAck());
-  }
-
+  present(_child_id, _presentation,_description,_node_manager->getAck());
 }
 
 // call the sensor-specific implementation of before
@@ -382,7 +377,7 @@ void Sensor::setup() {
 
 // call the sensor-specific implementation of loop
 void Sensor::loop(const MyMessage & message) {
-//  if (_pin == -1) return;
+  if (_pin == -1) return;
   // update the timers if within a loop cycle
   if (! _isReceive(message)) {
     if (_report_timer->isRunning()) {
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -216,10 +216,8 @@ char* Request::getValueString() {
  */
 
 Child::Child() {
-
+  
 }
-
-// constructor
 Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
   child_id = _child_id;
   presentation = _presentation;
@@ -228,57 +226,6 @@ Child::Child(int _child_id, int _presentation, int _type, int _value_type, char*
   description = _description;
 }
 
-// setter/getter
-template<> void Child::setValue(int value) {
-  _value_int = value;
-}
-template<> void Child::setValue(float value) {
-  _value_float = value;
-}
-template<> void Child::setValue(double value) {
-  _value_double = value;
-}
-template<> void Child::setValue(char* value) {
-  _value_string = value;
-}
-template<> int Child::getValue() {
-    return _value_int;
-}
-template<> float Child::getValue() {
-    return _value_float;
-}
-template<> double Child::getValue() {
-    return _value_double;
-}
-template<> char* Child::getValue() {
-    return _value_string;
-}
-template<> void Child::setLastValue(int value) {
-  _last_value_int = value;
-}
-template<> void Child::setLastValue(float value) {
-  _last_value_float = value;
-}
-template<> void Child::setLastValue(double value) {
-  _last_value_double = value;
-}
-template<> void Child::setLastValue(char* value) {
-  _last_value_string = value;
-}
-template<> int Child::getLastValue() {
-    return _last_value_int;
-}
-template<> float Child::getLastValue() {
-    return _last_value_float;
-}
-template<> double Child::getLastValue() {
-    return _last_value_double;
-}
-template<> char* Child::getLastValue() {
-    return _last_value_string;
-}
-
-
 /*
    Sensor class
 */
@@ -452,7 +408,8 @@ void Sensor::loop(const MyMessage & message) {
     // turn the sensor on
     if (_auto_power_pins) powerOn();
   #endif
-  // iterates over all the children
+  
+  // FOR ALL CHILD
   for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
     Child child = (*itr);
     // for numeric sensor requiring multiple samples, keep track of the total
@@ -469,32 +426,32 @@ void Sensor::loop(const MyMessage & message) {
         onLoop(child);
       }
       // for integers, floats and doubles, keep track of the total
-      if (child.value_type == TYPE_INTEGER) total += (float)child.getValue<int>();
-      else if (child.value_type == TYPE_FLOAT) total += child.getValue<float>();
-      else if (child.value_type == TYPE_DOUBLE) total += child.getValue<double>();
+      if (_value_type == TYPE_INTEGER) total += (float)_value_int;
+      else if (_value_type == TYPE_FLOAT) total += _value_float;
+      else if (_value_type == TYPE_DOUBLE) total += _value_double;
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
-    if (child.value_type == TYPE_INTEGER && total > -255) {
+    if (_value_type == TYPE_INTEGER && total > -1) {
       // if the value is an integer, calculate the average value of the samples
       int avg = (int) (total / _samples);
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<int>()))  {
-        child.setLastValue<int>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != _last_value_int))  {
+        _last_value_int = avg;
         _sendSensorMessage(_msg->set(avg));
-        child.setValue<int>(-255);
+        _value_int = -1;
       }
     }
     // process a float value
-    else if (_value_type == TYPE_FLOAT && total > -255) {
+    else if (_value_type == TYPE_FLOAT && total > -1) {
       // calculate the average value of the samples
       float avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<float>()))  {
-        child.setLastValue<float>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != _last_value_float))  {
+        _last_value_float = avg;
         _sendSensorMessage(_msg->set(avg, _float_precision));
-        child.setValue<float>(-255);
+        _value_float = -1;
       }
     }
     // process a double value
@@ -502,19 +459,19 @@ void Sensor::loop(const MyMessage & message) {
       // calculate the average value of the samples
       double avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<double>()))  {
-        child.setLastValue<double>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != _last_value_double))  {
+        _last_value_double = avg;
         _sendSensorMessage(_msg->set(avg, _double_precision));
-        child.setValue<double>(-255);
+        _value_double = -1;
       }
     }
     // process a string value
     else if (_value_type == TYPE_STRING) {
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(strcmp(child.getValue<char*>(), child.getLastValue<char*>()) != 0))  {
-        child.setLastValue<char*>(child.getValue<char*>());
-        _sendSensorMessage(_msg->set(child.getValue<char*>()));
-        child.setValue<char*>("");
+      if (_isReceive(message) || _isWorthSending(strcmp(_value_string, _last_value_string) != 0))  {
+        _last_value_string = _value_string;
+        _sendSensorMessage(_msg->set(_value_string));
+        _value_string = "";
       }
     }
   }
@@ -1380,7 +1337,7 @@ void SensorSHT21::onLoop(Child child) {
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) child.setValue<float>(temperature);
+    if (! isnan(temperature)) _value_float = temperature;
   }
   // Humidity Sensor
   else if (child.type == V_HUM) {
@@ -1394,7 +1351,7 @@ void SensorSHT21::onLoop(Child child) {
       Serial.println(humidity);
     #endif
     // store the value
-   if (! isnan(humidity)) child.setValue<float>(humidity);
+   if (! isnan(humidity)) _value_float = humidity;
   }
 }
 
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -283,20 +283,13 @@ template<> char* Child::getLastValue() {
    Sensor class
 */
 // constructor
-Sensor::Sensor() {
-  
-}
-Sensor::Sensor(NodeManager& nodeManager, int pin) {
-  _node_manager = &nodeManager;
+Sensor::Sensor(NodeManager* node_manager, int child_id, int pin) {
+  _node_manager = node_manager;
+  _child_id = child_id;
   _pin = pin;
   _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
-  _node_manager->registerSensor(this);
-}
-
-void Sensor::init(NodeManager* nodeManager) {
-  _node_manager = nodeManager;
 }
 
 // setter/getter
@@ -406,15 +399,15 @@ void Sensor::setInterrupt(int pin, int mode, int initial) {
 
 // present the sensor to the gateway and controller
 void Sensor::presentation() {
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    Child child = (*itr);
   #if DEBUG == 1
     Serial.print(F("PRES I="));
-    Serial.print(child->child_id);
+    Serial.print(child.child_id);
     Serial.print(F(" T="));
-    Serial.println(child->presentation);
+    Serial.println(child.presentation);
   #endif
-  present(child->child_id, child->presentation,child->description,_node_manager->getAck());
+  present(child.child_id, child.presentation,child.description,_node_manager->getAck());
   }
 
 }
@@ -451,8 +444,8 @@ void Sensor::loop(const MyMessage & message) {
     if (_auto_power_pins) powerOn();
   #endif
   // iterates over all the children
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    Child child = (*itr);
     // for numeric sensor requiring multiple samples, keep track of the total
     double total = 0;
     // collect multiple samples if needed
@@ -467,21 +460,21 @@ void Sensor::loop(const MyMessage & message) {
         onLoop(child);
       }
       // for integers, floats and doubles, keep track of the total
-      if (child->value_type == TYPE_INTEGER) total += (float)child->getValue<int>();
-      else if (child->value_type == TYPE_FLOAT) total += child->getValue<float>();
-      else if (child->value_type == TYPE_DOUBLE) total += child->getValue<double>();
+      if (child.value_type == TYPE_INTEGER) total += (float)child.getValue<int>();
+      else if (child.value_type == TYPE_FLOAT) total += child.getValue<float>();
+      else if (child.value_type == TYPE_DOUBLE) total += child.getValue<double>();
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
-    if (child->value_type == TYPE_INTEGER && total > -255) {
+    if (child.value_type == TYPE_INTEGER && total > -255) {
       // if the value is an integer, calculate the average value of the samples
       int avg = (int) (total / _samples);
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<int>()))  {
-        child->setLastValue<int>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<int>()))  {
+        child.setLastValue<int>(avg);
         _sendSensorMessage(_msg->set(avg));
-        child->setValue<int>(-255);
+        child.setValue<int>(-255);
       }
     }
     // process a float value
@@ -489,10 +482,10 @@ void Sensor::loop(const MyMessage & message) {
       // calculate the average value of the samples
       float avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<float>()))  {
-        child->setLastValue<float>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<float>()))  {
+        child.setLastValue<float>(avg);
         _sendSensorMessage(_msg->set(avg, _float_precision));
-        child->setValue<float>(-255);
+        child.setValue<float>(-255);
       }
     }
     // process a double value
@@ -500,19 +493,19 @@ void Sensor::loop(const MyMessage & message) {
       // calculate the average value of the samples
       double avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<double>()))  {
-        child->setLastValue<double>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<double>()))  {
+        child.setLastValue<double>(avg);
         _sendSensorMessage(_msg->set(avg, _double_precision));
-        child->setValue<double>(-255);
+        child.setValue<double>(-255);
       }
     }
     // process a string value
     else if (_value_type == TYPE_STRING) {
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(strcmp(child->getValue<char*>(), child->getLastValue<char*>()) != 0))  {
-        child->setLastValue<char*>(child->getValue<char*>());
-        _sendSensorMessage(_msg->set(child->getValue<char*>()));
-        child->setValue<char*>("");
+      if (_isReceive(message) || _isWorthSending(strcmp(child.getValue<char*>(), child.getLastValue<char*>()) != 0))  {
+        child.setLastValue<char*>(child.getValue<char*>());
+        _sendSensorMessage(_msg->set(child.getValue<char*>()));
+        child.setValue<char*>("");
       }
     }
   }
@@ -580,14 +573,6 @@ void Sensor::process(Request & request) {
   _sendServiceMessage(_msg->set(function));
 }
 
-// virtual functions
-void Sensor::onBefore(){}
-void Sensor::onSetup(){}
-void Sensor::onLoop(Child* child){}
-void Sensor::onReceive(const MyMessage & message){}
-void Sensor::onProcess(Request & request){}
-void Sensor::onInterrupt(){}
-
 // send a message to the network
 void Sensor::_sendSensorMessage(MyMessage & message) {
 	// setup the message
@@ -662,7 +647,7 @@ void SensorAnalogInput::onSetup() {
 }
 
 // what to do during loop
-void SensorAnalogInput::onLoop(Child* child) {
+void SensorAnalogInput::onLoop(Child child) {
   // read the input
   int adc = _getAnalogRead();
   // calculate the percentage
@@ -783,7 +768,7 @@ void SensorThermistor::onSetup() {
 }
 
 // what to do during loop
-void SensorThermistor::onLoop(Child* child) {
+void SensorThermistor::onLoop(Child child) {
   // read the voltage across the thermistor
   float adc = analogRead(_pin);
   // calculate the temperature
@@ -855,7 +840,7 @@ void SensorML8511::onSetup() {
 }
 
 // what to do during loop
-void SensorML8511::onLoop(Child* child) {
+void SensorML8511::onLoop(Child child) {
   // read the voltage 
   int uvLevel = analogRead(_pin);
   int refLevel = _node_manager->getVcc()*1024/3.3;
@@ -924,7 +909,7 @@ void SensorACS712::onSetup() {
 }
 
 // what to do during loop
-void SensorACS712::onLoop(Child* child) {
+void SensorACS712::onLoop(Child child) {
   int value = analogRead(_pin);
   // convert the analog read in mV
   double voltage = (value / 1024.0) * 5000; 
@@ -1010,7 +995,7 @@ void SensorDigitalInput::onSetup() {
 }
 
 // what to do during loop
-void SensorDigitalInput::onLoop(Child* child) {
+void SensorDigitalInput::onLoop(Child child) {
   // read the value
   int value = digitalRead(_pin);
   #if DEBUG == 1
@@ -1080,7 +1065,7 @@ void SensorDigitalOutput::setWaitAfterSet(int value) {
 }
 
 // main task
-void SensorDigitalOutput::onLoop(Child* child) {
+void SensorDigitalOutput::onLoop(Child child) {
   // set the value to -1 so to avoid reporting to the gateway during loop
   _value_int = -1;
   _last_value_int = -1;
@@ -1305,7 +1290,7 @@ void SensorDHT::onSetup() {
 }
 
 // what to do during loop
-void SensorDHT::onLoop(Child* child) {
+void SensorDHT::onLoop(Child child) {
   _node_manager->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
@@ -1356,14 +1341,13 @@ void SensorDHT::onInterrupt() {
 */
 #if MODULE_SHT21 == 1
 // contructor
-SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-
+SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
+  _children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  _children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   // initialize the library
   Wire.begin();
 }
@@ -1373,43 +1357,43 @@ void SensorSHT21::onSetup() {
 }
 
 // what to do during loop
-void SensorSHT21::onLoop(Child* child) {
+void SensorSHT21::onLoop(Child child) {
   // temperature sensor
-  if (child->type == V_TEMP) {
+  if (child.type == V_TEMP) {
     // read the temperature
     float temperature = SHT2x.GetTemperature();
     // convert it
     temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("SHT I="));
-      Serial.print(child->child_id);
+      Serial.print(child.child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) child->setValue<float>(temperature);
+    if (! isnan(temperature)) child.setValue<float>(temperature);
   }
   // Humidity Sensor
-  else if (child->type == V_HUM) {
+  else if (child.type == V_HUM) {
     // read humidity
     float humidity = SHT2x.GetHumidity();
     if (isnan(humidity)) return;
     #if DEBUG == 1
       Serial.print(F("SHT I="));
-      Serial.print(child->child_id);
+      Serial.print(child.child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
     #endif
     // store the value
-   if (! isnan(humidity)) child->setValue<float>(humidity);
+   if (! isnan(humidity)) child.setValue<float>(humidity);
   }
 }
 
 // what to do as the main task when receiving a message
 void SensorSHT21::onReceive(const MyMessage & message) {
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
-    if (message.getCommand() == C_REQ && child->child_id == message.sensor) onLoop(child);
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    Child child = (*itr);
+    if (message.getCommand() == C_REQ && child.child_id == message.sensor) onLoop(child);
   }
 }
 
@@ -1427,7 +1411,7 @@ void SensorSHT21::onInterrupt() {
  */
  #if MODULE_SHT21 == 1
 // constructor
-SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
+SensorHTU21D::SensorHTU21D(NodeManager* node_manager, int child_id, int pin): SensorSHT21(node_manager, child_id, pin) {
 }
 #endif 
 
@@ -1466,7 +1450,7 @@ void SensorSwitch::onSetup() {
 }
 
 // what to do during loop
-void SensorSwitch::onLoop(Child* child) {
+void SensorSwitch::onLoop(Child child) {
 }
 
 // what to do as the main task when receiving a message
@@ -1555,7 +1539,7 @@ void SensorDs18b20::onSetup() {
 }
 
 // what to do during loop
-void SensorDs18b20::onLoop(Child* child) {
+void SensorDs18b20::onLoop(Child child) {
   // do not wait for conversion, will sleep manually during it
   if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
   // request the temperature
@@ -1646,7 +1630,7 @@ void SensorBH1750::onSetup() {
 }
 
 // what to do during loop
-void SensorBH1750::onLoop(Child* child) {
+void SensorBH1750::onLoop(Child child) {
   // request the light level
   _value_int = _lightSensor->readLightLevel();
   #if DEBUG == 1
@@ -1703,7 +1687,7 @@ void SensorMLX90614::onSetup() {
 }
 
 // what to do during loop
-void SensorMLX90614::onLoop(Child* child) {
+void SensorMLX90614::onLoop(Child child) {
   float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -1780,7 +1764,7 @@ void SensorBosch::onSetup() {
 }
 
 // what to do during loop
-void SensorBosch::onLoop(Child* child) {
+void SensorBosch::onLoop(Child child) {
 }
 
 // what to do as the main task when receiving a message
@@ -1919,7 +1903,7 @@ SensorBME280::SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME
   _bme = bme;
 }
 
-void SensorBME280::onLoop(Child* child) {
+void SensorBME280::onLoop(Child child) {
   // temperature sensor
   if (_sensor_type == SensorBME280::TEMPERATURE) {
     // read the temperature
@@ -1983,7 +1967,7 @@ SensorBMP085::SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP
 }
 
 // what to do during loop
-void SensorBMP085::onLoop(Child* child) {
+void SensorBMP085::onLoop(Child child) {
   // temperature sensor
   if (_sensor_type == SensorBMP085::TEMPERATURE) {
     // read the temperature
@@ -2030,7 +2014,7 @@ SensorBMP280::SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP
   _bmp = bmp;
 }
 
-void SensorBMP280::onLoop(Child* child) {
+void SensorBMP280::onLoop(Child child) {
   // temperature sensor
   if (_sensor_type == SensorBMP280::TEMPERATURE) {
     // read the temperature
@@ -2105,7 +2089,7 @@ void SensorHCSR04::onSetup() {
 }
 
 // what to do during loop
-void SensorHCSR04::onLoop(Child* child) {
+void SensorHCSR04::onLoop(Child child) {
   int distance = _node_manager->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
   #if DEBUG == 1
     Serial.print(F("HC I="));
@@ -2180,7 +2164,7 @@ void SensorSonoff::onSetup() {
 }
 
 // what to do during loop
-void SensorSonoff::onLoop(Child* child) {
+void SensorSonoff::onLoop(Child child) {
   _debouncer.update();
   // Get the update value from the button
   int value = _debouncer.read();
@@ -2273,7 +2257,7 @@ void SensorMCP9808::onSetup() {
 }
 
 // what to do during loop
-void SensorMCP9808::onLoop(Child* child) {
+void SensorMCP9808::onLoop(Child child) {
   float temperature = _mcp->readTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -2366,7 +2350,7 @@ void SensorMQ::onSetup() {
 }
 
 // what to do during loop
-void SensorMQ::onLoop(Child* child) {
+void SensorMQ::onLoop(Child child) {
   if (_pin == -1) return;
   // calculate rs/ro
   float mq = _MQRead()/_ro;
@@ -2506,7 +2490,7 @@ void SensorMHZ19::onSetup() {
 }
 
 // what to do during loop
-void SensorMHZ19::onLoop(Child* child) {
+void SensorMHZ19::onLoop(Child child) {
   // Read the ppm value
   int co2ppm = readCO2(); // This is there the function gets called that talks to the Co2 sensor.
   #if DEBUG == 1
@@ -2610,7 +2594,7 @@ void SensorAM2320::onSetup() {
 }
 
 // what do to during loop
-void SensorAM2320::onLoop(Child* child) {
+void SensorAM2320::onLoop(Child child) {
   switch(_th->Read()) {
     case 0:
       // temperature sensor
@@ -2728,7 +2712,7 @@ void SensorTSL2561::onSetup() {
 }
 
 // what do to during loop
-void SensorTSL2561::onLoop(Child* child) {
+void SensorTSL2561::onLoop(Child child) {
   // request the light level
    switch (_tsl_spectrum) {
     case SensorTSL2561::VISIBLE:
@@ -2823,7 +2807,7 @@ void SensorPT100::onSetup() {
 }
 
 // what to do during loop
-void SensorPT100::onLoop(Child* child) {
+void SensorPT100::onLoop(Child child) {
   // read the PT100 sensor
   int temperature = _PT100->readTemperature(_pin);  
   #if DEBUG == 1
@@ -2889,7 +2873,7 @@ void SensorDimmer::onSetup() {
 }
 
 // what to do during loop
-void SensorDimmer::onLoop(Child* child) {
+void SensorDimmer::onLoop(Child child) {
 }
 
 // what to do as the main task when receiving a message
@@ -2989,7 +2973,7 @@ void SensorPulseMeter::onSetup() {
 }
 
 // what to do during loop
-void SensorPulseMeter::onLoop(Child* child) {
+void SensorPulseMeter::onLoop(Child child) {
   // do not report anything if called by an interrupt
   if (_node_manager->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
@@ -3251,17 +3235,17 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
   #if MODULE_SHT21 == 1
     else if (sensor_type == SENSOR_SHT21) {
       // register temperature sensor
-      //registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
+      registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
       // register humidity sensor
       //child_id = _getAvailableChildId();
       //return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
     }
     else if (sensor_type == SENSOR_HTU21D) {
       // register temperature sensor
-      //registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::TEMPERATURE));
+      registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::TEMPERATURE));
       // register humidity sensor
       child_id = _getAvailableChildId();
-//      return registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::HUMIDITY));
+      return registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::HUMIDITY));
     }
   #endif
   #if MODULE_SWITCH == 1
@@ -3422,13 +3406,8 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
   };
 }
 
-void NodeManager::registerSensor(Sensor* sensor) {
-  sensors.push(*sensor);
-}
-
-/*
 // attach a built-in or custom sensor to this manager
-int NodeManager::registerSensorOLD(Sensor* sensor) {
+int NodeManager::registerSensor(Sensor* sensor) {
   if (sensor->getChildId() > MAX_SENSORS) return;
   #if DEBUG == 1
     Serial.print(F("REG I="));
@@ -3449,7 +3428,37 @@ int NodeManager::registerSensor(Sensor* sensor) {
   // return the child_id
   return sensor->getChildId();
 }
-*/
+
+// un-register a sensor to this manager
+void NodeManager::unRegisterSensor(int sensor_index) {
+  if (sensor_index > MAX_SENSORS) return;
+  // unlink the pointer to this sensor
+  _sensors[sensor_index] == 0;
+}
+
+// return a sensor given its index
+Sensor* NodeManager::get(int child_id) {
+  if (child_id > MAX_SENSORS) return 0;
+  // return a pointer to the sensor from the given child_id
+  return _sensors[child_id];
+}
+Sensor* NodeManager::getSensor(int child_id) {
+  return get(child_id);
+}
+
+// assign a different child id to a sensor'
+bool NodeManager::renameSensor(int old_child_id, int new_child_id) {
+  if (old_child_id > MAX_SENSORS || new_child_id > MAX_SENSORS) return;
+  // ensure the old id exists and the new is available
+  if (_sensors[old_child_id] == 0 || _sensors[new_child_id] != 0) return false;
+  // assign the sensor to new id
+  _sensors[new_child_id] = _sensors[old_child_id];
+  // set the new child id
+  _sensors[new_child_id]->setChildId(new_child_id);
+  // free up the old id
+  _sensors[old_child_id] = 0;
+  return true;
+}
 
 // setup NodeManager
 void NodeManager::before() {
@@ -3503,12 +3512,12 @@ void NodeManager::before() {
     _signal_report_timer.start();
   #endif
   // setup individual sensors
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+  for (int i = 1; i <= MAX_SENSORS; i++) {
+    if (_sensors[i] == 0) continue;
     // configure reporting interval
-    if (! sensor->isReportIntervalConfigured()) sensor->setReportIntervalSeconds(_report_interval_seconds);
+    if (! _sensors[i]->isReportIntervalConfigured()) _sensors[i]->setReportIntervalSeconds(_report_interval_seconds);
     // call each sensor's before()
-    sensor->before();
+    _sensors[i]->before();
   }
   // setup the interrupt pins
   setupInterrupts();
@@ -3537,11 +3546,11 @@ void NodeManager::presentation() {
     signalReport();
   #endif
   // present each sensor
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+  for (int i = 1; i <= MAX_SENSORS; i++) {
+    if (_sensors[i] == 0) continue;
     // call each sensor's presentation()
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
-    sensor->presentation();
+    _sensors[i]->presentation();
   }
   #if DEBUG == 1
     Serial.println(F("READY"));
@@ -3564,10 +3573,10 @@ void NodeManager::setup() {
 	_sendUsingConfigChild(_msg.set("STARTED"));
   #endif
   // run setup for all the registered sensors
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+  for (int i = 1; i <= MAX_SENSORS; i++) {
+    if (_sensors[i] == 0) continue;
     // call each sensor's setup()
-    sensor->setup();
+    _sensors[i]->setup();
   }
 }
 
@@ -3600,20 +3609,21 @@ void NodeManager::loop() {
     if (_auto_power_pins) powerOn();
   #endif
   // run loop for all the registered sensors
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
-    if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
+  for (int i = 1; i <= MAX_SENSORS; i++) {
+    // skip unconfigured sensors
+    if (_sensors[i] == 0) continue;
+    if (_last_interrupt_pin != -1 && _sensors[i]->getInterruptPin() == _last_interrupt_pin) {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
       _msg.clear();
-      sensor->interrupt();
-      sensor->loop(_msg);
+      _sensors[i]->interrupt();
+      _sensors[i]->loop(_msg);
         // reset the last interrupt pin
       _last_interrupt_pin = -1;
     }
     else if (_last_interrupt_pin == -1) {
       // if just at the end of a cycle, call the sensor's loop() 
       _msg.clear();
-      sensor->loop(_msg);
+      _sensors[i]->loop(_msg);
     }
   }
   #if POWER_MANAGER == 1
@@ -3648,23 +3658,17 @@ void NodeManager::receive(const MyMessage &message) {
     #endif
   }
   // dispatch the message to the registered sensor
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
-    for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
-      Child* child = itr1;
-      if (message.sensor == child->child_id) {
-        #if POWER_MANAGER == 1
-          // turn on the pin powering all the sensors
-          if (_auto_power_pins) powerOn();
-        #endif
-        // call the sensor's receive()
-        sensor->receive(message);
-        #if POWER_MANAGER == 1
-          // turn off the pin powering all the sensors
-          if (_auto_power_pins) powerOff();
-        #endif
-      }
-    }
+  else if (message.sensor <= MAX_SENSORS && _sensors[message.sensor] != 0) {
+    #if POWER_MANAGER == 1
+      // turn on the pin powering all the sensors
+      if (_auto_power_pins) powerOn();
+    #endif
+    // call the sensor's receive()
+     _sensors[message.sensor]->receive(message);
+    #if POWER_MANAGER == 1
+      // turn off the pin powering all the sensors
+      if (_auto_power_pins) powerOff();
+    #endif
   }
 }
 
@@ -3749,6 +3753,7 @@ void NodeManager::process(Request & request) {
       case 24: powerOn(); break;
       case 25: powerOff(); break;
     #endif
+    case 26: unRegisterSensor(request.getValueInt()); break;
     case 27: saveToMemory(0,request.getValueInt()); break;
     case 28: setInterruptMinDelta(request.getValueInt()); break;
     case 30: setSleepOrWait(request.getValueInt()); break;
@@ -4135,10 +4140,13 @@ void NodeManager::_present(int child_id, int type) {
 
 // return the next available child_id
 int NodeManager::_getAvailableChildId() {
-  _child_id_counter++;
-  if (_child_id_counter == CONFIGURATION_CHILD_ID) _child_id_counter++;
-  if (_child_id_counter == BATTERY_CHILD_ID) _child_id_counter++;
-  return _child_id_counter;
+  for (int i = 1; i <= MAX_SENSORS; i++) {
+    if (i == CONFIGURATION_CHILD_ID) continue;
+    if (i == BATTERY_CHILD_ID) continue;
+    // empty place, return it
+    if (_sensors[i] == 0) return i;
+  }
+  return MAX_SENSORS;
 }
 
 // guess the initial value of a digital output based on the configured interrupt mode
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -292,7 +292,11 @@ Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
-  //_node_manager->registerSensor(this);
+  _node_manager->registerSensor(this);
+}
+
+void Sensor::init(NodeManager* nodeManager) {
+  _node_manager = nodeManager;
 }
 
 // setter/getter
@@ -419,17 +423,6 @@ void Sensor::presentation() {
 void Sensor::before() {
   if (_pin == -1) return;
   onBefore();
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
-    #if DEBUG == 1
-      Serial.print(F("CHILD I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" P="));
-      Serial.print(child->presentation);
-      Serial.print(F(" T="));
-      Serial.println(child->type);
-    #endif
-  }
 }
 
 // call the sensor-specific implementation of setup
@@ -588,9 +581,7 @@ void Sensor::process(Request & request) {
 }
 
 // virtual functions
-void Sensor::onBefore(){
-  Serial.println("NO");
-}
+void Sensor::onBefore(){}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
 void Sensor::onReceive(const MyMessage & message){}
@@ -1366,14 +1357,11 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-     children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,"")); 
-  _node_manager->registerSensor(this);
+
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  Serial.println("SHT");
   children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
   children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   // initialize the library
@@ -3224,7 +3212,6 @@ bool NodeManager::isSleepingNode() {
   return false;
 }
 
-/*
 // register a sensor to this manager
 int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
   // get a child_id if not provided by the user
@@ -3434,9 +3421,10 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
     return -1;
   };
 }
-/*
-
 
+void NodeManager::registerSensor(Sensor* sensor) {
+  sensors.push(*sensor);
+}
 
 /*
 // attach a built-in or custom sensor to this manager
@@ -3463,10 +3451,6 @@ int NodeManager::registerSensorOLD(Sensor* sensor) {
 }
 */
 
-void NodeManager::registerSensor(Sensor* sensor) {
-  sensors.push(sensor);
-}
-
 // setup NodeManager
 void NodeManager::before() {
   // print out the version
@@ -3664,7 +3648,7 @@ void NodeManager::receive(const MyMessage &message) {
     #endif
   }
   // dispatch the message to the registered sensor
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = itr;
     for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
       Child* child = itr1;
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -292,7 +292,7 @@ Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
-  _node_manager->registerSensor(this);
+  //_node_manager->registerSensor(this);
 }
 
 // setter/getter
@@ -422,8 +422,7 @@ void Sensor::before() {
   for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = itr;
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
+      Serial.print(F("CHILD I="));
       Serial.print(child->child_id);
       Serial.print(F(" P="));
       Serial.print(child->presentation);
@@ -1367,11 +1366,14 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-  _name = "SHT";
+     children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,"")); 
+  _node_manager->registerSensor(this);
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
+  Serial.println("SHT");
   children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
   children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   // initialize the library
@@ -1391,8 +1393,7 @@ void SensorSHT21::onLoop(Child* child) {
     // convert it
     temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
+      Serial.print(F("SHT I="));
       Serial.print(child->child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
@@ -3518,8 +3519,8 @@ void NodeManager::before() {
     _signal_report_timer.start();
   #endif
   // setup individual sensors
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
     // configure reporting interval
     if (! sensor->isReportIntervalConfigured()) sensor->setReportIntervalSeconds(_report_interval_seconds);
     // call each sensor's before()
@@ -3552,8 +3553,8 @@ void NodeManager::presentation() {
     signalReport();
   #endif
   // present each sensor
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
     // call each sensor's presentation()
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
     sensor->presentation();
@@ -3579,8 +3580,8 @@ void NodeManager::setup() {
 	_sendUsingConfigChild(_msg.set("STARTED"));
   #endif
   // run setup for all the registered sensors
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
     // call each sensor's setup()
     sensor->setup();
   }
@@ -3615,8 +3616,8 @@ void NodeManager::loop() {
     if (_auto_power_pins) powerOn();
   #endif
   // run loop for all the registered sensors
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
     if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
       _msg.clear();
@@ -3664,7 +3665,7 @@ void NodeManager::receive(const MyMessage &message) {
   }
   // dispatch the message to the registered sensor
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
+    Sensor* sensor = itr;
     for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
       Child* child = itr1;
       if (message.sensor == child->child_id) {
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -220,7 +220,7 @@ Child::Child() {
 }
 
 // constructor
-Child::Child(int _child_id, int _presentation, int _type, int _value_type = TYPE_INTEGER, char* _description = "") {
+Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
   child_id = _child_id;
   presentation = _presentation;
   type = _type;
@@ -286,7 +286,6 @@ template<> char* Child::getLastValue() {
 Sensor::Sensor() {
   
 }
-
 Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _node_manager = &nodeManager;
   _pin = pin;
@@ -589,17 +588,10 @@ void Sensor::process(Request & request) {
   _sendServiceMessage(_msg->set(function));
 }
 
-// return the requested child 
-Child* Sensor::getChild(int child_id) {
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
-    if (child->child_id == child_id) return child;
-  }
-  return nullptr;
+// virtual functions
+void Sensor::onBefore(){
+  Serial.println("NO");
 }
-
-// virtual functions
-void Sensor::onBefore() {}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
 void Sensor::onReceive(const MyMessage & message){}
@@ -1375,13 +1367,13 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-  _name = F("SHT");
+  _name = "SHT";
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  children.push(Child(_node_manager->getAvailableChildId(),S_TEMP,V_TEMP,TYPE_FLOAT));
-  children.push(Child(_node_manager->getAvailableChildId(),S_HUM,V_HUM,TYPE_FLOAT));
+  children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   // initialize the library
   Wire.begin();
 }
@@ -1414,8 +1406,7 @@ void SensorSHT21::onLoop(Child* child) {
     float humidity = SHT2x.GetHumidity();
     if (isnan(humidity)) return;
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
+      Serial.print(F("SHT I="));
       Serial.print(child->child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
@@ -1427,9 +1418,10 @@ void SensorSHT21::onLoop(Child* child) {
 
 // what to do as the main task when receiving a message
 void SensorSHT21::onReceive(const MyMessage & message) {
-  Child* child = getChild(message.sensor);
-  if (child == nullptr) return;
-  if (message.getCommand() == C_REQ) onLoop(child);
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
+    if (message.getCommand() == C_REQ && child->child_id == message.sensor) onLoop(child);
+  }
 }
 
 // what to do when receiving a remote message
@@ -3671,18 +3663,23 @@ void NodeManager::receive(const MyMessage &message) {
     #endif
   }
   // dispatch the message to the registered sensor
-  Sensor* sensor = getSensorWithChild(message.sensor);
-  if (sensor != nullptr) {
-    #if POWER_MANAGER == 1
-      // turn on the pin powering all the sensors
-      if (_auto_power_pins) powerOn();
-    #endif
-    // call the sensor's receive()
-    sensor->receive(message);
-    #if POWER_MANAGER == 1
-      // turn off the pin powering all the sensors
-      if (_auto_power_pins) powerOff();
-    #endif
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
+    for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
+      Child* child = itr1;
+      if (message.sensor == child->child_id) {
+        #if POWER_MANAGER == 1
+          // turn on the pin powering all the sensors
+          if (_auto_power_pins) powerOn();
+        #endif
+        // call the sensor's receive()
+        sensor->receive(message);
+        #if POWER_MANAGER == 1
+          // turn off the pin powering all the sensors
+          if (_auto_power_pins) powerOff();
+        #endif
+      }
+    }
   }
 }
 
@@ -4009,16 +4006,6 @@ void NodeManager::sleepOrWait(long value) {
   }
 #endif
 
-// return the next available child_id
-int NodeManager::getAvailableChildId() {
-  for (int i = 1; i < 255; i++) {
-    if (i == CONFIGURATION_CHILD_ID || i == BATTERY_CHILD_ID || i == SIGNAL_CHILD_ID) continue;
-    Child* child = getChild(i);
-    if (child == nullptr) return i;
-  }
-  return 255;
-}
-
 // handle an interrupt
 void NodeManager::_onInterrupt_1() {
   long now = millis();
@@ -4094,23 +4081,6 @@ void NodeManager::sendMessage() {
   }
 }
 
-// return the requested child 
-Child* NodeManager::getChild(int child_id) {
-  Sensor* sensor = getSensorWithChild(child_id);
-  if (sensor == nullptr) return nullptr;
-  return sensor->getChild(child_id);
-}
-
-// return the sensor with the requested child 
-Sensor* NodeManager::getSensorWithChild(int child_id) {
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
-    Child* child = sensor->getChild(child_id);
-    if (child != nullptr) return sensor;
-  }
-  return nullptr;  
-}
-
 // wrapper of smart sleep
 void NodeManager::_sleep() {
   #if DEBUG == 1
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -494,7 +494,7 @@ void Sensor::loop(const MyMessage & message) {
       }
     }
     // process a float value
-    else if (child->value_type == TYPE_FLOAT && total > -255) {
+    else if (_value_type == TYPE_FLOAT && total > -255) {
       // calculate the average value of the samples
       float avg = total / _samples;
       // report the value back
@@ -505,7 +505,7 @@ void Sensor::loop(const MyMessage & message) {
       }
     }
     // process a double value
-    else if (child->value_type == TYPE_DOUBLE && total > -1) {
+    else if (_value_type == TYPE_DOUBLE && total > -1) {
       // calculate the average value of the samples
       double avg = total / _samples;
       // report the value back
@@ -516,7 +516,7 @@ void Sensor::loop(const MyMessage & message) {
       }
     }
     // process a string value
-    else if (child->value_type == TYPE_STRING) {
+    else if (_value_type == TYPE_STRING) {
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
       if (_isReceive(message) || _isWorthSending(strcmp(child->getValue<char*>(), child->getLastValue<char*>()) != 0))  {
         child->setLastValue<char*>(child->getValue<char*>());
@@ -643,149 +643,6 @@ bool Sensor::_isWorthSending(bool comparison) {
   return false;
 }
 
-/*
-   SensorBattery
-*/
-// contructor
-SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-  _name = F("BAT");
-  // report battery level every 60 minutes by default
-  setReportIntervalMinutes(60);
-}
-void SensorBattery::setMinVoltage(float value) {
-  _battery_min = value;
-}
-void SensorBattery::setMaxVoltage(float value) {
-  _battery_max = value;
-}
-void SensorBattery::setBatteryInternalVcc(bool value) {
-  _battery_internal_vcc = value;
-}
-void SensorBattery::setBatteryPin(int value) {
-  _battery_pin = value;
-}
-void SensorBattery::setBatteryVoltsPerBit(float value) {
-  _battery_volts_per_bit = value;
-}
-void SensorBattery::setBatteryReportWithInterrupt(bool value) {
-  _battery_report_with_interrupt = value;
-}
-
-// what to do during before
-void SensorBattery::onBefore() {
-  children.push(Child(BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE,TYPE_FLOAT));
-}
-
-// what to do during setup
-void SensorBattery::onSetup() {
-  if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
-}
-
-// what to do during loop
-void SensorBattery::onLoop(Child* child) {
-  // measure the board vcc
-  float volt = 0;
-  if (_battery_internal_vcc || _battery_pin == -1) volt = _node_manager->getVcc();
-  else volt = analogRead(_battery_pin) * _battery_volts_per_bit;
-  // calculate the percentage
-  int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
-  if (percentage > 100) percentage = 100;
-  if (percentage < 0) percentage = 0;
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" V="));
-    Serial.print(volt);
-    Serial.print(F(" %="));
-    Serial.println(percentage);
-  #endif
-  child->setValue<float>(volt);
-  // report battery level percentage
-  sendBatteryLevel(percentage);
-}
-
-// what to do as the main task when receiving a message
-void SensorBattery::onReceive(const MyMessage & message) {
-  Child* child = getChild(message.sensor);
-  if (child == nullptr) return;
-  if (message.getCommand() == C_REQ) onLoop(child);
-}
-
-// what to do when receiving a remote message
-void SensorBattery::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 102: setMinVoltage(request.getValueFloat()); break;
-    case 103: setMaxVoltage(request.getValueFloat()); break;
-    case 104: setBatteryInternalVcc(request.getValueInt()); break;
-    case 105: setBatteryPin(request.getValueInt()); break;
-    case 106: setBatteryVoltsPerBit(request.getValueFloat()); break;
-    case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
-    default: return;
-  }
-  _sendServiceMessage(_msg->set(function));
-}
-
-// what to do when receiving an interrupt
-void SensorBattery::onInterrupt() {
-}
-
-/*
-   SensorSignal
-*/
-// contructor
-SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-  _name = F("SIG");
-  // report signal level every 60 minutes by default
-  setReportIntervalMinutes(60);
-}
-// setter/getter
-void SensorSignal::setSignalCommand(int value) {
-  _signal_command = value;
-}
-
-// what to do during before
-void SensorSignal::onBefore() {
-  children.push(Child(SIGNAL_CHILD_ID,S_SOUND,V_LEVEL));
-}
-
-// what to do during setup
-void SensorSignal::onSetup() {
-
-}
-
-// what to do during loop
-void SensorSignal::onLoop(Child* child) {
-  int16_t value = transportGetSignalReport(_signal_command);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" V="));
-    Serial.println(value);
-  #endif
-  child->setValue<int>(value);
-}
-
-// what to do as the main task when receiving a message
-void SensorSignal::onReceive(const MyMessage & message) {
-  Child* child = getChild(message.sensor);
-  if (child == nullptr) return;
-  if (message.getCommand() == C_REQ) onLoop(child);
-}
-
-// what to do when receiving a remote message
-void SensorSignal::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setSignalCommand(request.getValueInt()); break;
-    default: return;
-  }
-  _sendServiceMessage(_msg->set(function));
-}
-
-// what to do when receiving an interrupt
-void SensorSignal::onInterrupt() {
-}
-
-
 #if MODULE_ANALOG_INPUT == 1
 /*
    SensorAnalogInput
@@ -3656,6 +3544,18 @@ void NodeManager::before() {
     // restore the configuration saved in the eeprom
     _loadConfig();
   #endif
+  #if BATTERY_MANAGER == 1 && !defined(MY_GATEWAY_ESP8266)
+    // set analogReference to internal if measuring the battery through a pin
+    if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
+    // if not already configured, report battery level every 60 minutes
+    if (! _battery_report_timer.isConfigured()) _battery_report_timer.set(60,MINUTES);
+    _battery_report_timer.start();
+  #endif
+  #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
+    // if not already configured, report signal level every 60 minutes
+    if (! _signal_report_timer.isConfigured()) _signal_report_timer.set(60,MINUTES);
+    _signal_report_timer.start();
+  #endif
   // setup individual sensors
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3678,6 +3578,18 @@ void NodeManager::presentation() {
   sendSketchInfo(SKETCH_NAME,SKETCH_VERSION);
   // present the service as a custom sensor to the controller
   _present(CONFIGURATION_CHILD_ID, S_CUSTOM);
+  #if BATTERY_MANAGER == 1 && BATTERY_SENSOR == 1
+    // present the battery service
+    _present(BATTERY_CHILD_ID, S_MULTIMETER);
+    // report battery level
+    batteryReport();
+  #endif
+  #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
+    // present the signal service
+    _present(SIGNAL_CHILD_ID, S_SOUND);
+    // report battery level
+    signalReport();
+  #endif
   // present each sensor
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3715,6 +3627,28 @@ void NodeManager::setup() {
 
 // run the main function for all the register sensors
 void NodeManager::loop() {
+  #if BATTERY_MANAGER == 1
+    // update the timer for battery report when not waking up from an interrupt
+    if (_battery_report_timer.isRunning() && _last_interrupt_pin == -1) _battery_report_timer.update();
+    // if it is time to report the battery level
+    if (_battery_report_timer.isOver()) {
+      // time to report the battery level again
+      batteryReport();
+      // restart the timer
+      _battery_report_timer.restart();
+    }
+  #endif
+  #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
+    // update the timer for signal report when not waking up from an interrupt
+    if (_signal_report_timer.isRunning() && _last_interrupt_pin == -1) _signal_report_timer.update();
+    // if it is time to report the signal level
+    if (_signal_report_timer.isOver()) {
+      // time to report the signal level again
+      signalReport();
+      // restart the timer
+      _signal_report_timer.restart();
+    }
+  #endif
   #if POWER_MANAGER == 1
     // turn on the pin powering all the sensors
     if (_auto_power_pins) powerOn();
@@ -3814,6 +3748,16 @@ void NodeManager::process(Request & request) {
   int function = request.getFunction();
   switch(function) {
     case 1: hello(); break;
+    #if BATTERY_MANAGER == 1
+      case 2: batteryReport(); return;
+      case 11: setBatteryMin(request.getValueFloat()); break;
+      case 12: setBatteryMax(request.getValueFloat()); break;
+      case 14: setBatteryReportMinutes(request.getValueInt()); break;
+      case 15: setBatteryInternalVcc(request.getValueInt()); break;
+      case 16: setBatteryPin(request.getValueInt()); break;
+      case 17: setBatteryVoltsPerBit(request.getValueFloat()); break;
+      case 18: setBatteryReportWithInterrupt(request.getValueInt()); break;
+    #endif
     case 3:
       setSleepSeconds(request.getValueInt());
       #if PERSIST == 1
@@ -3859,10 +3803,23 @@ void NodeManager::process(Request & request) {
     case 30: setSleepOrWait(request.getValueInt()); break;
     case 31: setRebootPin(request.getValueInt()); break;
     case 32: setADCOff(); break;
+    #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
+      case 33: setSignalReportMinutes(request.getValueInt()); break;
+      case 43: setSignalReportSeconds(request.getValueInt()); break;
+      case 44: setSignalReportHours(request.getValueInt()); break;
+      case 45: setSignalReportDays(request.getValueInt()); break;
+      case 34: setSignalCommand(request.getValueInt()); break;
+      case 35: signalReport(); break;
+    #endif
     case 36: setReportIntervalSeconds(request.getValueInt()); break;
     case 37: setReportIntervalMinutes(request.getValueInt()); break;
     case 38: setReportIntervalHours(request.getValueInt()); break;
     case 39: setReportIntervalDays(request.getValueInt()); break;
+    #if BATTERY_MANAGER == 1
+      case 40: setBatteryReportSeconds(request.getValueInt()); break;
+      case 41: setBatteryReportHours(request.getValueInt()); break;
+      case 42: setBatteryReportDays(request.getValueInt()); break;
+    #endif
     default: return; 
   }
   _sendUsingConfigChild(_msg.set(function));
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -220,113 +220,65 @@ Child::Child() {
 }
 
 // constructor
-Child::Child(Sensor* __sensor, int _child_id, int _presentation, int _type, char* _description = "") {
+Child::Child(int _child_id, int _presentation, int _type, int _value_type = TYPE_INTEGER, char* _description = "") {
   child_id = _child_id;
   presentation = _presentation;
   type = _type;
+  value_type = _value_type;
   description = _description;
-  _sensor = __sensor;
-  _sensor->registerChild(this);
 }
-// set a value, implemented by the subclasses
-void Child::sendValue() {
+
+// setter/getter
+template<> void Child::setValue(int value) {
+  _value_int = value;
+}
+template<> void Child::setValue(float value) {
+  _value_float = value;
+}
+template<> void Child::setValue(double value) {
+  _value_double = value;
 }
-
-// ChildInt class
-ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+template<> void Child::setValue(char* value) {
+  _value_string = value;
+}
+template<> int Child::getValue() {
+    return _value_int;
 }
-
-// store a new value and update the total
-void ChildInt::setValueInt(int value) {
-  _samples++;
-  _total = _total + value;
-  _value = value;
+template<> float Child::getValue() {
+    return _value_float;
 }
-
-// send the value back to the controller
-void ChildInt::sendValue() {
-  if (_total == -255) return;
-  int avg = (int) (_total / _samples);
-  _last_value = avg;
-  MyMessage* msg = _sensor->_node_manager->getMessage();
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(avg);
-  _sensor->_node_manager->sendMessage();
-  _value = -255;
+template<> double Child::getValue() {
+    return _value_double;
 }
-
-// ChildFloat class
-ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+template<> char* Child::getValue() {
+    return _value_string;
 }
-
-// store a new value and update the total
-void ChildFloat::setValueFloat(float value) {
-  _samples++;
-  _total = _total + value;
-  _value = value;
+template<> void Child::setLastValue(int value) {
+  _last_value_int = value;
 }
-
-// send the value back to the controller
-void ChildFloat::sendValue() {
-  if (_total == -255) return;
-  float avg = _total / _samples;
-  _last_value = avg;
-  MyMessage* msg = _sensor->_node_manager->getMessage();
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(avg,_sensor->getFloatPrecision());
-  _sensor->_node_manager->sendMessage();
-  _value = -255;
+template<> void Child::setLastValue(float value) {
+  _last_value_float = value;
 }
-
-// ChildDouble class
-ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+template<> void Child::setLastValue(double value) {
+  _last_value_double = value;
 }
-
-// store a new value and update the total
-void ChildDouble::setValueDouble(double value) {
-  _samples++;
-  _total = _total + value;
-  _value = value;
+template<> void Child::setLastValue(char* value) {
+  _last_value_string = value;
 }
-
-// send the value back to the controller
-void ChildDouble::sendValue() {
-  if (_total == -255) return;
-  double avg = _total / _samples;
-  _last_value = avg;
-  MyMessage* msg = _sensor->_node_manager->getMessage();
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(avg,_sensor->getDoublePrecision());
-  _sensor->_node_manager->sendMessage();
-  _value = -255;
+template<> int Child::getLastValue() {
+    return _last_value_int;
 }
-
-// ChildString class
-ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+template<> float Child::getLastValue() {
+    return _last_value_float;
 }
-
-// store a new value and update the total
-void ChildString::setValueString(char* value) {
-  _value = value;
+template<> double Child::getLastValue() {
+    return _last_value_double;
 }
-
-// send the value back to the controller
-void ChildString::sendValue() {
-  MyMessage* msg = _sensor->_node_manager->getMessage();
-  _last_value = _value;
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(_value);
-  _sensor->_node_manager->sendMessage();
-  _value = "";
+template<> char* Child::getLastValue() {
+    return _last_value_string;
 }
 
 
-
-
 /*
    Sensor class
 */
@@ -396,16 +348,9 @@ int Sensor::getValueType() {
 void Sensor::setFloatPrecision(int value) {
   _float_precision = value;
 }
-int Sensor::getFloatPrecision() {
-  return _float_precision;
-}
 void Sensor::setDoublePrecision(int value) {
   _double_precision = value;
 }
-int Sensor::getDoublePrecision() {
-  return _double_precision;
-}
-
 #if POWER_MANAGER == 1
     void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
       _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
@@ -456,15 +401,10 @@ void Sensor::setInterrupt(int pin, int mode, int initial) {
   _node_manager->setInterrupt(pin,mode,initial);
 }
 
-// register a child
-void Sensor::registerChild(Child* child) {
-  children.push(child);
-}
-
 // present the sensor to the gateway and controller
 void Sensor::presentation() {
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
   #if DEBUG == 1
     Serial.print(F("PRES I="));
     Serial.print(child->child_id);
@@ -480,8 +420,8 @@ void Sensor::presentation() {
 void Sensor::before() {
   if (_pin == -1) return;
   onBefore();
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -501,14 +441,16 @@ void Sensor::setup() {
 }
 
 // call the sensor-specific implementation of loop
-void Sensor::loop(MyMessage* message) {
+void Sensor::loop(const MyMessage & message) {
+//  if (_pin == -1) return;
   // update the timers if within a loop cycle
-  if (message == nullptr) {
+  if (! _isReceive(message)) {
     if (_report_timer->isRunning()) {
+      // store the elapsed time before updating it
       bool first_run = _report_timer->isFirstRun();
       // update the timer
       _report_timer->update();
-      // if it is not the time yet to report a new measure, just return (unless it is the first time)
+      // if it is not the time yet to report a new measure, just return (unless the first time)
       if (! _report_timer->isOver() && ! first_run) return;
     }
     if (_force_update_timer->isRunning()) _force_update_timer->update();
@@ -518,14 +460,14 @@ void Sensor::loop(const MyMessage & message) {
     if (_auto_power_pins) powerOn();
   #endif
   // iterates over all the children
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
     // for numeric sensor requiring multiple samples, keep track of the total
     double total = 0;
     // collect multiple samples if needed
     for (int i = 0; i < _samples; i++) {
       // call the sensor-specific implementation of the main task which will store the result in the _value variable
-      if (message != nullptr) {
+      if (_isReceive(message)) {
         // we've been called from receive(), pass the message along
         onReceive(message);
       }
@@ -533,18 +475,62 @@ void Sensor::loop(const MyMessage & message) {
         // we'be been called from loop()
         onLoop(child);
       }
+      // for integers, floats and doubles, keep track of the total
+      if (child->value_type == TYPE_INTEGER) total += (float)child->getValue<int>();
+      else if (child->value_type == TYPE_FLOAT) total += child->getValue<float>();
+      else if (child->value_type == TYPE_DOUBLE) total += child->getValue<double>();
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
-    child->sendValue();
+    if (child->value_type == TYPE_INTEGER && total > -255) {
+      // if the value is an integer, calculate the average value of the samples
+      int avg = (int) (total / _samples);
+      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
+      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<int>()))  {
+        child->setLastValue<int>(avg);
+        _sendSensorMessage(_msg->set(avg));
+        child->setValue<int>(-255);
+      }
+    }
+    // process a float value
+    else if (child->value_type == TYPE_FLOAT && total > -255) {
+      // calculate the average value of the samples
+      float avg = total / _samples;
+      // report the value back
+      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<float>()))  {
+        child->setLastValue<float>(avg);
+        _sendSensorMessage(_msg->set(avg, _float_precision));
+        child->setValue<float>(-255);
+      }
+    }
+    // process a double value
+    else if (child->value_type == TYPE_DOUBLE && total > -1) {
+      // calculate the average value of the samples
+      double avg = total / _samples;
+      // report the value back
+      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<double>()))  {
+        child->setLastValue<double>(avg);
+        _sendSensorMessage(_msg->set(avg, _double_precision));
+        child->setValue<double>(-255);
+      }
+    }
+    // process a string value
+    else if (child->value_type == TYPE_STRING) {
+      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
+      if (_isReceive(message) || _isWorthSending(strcmp(child->getValue<char*>(), child->getLastValue<char*>()) != 0))  {
+        child->setLastValue<char*>(child->getValue<char*>());
+        _sendSensorMessage(_msg->set(child->getValue<char*>()));
+        child->setValue<char*>("");
+      }
+    }
   }
   // turn the sensor off
   #if POWER_MANAGER == 1
     if (_auto_power_pins) powerOff();
   #endif
   // restart the report timer if over
-  if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
+  if (! _isReceive(message) && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
 }
 
 // receive and handle an interrupt
@@ -570,7 +556,7 @@ void Sensor::receive(const MyMessage &message) {
   // return if the type is not correct
   if (message.type != _type) return;
   // a request would make the sensor executing its main task passing along the message
-  loop(&message);
+  loop(message);
 }
 
 // process a remote configuration request message
@@ -605,8 +591,8 @@ void Sensor::process(Request & request) {
 
 // return the requested child 
 Child* Sensor::getChild(int child_id) {
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
     if (child->child_id == child_id) return child;
   }
   return nullptr;
@@ -616,7 +602,7 @@ Child* Sensor::getChild(int child_id) {
 void Sensor::onBefore() {}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
-void Sensor::onReceive(MyMessage* message){}
+void Sensor::onReceive(const MyMessage & message){}
 void Sensor::onProcess(Request & request){}
 void Sensor::onInterrupt(){}
 
@@ -687,7 +673,7 @@ void SensorBattery::setBatteryReportWithInterrupt(bool value) {
 
 // what to do during before
 void SensorBattery::onBefore() {
-  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);  
+  children.push(Child(BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE,TYPE_FLOAT));
 }
 
 // what to do during setup
@@ -712,16 +698,16 @@ void SensorBattery::onLoop(Child* child) {
     Serial.print(F(" %="));
     Serial.println(percentage);
   #endif
-  ((ChildFloat*)child)->setValueFloat(volt);
+  child->setValue<float>(volt);
   // report battery level percentage
   sendBatteryLevel(percentage);
 }
 
 // what to do as the main task when receiving a message
-void SensorBattery::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
+void SensorBattery::onReceive(const MyMessage & message) {
+  Child* child = getChild(message.sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ) onLoop(child);
+  if (message.getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -759,7 +745,7 @@ void SensorSignal::setSignalCommand(int value) {
 
 // what to do during before
 void SensorSignal::onBefore() {
-  new ChildInt(this,SIGNAL_CHILD_ID,S_SOUND,V_LEVEL);
+  children.push(Child(SIGNAL_CHILD_ID,S_SOUND,V_LEVEL));
 }
 
 // what to do during setup
@@ -775,14 +761,14 @@ void SensorSignal::onLoop(Child* child) {
     Serial.print(F(" V="));
     Serial.println(value);
   #endif
-  ((ChildInt*)child)->setValueInt(value);
+  child->setValue<int>(value);
 }
 
 // what to do as the main task when receiving a message
-void SensorSignal::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
+void SensorSignal::onReceive(const MyMessage & message) {
+  Child* child = getChild(message.sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ) onLoop(child);
+  if (message.getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -1537,8 +1523,8 @@ SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  new ChildFloat(this,_node_manager->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node_manager->getAvailableChildId(),S_HUM,V_HUM);
+  children.push(Child(_node_manager->getAvailableChildId(),S_TEMP,V_TEMP,TYPE_FLOAT));
+  children.push(Child(_node_manager->getAvailableChildId(),S_HUM,V_HUM,TYPE_FLOAT));
   // initialize the library
   Wire.begin();
 }
@@ -1563,7 +1549,7 @@ void SensorSHT21::onLoop(Child* child) {
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+    if (! isnan(temperature)) child->setValue<float>(temperature);
   }
   // Humidity Sensor
   else if (child->type == V_HUM) {
@@ -1578,15 +1564,15 @@ void SensorSHT21::onLoop(Child* child) {
       Serial.println(humidity);
     #endif
     // store the value
-   if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+   if (! isnan(humidity)) child->setValue<float>(humidity);
   }
 }
 
 // what to do as the main task when receiving a message
-void SensorSHT21::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
+void SensorSHT21::onReceive(const MyMessage & message) {
+  Child* child = getChild(message.sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ) onLoop(child);
+  if (message.getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -3706,14 +3692,14 @@ void NodeManager::loop() {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
       _msg.clear();
       sensor->interrupt();
-      sensor->loop(nullptr);
+      sensor->loop(_msg);
         // reset the last interrupt pin
       _last_interrupt_pin = -1;
     }
     else if (_last_interrupt_pin == -1) {
       // if just at the end of a cycle, call the sensor's loop() 
       _msg.clear();
-      sensor->loop(nullptr);
+      sensor->loop(_msg);
     }
   }
   #if POWER_MANAGER == 1
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -163,8 +163,7 @@ float Timer::getElapsed() {
     Request
 */
 
-Request::Request(int child_id, const char* string) {
-  _child_id = child_id;
+Request::Request(const char* string) {
   char* ptr;
   // copy to working area
   strcpy((char*)&_value, string);
@@ -186,11 +185,6 @@ Request::Request(const char* string) {
   #endif
 }
 
-// return the child id
-int Request::getChildId() {
-  return _child_id;
-}
-
 // return the parsed function
 int Request::getFunction() {
   return _function;
@@ -254,7 +248,11 @@ void ChildInt::sendValue() {
   if (_total == -255) return;
   int avg = (int) (_total / _samples);
   _last_value = avg;
-  _sensor->_node_manager->sendMessage(child_id,type,avg);
+  MyMessage* msg = _sensor->_node_manager->getMessage();
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(avg);
+  _sensor->_node_manager->sendMessage();
   _value = -255;
 }
 
@@ -274,7 +272,11 @@ void ChildFloat::sendValue() {
   if (_total == -255) return;
   float avg = _total / _samples;
   _last_value = avg;
-  _sensor->_node_manager->sendMessage(child_id,type,avg);
+  MyMessage* msg = _sensor->_node_manager->getMessage();
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(avg,_sensor->getFloatPrecision());
+  _sensor->_node_manager->sendMessage();
   _value = -255;
 }
 
@@ -294,7 +296,11 @@ void ChildDouble::sendValue() {
   if (_total == -255) return;
   double avg = _total / _samples;
   _last_value = avg;
-  _sensor->_node_manager->sendMessage(child_id,type,avg);
+  MyMessage* msg = _sensor->_node_manager->getMessage();
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(avg,_sensor->getDoublePrecision());
+  _sensor->_node_manager->sendMessage();
   _value = -255;
 }
 
@@ -309,8 +315,12 @@ void ChildString::setValueString(char* value) {
 
 // send the value back to the controller
 void ChildString::sendValue() {
+  MyMessage* msg = _sensor->_node_manager->getMessage();
   _last_value = _value;
-  _sensor->_node_manager->sendMessage(child_id,type,_value);
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(_value);
+  _sensor->_node_manager->sendMessage();
   _value = "";
 }
 
@@ -341,6 +351,27 @@ void Sensor::setPin(int value) {
 int Sensor::getPin() {
   return _pin;
 }
+void Sensor::setChildId(int value) {
+  _child_id = value;
+}
+int Sensor::getChildId() {
+  return _child_id;
+}
+void Sensor::setPresentation(int value) {
+  _presentation = value;
+}
+int Sensor::getPresentation() {
+  return _presentation;
+}
+void Sensor::setType(int value) {
+  _type = value;
+}
+int Sensor::getType() {
+  return _type;
+}
+void Sensor::setDescription(char* value) {
+  _description = value;
+}
 void Sensor::setSamples(int value) {
   _samples = value;
 }
@@ -356,6 +387,25 @@ void Sensor::setForceUpdateMinutes(int value) {
 void Sensor::setForceUpdateHours(int value) {
   _force_update_timer->start(value,HOURS);
 }
+void Sensor::setValueType(int value) {
+  _value_type = value;
+}
+int Sensor::getValueType() {
+  return _value_type;
+}
+void Sensor::setFloatPrecision(int value) {
+  _float_precision = value;
+}
+int Sensor::getFloatPrecision() {
+  return _float_precision;
+}
+void Sensor::setDoublePrecision(int value) {
+  _double_precision = value;
+}
+int Sensor::getDoublePrecision() {
+  return _double_precision;
+}
+
 #if POWER_MANAGER == 1
     void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
       _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
@@ -470,14 +520,19 @@ void Sensor::loop(MyMessage* message) {
   // iterates over all the children
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
-    // if a specific child is requested, skip all the others
-    if (message != nullptr && message->sensor != child->child_id) continue;
+    // for numeric sensor requiring multiple samples, keep track of the total
+    double total = 0;
     // collect multiple samples if needed
     for (int i = 0; i < _samples; i++) {
-      // we've been called from receive(), pass the message along
-      if (message != nullptr) onReceive(message);
-      // we'be been called from loop()
-      else onLoop(child);
+      // call the sensor-specific implementation of the main task which will store the result in the _value variable
+      if (message != nullptr) {
+        // we've been called from receive(), pass the message along
+        onReceive(message);
+      }
+      else {
+        // we'be been called from loop()
+        onLoop(child);
+      }
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
@@ -500,19 +555,22 @@ void Sensor::interrupt() {
 
 // receive a message from the radio network
 void Sensor::receive(const MyMessage &message) {
+  // return if not for this sensor
+  if (message.sensor != _child_id) return;
   // check if it is a request for the API
   if (message.getCommand() == C_REQ && message.type == V_CUSTOM) {
     #if REMOTE_CONFIGURATION == 1
       // parse the request
-      Request request = Request(message.sensor,message.getString());
+      Request request = Request(message.getString());
       // if it is for a sensor-generic function, call process(), otherwise the sensor-specific onProcess();
       if (request.getFunction() < 100) process(request);
       else onProcess(request);
     #endif
-  } else {
-    // a request would make the sensor executing its main task passing along the message
-    loop(&message);
   }
+  // return if the type is not correct
+  if (message.type != _type) return;
+  // a request would make the sensor executing its main task passing along the message
+  loop(&message);
 }
 
 // process a remote configuration request message
@@ -520,11 +578,15 @@ void Sensor::process(Request & request) {
   int function = request.getFunction();
   switch(function) {
     case 1: setPin(request.getValueInt()); break;
+    case 2: setChildId(request.getValueInt()); break;
+    case 3: setType(request.getValueInt()); break;
+    case 4: setDescription(request.getValueString()); break;
     case 5: setSamples(request.getValueInt()); break;
     case 6: setSamplesInterval(request.getValueInt()); break;
     case 7: setTrackLastValue(request.getValueInt()); break;
     case 9: setForceUpdateMinutes(request.getValueInt()); break;
     case 10: setValueType(request.getValueInt()); break;
+    case 11: setFloatPrecision(request.getValueInt()); break;
     #if POWER_MANAGER == 1
       case 12: setAutoPowerPins(request.getValueInt()); break;
       case 13: powerOn(); break;
@@ -535,9 +597,10 @@ void Sensor::process(Request & request) {
     case 19: setReportIntervalHours(request.getValueInt()); break;
     case 20: setReportIntervalDays(request.getValueInt()); break;
     case 18: setForceUpdateHours(request.getValueInt()); break;
+    case 21: setDoublePrecision(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // return the requested child 
@@ -557,6 +620,28 @@ void Sensor::onReceive(MyMessage* message){}
 void Sensor::onProcess(Request & request){}
 void Sensor::onInterrupt(){}
 
+// send a message to the network
+void Sensor::_sendSensorMessage(MyMessage & message) {
+	// setup the message
+	message.setSensor(_child_id);
+	message.setType(_type);
+	_node_manager->sendMessage();
+  }
+
+// send a message to the network
+void Sensor::_sendServiceMessage(MyMessage & message) {
+	// setup the message
+	message.setSensor(_child_id);
+	message.setType(V_CUSTOM);
+	_node_manager->sendMessage();
+}
+
+// return true if the message is coming from the radio network
+bool Sensor::_isReceive(const MyMessage & message) {
+  if (message.sender == 0 && message.sensor == 0 && message.getCommand() == 0 && message.type == 0) return false;
+  return true;
+}
+
 // determine if a value is worth sending back to the controller
 bool Sensor::_isWorthSending(bool comparison) {
   // track last value is disabled
@@ -602,7 +687,7 @@ void SensorBattery::setBatteryReportWithInterrupt(bool value) {
 
 // what to do during before
 void SensorBattery::onBefore() {
-  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);
+  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);  
 }
 
 // what to do during setup
@@ -651,7 +736,7 @@ void SensorBattery::onProcess(Request & request) {
     case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -707,7 +792,7 @@ void SensorSignal::onProcess(Request & request) {
     case 101: setSignalCommand(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -786,7 +871,7 @@ void SensorAnalogInput::onProcess(Request & request) {
     case 105: setRangeMax(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -915,7 +1000,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -1041,7 +1126,7 @@ void SensorACS712::onProcess(Request & request) {
     case 102: setOffset(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -1207,7 +1292,7 @@ void SensorDigitalOutput::onProcess(Request & request) {
     case 107: setWaitAfterSet(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -1333,7 +1418,7 @@ void SensorLatchingRelay::onProcess(Request & request) {
     case 203: setPinOn(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // switch to the requested status
@@ -1577,7 +1662,7 @@ void SensorSwitch::onProcess(Request & request) {
     case 104: setInitial(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -1683,7 +1768,7 @@ void SensorDs18b20::onProcess(Request & request) {
     case 102: setSleepDuringConversion(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -1760,7 +1845,7 @@ void SensorBH1750::onProcess(Request & request) {
     case 101: setMode(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 
@@ -1886,7 +1971,7 @@ void SensorBosch::onProcess(Request & request) {
     case 101: setForecastSamplesCount(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -2221,7 +2306,7 @@ void SensorHCSR04::onProcess(Request & request) {
     case 103: setMaxDistance(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -2306,7 +2391,7 @@ void SensorSonoff::onProcess(Request & request) {
     case 103: setLedPin(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -2505,7 +2590,7 @@ void SensorMQ::onProcess(Request & request) {
     case 8: setReadSampleInterval(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -2660,7 +2745,7 @@ void SensorMHZ19::onProcess(Request & request) {
   switch(function) {
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -2877,7 +2962,7 @@ void SensorTSL2561::onProcess(Request & request) {
     case 104: setAddress(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -2939,7 +3024,7 @@ void SensorPT100::onProcess(Request & request) {
     case 101: setVoltageRef(request.getValueFloat()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -3008,7 +3093,7 @@ void SensorDimmer::onProcess(Request & request) {
     case 103: setStepDuration(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -3110,7 +3195,7 @@ void SensorPulseMeter::onProcess(Request & request) {
     case 102: setPulseFactor(request.getValueFloat()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendServiceMessage(_msg->set(function));
 }
 
 // what to do when receiving an interrupt
@@ -3168,7 +3253,7 @@ SensorWaterMeter::SensorWaterMeter(NodeManager* node_manager, int child_id, int
 // initialize the node manager
 NodeManager::NodeManager() {
   // setup the message container
-  _message = MyMessage();
+  _msg = MyMessage();
 }
 
 int NodeManager::_last_interrupt_pin = -1;
@@ -3184,7 +3269,7 @@ int NodeManager::getRetries() {
   return _retries;
 }
 MyMessage* NodeManager::getMessage() {
-	return &_message;
+	return &_msg;
 }
 
 
@@ -3619,7 +3704,7 @@ void NodeManager::loop() {
     Sensor* sensor = *itr;
     if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
-      _message.clear();
+      _msg.clear();
       sensor->interrupt();
       sensor->loop(nullptr);
         // reset the last interrupt pin
@@ -3627,7 +3712,7 @@ void NodeManager::loop() {
     }
     else if (_last_interrupt_pin == -1) {
       // if just at the end of a cycle, call the sensor's loop() 
-      _message.clear();
+      _msg.clear();
       sensor->loop(nullptr);
     }
   }
@@ -3657,7 +3742,7 @@ void NodeManager::receive(const MyMessage &message) {
   if (message.sensor == CONFIGURATION_CHILD_ID && message.getCommand() == C_REQ && message.type == V_CUSTOM) {
     #if REMOTE_CONFIGURATION == 1
       // parse the request
-      Request request = Request(message.sensor,message.getString());
+      Request request = Request(message.getString());
       // process the request
       process(request);
     #endif
@@ -3737,7 +3822,7 @@ void NodeManager::process(Request & request) {
       case 6: reboot(); return;
     #endif
     case 7: clearEeprom(); break;
-    case 8: sendMessage(request.getChildId(),V_CUSTOM,VERSION); return;
+    case 8: version(); return;
     case 9: wakeup(); break;
     case 10: setRetries(request.getValueInt()); break;
     case 19: setSleepInterruptPin(request.getValueInt()); break;
@@ -3760,7 +3845,7 @@ void NodeManager::process(Request & request) {
     case 39: setReportIntervalDays(request.getValueInt()); break;
     default: return; 
   }
-  sendMessage(request.getChildId(),V_CUSTOM,function);
+  _sendUsingConfigChild(_msg.set(function));
 }
 
 
@@ -3787,6 +3872,11 @@ void NodeManager::reboot() {
   }
 }
 
+// send NodeManager's the version back to the controller
+void NodeManager::version() {
+	_sendUsingConfigChild(_msg.set(VERSION));
+}
+
 // clear the EEPROM
 void NodeManager::clearEeprom() {
   #if DEBUG == 1
@@ -3954,54 +4044,54 @@ void NodeManager::_onInterrupt_2() {
   }
 }
 
-// send a message by providing the source child, type of the message and value
-void NodeManager::sendMessage(int child_id, int type, int value) {
-  _message.clear();
-  _message.set(value);
-  _sendMessage(child_id,type);
+// send a message to the network using CONFIGURATION_CHILD_ID, V_CUSTOM
+void NodeManager::_sendUsingConfigChild(MyMessage & message) {
+	// setup the message
+	message.setSensor(CONFIGURATION_CHILD_ID);
+	message.setType(V_CUSTOM);
+	sendMessage();
 }
-void NodeManager::sendMessage(int child_id, int type, float value) {
-  _message.clear();
-  _message.set(value,2);
-  _sendMessage(child_id,type);
+
+// send a message to the network using BATTERY_CHILD_ID, V_VOLTAGE
+void NodeManager::_sendUsingBatteryChild(MyMessage & message) {
+	// setup the message
+	message.setSensor(BATTERY_CHILD_ID);
+	message.setType(V_VOLTAGE);
+	sendMessage();
 }
-void NodeManager::sendMessage(int child_id, int type, double value) {
-  _message.clear();
-  _message.set(value,4);
-  _sendMessage(child_id,type);
-}
-void NodeManager::sendMessage(int child_id, int type, const char* value) {
-  _message.clear();
-  _message.set(value);
-  _sendMessage(child_id,type);
+
+// send a message to the network using SIGNAL_CHILD_ID, V_LEVEL
+void NodeManager::_sendUsingSignalChild(MyMessage & message) {
+	// setup the message
+	message.setSensor(SIGNAL_CHILD_ID);
+	message.setType(V_LEVEL);
+	sendMessage();
 }
+
 
 // send a message to the network
-void NodeManager::_sendMessage(int child_id, int type) {
-  // prepare the message
-  _message.setSensor(child_id);
-  _message.setType(type);
+void NodeManager::sendMessage() {
   // send the message, multiple times if requested
   for (int i = 0; i < _retries; i++) {
     // if configured, sleep beetween each send
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
     #if DEBUG == 1
       Serial.print(F("SEND D="));
-		  Serial.print(_message.destination);
+		Serial.print(_msg.destination);
       Serial.print(F(" I="));
-		  Serial.print(_message.sensor);
+		Serial.print(_msg.sensor);
       Serial.print(F(" C="));
-		  Serial.print(_message.getCommand());
+		Serial.print(_msg.getCommand());
       Serial.print(F(" T="));
-		  Serial.print(_message.type);
+		Serial.print(_msg.type);
       Serial.print(F(" S="));
-		  Serial.print(_message.getString());
+		Serial.print(_msg.getString());
       Serial.print(F(" I="));
-		  Serial.print(_message.getInt());
+		Serial.print(_msg.getInt());
       Serial.print(F(" F="));
-		  Serial.println(_message.getFloat());
+		Serial.println(_msg.getFloat());
     #endif
-		send(_message, _ack);
+		send(_msg, _ack);
   }
 }
 
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -415,13 +418,13 @@ void Sensor::registerChild(Child* child) {
 void Sensor::presentation() {
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
-    #if DEBUG == 1
-      Serial.print(F("PRES I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(child->presentation);
-    #endif
-    present(child->child_id, child->presentation,child->description,_node_manager->getAck());
+  #if DEBUG == 1
+    Serial.print(F("PRES I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" T="));
+    Serial.println(child->presentation);
+  #endif
+  present(child->child_id, child->presentation,child->description,_node_manager->getAck());
   }
 
 }
@@ -516,7 +519,7 @@ void Sensor::receive(const MyMessage &message) {
 }
 
 // process a remote configuration request message
-void Sensor::process(const Request & request) {
+void Sensor::process(Request & request) {
   int function = request.getFunction();
   switch(function) {
     case 1: setPin(request.getValueInt()); break;
@@ -524,6 +527,7 @@ void Sensor::process(Request & request) {
     case 6: setSamplesInterval(request.getValueInt()); break;
     case 7: setTrackLastValue(request.getValueInt()); break;
     case 9: setForceUpdateMinutes(request.getValueInt()); break;
+    case 10: setValueType(request.getValueInt()); break;
     #if POWER_MANAGER == 1
       case 12: setAutoPowerPins(request.getValueInt()); break;
       case 13: powerOn(); break;
@@ -640,7 +644,6 @@ void SensorBattery::onReceive(MyMessage* message) {
 
 // what to do when receiving a remote message
 void SensorBattery::onProcess(Request & request) {
-#if REMOTE_CONFIGURATION == 1
   int function = request.getFunction();
   switch(function) {
     case 102: setMinVoltage(request.getValueFloat()); break;
@@ -652,7 +655,6 @@ void SensorBattery::onProcess(Request & request) {
     default: return;
   }
   _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
-#endif
 }
 
 // what to do when receiving an interrupt
@@ -703,14 +705,12 @@ void SensorSignal::onReceive(MyMessage* message) {
 
 // what to do when receiving a remote message
 void SensorSignal::onProcess(Request & request) {
-#if REMOTE_CONFIGURATION == 1
   int function = request.getFunction();
   switch(function) {
     case 101: setSignalCommand(request.getValueInt()); break;
     default: return;
   }
   _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
-#endif
 }
 
 // what to do when receiving an interrupt
@@ -3197,8 +3197,6 @@ void NodeManager::setSleepSeconds(int value) {
   else _status = SLEEP;
   // store the time
   _sleep_time = value;
-  // save sleep settings to eeprom
-  if (_save_sleep_settings) _saveSleepSettings();
 }
 void NodeManager::setSleepMinutes(int value) {
   setSleepSeconds(value*60);
@@ -3263,9 +3261,6 @@ void NodeManager::setIsMetric(bool value) {
 bool NodeManager::getIsMetric() {
   return _is_metric;
 }
-void NodeManager::setSaveSleepSettings(bool value) {
-  _save_sleep_settings = value;
-}
 
 // Convert a temperature from celsius to fahrenheit depending on how isMetric is set
 float NodeManager::celsiusToFahrenheit(float temperature) {
@@ -3558,8 +3553,10 @@ void NodeManager::before() {
     Serial.print(F(" B="));
     Serial.println(MY_CAP_RXBUF);
   #endif
-  // restore the sleep settings saved in the eeprom
-  if (_save_sleep_settings) _loadSleepSettings();
+  #if PERSIST == 1
+    // restore the configuration saved in the eeprom
+    _loadConfig();
+  #endif
   // setup individual sensors
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3717,15 +3714,27 @@ void NodeManager::process(Request & request) {
     case 1: hello(); break;
     case 3:
       setSleepSeconds(request.getValueInt());
+      #if PERSIST == 1
+        _saveConfig();
+      #endif
       break;
     case 4:
       setSleepMinutes(request.getValueInt());
+      #if PERSIST == 1
+        _saveConfig();
+      #endif
       break;
     case 5:
       setSleepHours(request.getValueInt());
+      #if PERSIST == 1
+        _saveConfig();
+      #endif
       break;
     case 29:
       setSleepDays(request.getValueInt());
+      #if PERSIST == 1
+        _saveConfig();
+      #endif
       break;
     #ifndef MY_GATEWAY_ESP8266
       case 6: reboot(); return;
@@ -4083,7 +4092,7 @@ int NodeManager::_getInterruptInitialValue(int mode) {
 }
 
 // load the configuration stored in the eeprom
-void NodeManager::_loadSleepSettings() {
+void NodeManager::_loadConfig() {
   if (loadState(EEPROM_SLEEP_SAVED) == 1) {
     // load sleep settings
     int bit_1 = loadState(EEPROM_SLEEP_1);
@@ -4098,7 +4107,7 @@ void NodeManager::_loadConfig() {
 }
 
 // save the configuration in the eeprom
-void NodeManager::_saveSleepSettings() {
+void NodeManager::_saveConfig() {
   if (_sleep_time == 0) return;
   // encode the sleep time in 3 bits
   int bit_1, bit_2, bit_3 = 0;
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -318,11 +318,14 @@ void ChildString::sendValue() {
    Sensor class
 */
 // constructor
-Sensor::Sensor() {  
+Sensor::Sensor() {
+  
 }
+
 Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _node_manager = &nodeManager;
   _pin = pin;
+  _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
   _node_manager->registerSensor(this);
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -62,7 +62,7 @@ void PowerManager::powerOff() {
 */
 
 Timer::Timer(NodeManager* node_manager) {
-  _node = node_manager;
+  _node_manager = node_manager;
 }
 
 // start the timer
@@ -92,7 +92,7 @@ void Timer::restart() {
   stop();
   reset();
   // if using millis(), keep track of the current timestamp for calculating the difference
-  if (! _node->isSleepingNode()) _last_millis = millis();
+  if (! _node_manager->isSleepingNode()) _last_millis = millis();
   start();
 }
 
@@ -117,9 +117,9 @@ void Timer::unset() {
 // update the timer at every cycle
 void Timer::update() {
   if (! isRunning()) return;
-  if (_node->isSleepingNode()) {
+  if (_node_manager->isSleepingNode()) {
     // millis() is not reliable while sleeping so calculate how long a sleep cycle would last in seconds and update the elapsed time
-    _elapsed += _node->getSleepSeconds();
+    _elapsed += _node_manager->getSleepSeconds();
   } else {
     // use millis() to calculate the elapsed time in seconds
     _elapsed = (long)((millis() - _last_millis)/1000);
@@ -254,7 +254,7 @@ void ChildInt::sendValue() {
   if (_total == -255) return;
   int avg = (int) (_total / _samples);
   _last_value = avg;
-  _sensor->_node->sendMessage(child_id,type,avg);
+  _sensor->_node_manager->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -274,7 +274,7 @@ void ChildFloat::sendValue() {
   if (_total == -255) return;
   float avg = _total / _samples;
   _last_value = avg;
-  _sensor->_node->sendMessage(child_id,type,avg);
+  _sensor->_node_manager->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -294,7 +294,7 @@ void ChildDouble::sendValue() {
   if (_total == -255) return;
   double avg = _total / _samples;
   _last_value = avg;
-  _sensor->_node->sendMessage(child_id,type,avg);
+  _sensor->_node_manager->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -310,7 +310,7 @@ void ChildString::setValueString(char* value) {
 // send the value back to the controller
 void ChildString::sendValue() {
   _last_value = _value;
-  _sensor->_node->sendMessage(child_id,type,_value);
+  _sensor->_node_manager->sendMessage(child_id,type,_value);
   _value = "";
 }
 
@@ -320,12 +320,12 @@ void ChildString::sendValue() {
 // constructor
 Sensor::Sensor() {  
 }
-Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
-  _node = &nodeManager;
+Sensor::Sensor(NodeManager& nodeManager, int pin) {
+  _node_manager = &nodeManager;
   _pin = pin;
-  _report_timer = new Timer(_node);
-  _force_update_timer = new Timer(_node);
-  _node->registerSensor(this);
+  _report_timer = new Timer(_node_manager);
+  _force_update_timer = new Timer(_node_manager);
+  _node_manager->registerSensor(this);
 }
 
 // setter/getter
@@ -397,7 +397,7 @@ bool Sensor::isReportIntervalConfigured() {
 // listen for interrupts on the given pin so interrupt() will be called when occurring
 void Sensor::setInterrupt(int pin, int mode, int initial) {
   _interrupt_pin = pin;
-  _node->setInterrupt(pin,mode,initial);
+  _node_manager->setInterrupt(pin,mode,initial);
 }
 
 // register a child
@@ -415,13 +415,14 @@ void Sensor::presentation() {
       Serial.print(F(" T="));
       Serial.println(child->presentation);
     #endif
-    present(child->child_id, child->presentation,child->description,_node->getAck());
+    present(child->child_id, child->presentation,child->description,_node_manager->getAck());
   }
 
 }
 
 // call the sensor-specific implementation of before
 void Sensor::before() {
+  if (_pin == -1) return;
   onBefore();
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
@@ -439,6 +440,7 @@ void Sensor::before() {
 
 // call the sensor-specific implementation of setup
 void Sensor::setup() {
+  if (_pin == -1) return;
   onSetup();
 }
 
@@ -471,7 +473,7 @@ void Sensor::loop(MyMessage* message) {
       // we'be been called from loop()
       else onLoop(child);
       // wait between samples
-      if (_samples_interval > 0) _node->sleepOrWait(_samples_interval);
+      if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
     child->sendValue();
@@ -528,7 +530,7 @@ void Sensor::process(const Request & request) {
     case 18: setForceUpdateHours(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // return the requested child 
@@ -605,7 +607,7 @@ void SensorBattery::onSetup() {
 void SensorBattery::onLoop(Child* child) {
   // measure the board vcc
   float volt = 0;
-  if (_battery_internal_vcc || _battery_pin == -1) volt = _node->getVcc();
+  if (_battery_internal_vcc || _battery_pin == -1) volt = _node_manager->getVcc();
   else volt = analogRead(_battery_pin) * _battery_volts_per_bit;
   // calculate the percentage
   int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
@@ -643,7 +645,7 @@ void SensorBattery::onProcess(Request & request) {
     case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 #endif
 }
 
@@ -701,7 +703,7 @@ void SensorSignal::onProcess(Request & request) {
     case 101: setSignalCommand(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 #endif
 }
 
@@ -781,7 +783,7 @@ void SensorAnalogInput::onProcess(Request & request) {
     case 105: setRangeMax(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -881,7 +883,7 @@ void SensorThermistor::onLoop(Child* child) {
   temperature += 1.0 / (_nominal_temperature + 273.15); // + (1/To)
   temperature = 1.0 / temperature;                 // Invert
   temperature -= 273.15;                         // convert to C
-  temperature = _node->celsiusToFahrenheit(temperature);
+  temperature = _node_manager->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("THER I="));
     Serial.print(_child_id);
@@ -910,7 +912,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -943,7 +945,7 @@ void SensorML8511::onSetup() {
 void SensorML8511::onLoop(Child* child) {
   // read the voltage 
   int uvLevel = analogRead(_pin);
-  int refLevel = _node->getVcc()*1024/3.3;
+  int refLevel = _node_manager->getVcc()*1024/3.3;
   //Use the 3.3V power pin as a reference to get a very accurate output value from sensor
   float outputVoltage = 3.3 / refLevel * uvLevel;
   //Convert the voltage to a UV intensity level
@@ -1036,7 +1038,7 @@ void SensorACS712::onProcess(Request & request) {
     case 102: setOffset(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1202,7 +1204,7 @@ void SensorDigitalOutput::onProcess(Request & request) {
     case 107: setWaitAfterSet(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1230,7 +1232,7 @@ void SensorDigitalOutput::setStatus(int value) {
   }
   _setStatus(value);
   // wait if needed for relay drawing a lot of current
-  if (_wait_after_set > 0) _node->sleepOrWait(_wait_after_set);
+  if (_wait_after_set > 0) _node_manager->sleepOrWait(_wait_after_set);
   // store the new status so it will be sent to the controller
   _status = value;
   _value_int = value;
@@ -1328,7 +1330,7 @@ void SensorLatchingRelay::onProcess(Request & request) {
     case 203: setPinOn(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // switch to the requested status
@@ -1338,7 +1340,7 @@ void SensorLatchingRelay::_setStatus(int value) {
   // set the value
   digitalWrite(pin, _on_value);
   // wait for the given time before restoring the value to the original value after the pulse
-  _node->sleepOrWait(_pulse_width);
+  _node_manager->sleepOrWait(_pulse_width);
   digitalWrite(pin, ! _on_value);
   #if DEBUG == 1
     Serial.print(F("LAT I="));
@@ -1391,13 +1393,13 @@ void SensorDHT::onSetup() {
 
 // what to do during loop
 void SensorDHT::onLoop(Child* child) {
-  _node->sleepOrWait(_dht->getMinimumSamplingPeriod());
+  _node_manager->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
   if (_sensor_type == SensorDHT::TEMPERATURE) {
     // read the temperature
     float temperature = _dht->getTemperature();
-    if (! _node->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
+    if (! _node_manager->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("DHT I="));
       Serial.print(_child_id);
@@ -1441,14 +1443,14 @@ void SensorDHT::onInterrupt() {
 */
 #if MODULE_SHT21 == 1
 // contructor
-SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
+SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
   _name = F("SHT");
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+  new ChildFloat(this,_node_manager->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node_manager->getAvailableChildId(),S_HUM,V_HUM);
   // initialize the library
   Wire.begin();
 }
@@ -1464,7 +1466,7 @@ void SensorSHT21::onLoop(Child* child) {
     // read the temperature
     float temperature = SHT2x.GetTemperature();
     // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
+    temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -1572,13 +1574,13 @@ void SensorSwitch::onProcess(Request & request) {
     case 104: setInitial(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
 void SensorSwitch::onInterrupt() {
   // wait to ensure the the input is not floating
-  if (_debounce > 0) _node->sleepOrWait(_debounce);
+  if (_debounce > 0) _node_manager->sleepOrWait(_debounce);
   // read the value of the pin
   int value = digitalRead(_pin);
   // process the value
@@ -1593,7 +1595,7 @@ void SensorSwitch::onInterrupt() {
     #endif
     _value_int = value;
     // allow the signal to be restored to its normal value
-    if (_trigger_time > 0) _node->sleepOrWait(_trigger_time);
+    if (_trigger_time > 0) _node_manager->sleepOrWait(_trigger_time);
   } else {
     // invalid
     _value_int = -1;
@@ -1654,7 +1656,7 @@ void SensorDs18b20::onLoop(Child* child) {
   // read the temperature
   float temperature = _sensors->getTempCByIndex(_index);
   // convert it
-  temperature = _node->celsiusToFahrenheit(temperature);
+  temperature = _node_manager->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("DS18B20 I="));
     Serial.print(_child_id);
@@ -1678,7 +1680,7 @@ void SensorDs18b20::onProcess(Request & request) {
     case 102: setSleepDuringConversion(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1755,7 +1757,7 @@ void SensorBH1750::onProcess(Request & request) {
     case 101: setMode(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 
@@ -1792,7 +1794,7 @@ void SensorMLX90614::onSetup() {
 void SensorMLX90614::onLoop(Child* child) {
   float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
   // convert it
-  temperature = _node->celsiusToFahrenheit(temperature);
+  temperature = _node_manager->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("MLX I="));
     Serial.print(_child_id);
@@ -1881,7 +1883,7 @@ void SensorBosch::onProcess(Request & request) {
     case 101: setForecastSamplesCount(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2011,7 +2013,7 @@ void SensorBME280::onLoop(Child* child) {
     // read the temperature
     float temperature = _bme->readTemperature();
     // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
+    temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("BME I="));
       Serial.print(_child_id);
@@ -2075,7 +2077,7 @@ void SensorBMP085::onLoop(Child* child) {
     // read the temperature
     float temperature = _bmp->readTemperature();
     // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
+    temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("BMP I="));
       Serial.print(_child_id);
@@ -2122,7 +2124,7 @@ void SensorBMP280::onLoop(Child* child) {
     // read the temperature
     float temperature = _bmp->readTemperature();
     // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
+    temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("BMP I="));
       Serial.print(_child_id);
@@ -2192,7 +2194,7 @@ void SensorHCSR04::onSetup() {
 
 // what to do during loop
 void SensorHCSR04::onLoop(Child* child) {
-  int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
+  int distance = _node_manager->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
   #if DEBUG == 1
     Serial.print(F("HC I="));
     Serial.print(_child_id);
@@ -2216,7 +2218,7 @@ void SensorHCSR04::onProcess(Request & request) {
     case 103: setMaxDistance(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2301,7 +2303,7 @@ void SensorSonoff::onProcess(Request & request) {
     case 103: setLedPin(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2362,7 +2364,7 @@ void SensorMCP9808::onSetup() {
 void SensorMCP9808::onLoop(Child* child) {
   float temperature = _mcp->readTempC();
   // convert it
-  temperature = _node->celsiusToFahrenheit(temperature);
+  temperature = _node_manager->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("MCP I="));
     Serial.print(_child_id);
@@ -2453,6 +2455,7 @@ void SensorMQ::onSetup() {
 
 // what to do during loop
 void SensorMQ::onLoop(Child* child) {
+  if (_pin == -1) return;
   // calculate rs/ro
   float mq = _MQRead()/_ro;
   // calculate the ppm
@@ -2499,7 +2502,7 @@ void SensorMQ::onProcess(Request & request) {
     case 8: setReadSampleInterval(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2654,7 +2657,7 @@ void SensorMHZ19::onProcess(Request & request) {
   switch(function) {
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2871,7 +2874,7 @@ void SensorTSL2561::onProcess(Request & request) {
     case 104: setAddress(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2933,7 +2936,7 @@ void SensorPT100::onProcess(Request & request) {
     case 101: setVoltageRef(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3002,7 +3005,7 @@ void SensorDimmer::onProcess(Request & request) {
     case 103: setStepDuration(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3076,7 +3079,7 @@ void SensorPulseMeter::onSetup() {
 // what to do during loop
 void SensorPulseMeter::onLoop(Child* child) {
   // do not report anything if called by an interrupt
-  if (_node->getLastInterruptPin() == _interrupt_pin) return;
+  if (_node_manager->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
   _reportTotal();
   #if DEBUG == 1
@@ -3104,7 +3107,7 @@ void SensorPulseMeter::onProcess(Request & request) {
     case 102: setPulseFactor(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3908,7 +3911,7 @@ int NodeManager::getAvailableChildId() {
     Child* child = getChild(i);
     if (child == nullptr) return i;
   }
-  return 254;
+  return 255;
 }
 
 // handle an interrupt
@@ -4062,6 +4065,13 @@ void NodeManager::_present(int child_id, int type) {
   present(child_id,type,"",_ack);
 }
 
+// guess the initial value of a digital output based on the configured interrupt mode
+int NodeManager::_getInterruptInitialValue(int mode) {
+  if (mode == RISING) return LOW; 
+  if (mode == FALLING) return HIGH; 
+  return -1;
+}
+
 // load the configuration stored in the eeprom
 void NodeManager::_loadSleepSettings() {
   if (loadState(EEPROM_SLEEP_SAVED) == 1) {
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -256,8 +256,6 @@ void ChildInt::sendValue() {
   _last_value = avg;
   _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
-  _total = -255;
-  _samples = 0;
 }
 
 // ChildFloat class
@@ -278,8 +276,6 @@ void ChildFloat::sendValue() {
   _last_value = avg;
   _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
-  _total = -255;
-  _samples = 0;
 }
 
 // ChildDouble class
@@ -300,8 +296,6 @@ void ChildDouble::sendValue() {
   _last_value = avg;
   _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
-  _total = -255;
-  _samples = 0;
 }
 
 // ChildString class
@@ -453,7 +447,6 @@ void Sensor::loop(MyMessage* message) {
   // update the timers if within a loop cycle
   if (message == nullptr) {
     if (_report_timer->isRunning()) {
-      // keep track if it is the first time
       bool first_run = _report_timer->isFirstRun();
       // update the timer
       _report_timer->update();
@@ -487,7 +480,7 @@ void Sensor::loop(MyMessage* message) {
   #if POWER_MANAGER == 1
     if (_auto_power_pins) powerOff();
   #endif
-  // if called from loop(), restart the report timer if over
+  // restart the report timer if over
   if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
 }
 
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -233,94 +233,77 @@ Child::Child(Sensor* __sensor, int _child_id, int _presentation, int _type, char
   description = _description;
   _sensor = __sensor;
   _sensor->registerChild(this);
-  force_update_timer = new Timer(_sensor->_node);
 }
 // set a value, implemented by the subclasses
 void Child::sendValue() {
 }
 
-// check if it is an updated value, implemented by the subclasses
-bool Child::isNewValue() {
-}
-
 // ChildInt class
 ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
 
 // store a new value and update the total
 void ChildInt::setValueInt(int value) {
+  _samples++;
   _total = _total + value;
-  _samples++;
-  _value = (int) (_total / _samples);
+  _value = value;
 }
 
 // send the value back to the controller
 void ChildInt::sendValue() {
-  if (_value == -255) return;
-  _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
+  if (_total == -255) return;
+  int avg = (int) (_total / _samples);
+  _last_value = avg;
+  _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
   _total = -255;
   _samples = 0;
 }
 
-// check if it is an updated value
-bool ChildInt::isNewValue() {
-  return _last_value != _value;
-}
-
 // ChildFloat class
 ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
 
 // store a new value and update the total
 void ChildFloat::setValueFloat(float value) {
+  _samples++;
   _total = _total + value;
-  _samples++;
-  _value = _total / _samples;
+  _value = value;
 }
 
 // send the value back to the controller
 void ChildFloat::sendValue() {
-  if (_value == -255) return;
-  _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
+  if (_total == -255) return;
+  float avg = _total / _samples;
+  _last_value = avg;
+  _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
   _total = -255;
   _samples = 0;
 }
 
-// check if it is an updated value
-bool ChildFloat::isNewValue() {
-  return _last_value != _value;
-}
-
 // ChildDouble class
 ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
 
 // store a new value and update the total
 void ChildDouble::setValueDouble(double value) {
+  _samples++;
   _total = _total + value;
-  _samples++;
-  _value = _total / _samples;
+  _value = value;
 }
 
 // send the value back to the controller
 void ChildDouble::sendValue() {
-  if (_value == -255) return;
-  _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
+  if (_total == -255) return;
+  double avg = _total / _samples;
+  _last_value = avg;
+  _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
   _total = -255;
   _samples = 0;
 }
 
-// check if it is an updated value
-bool ChildDouble::isNewValue() {
-  return _last_value != _value;
-}
-
 // ChildString class
 ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -332,16 +315,11 @@ void ChildString::setValueString(char* value) {
 
 // send the value back to the controller
 void ChildString::sendValue() {
+  _last_value = _value;
   _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
   _value = "";
 }
 
-// check if it is an updated value
-bool ChildString::isNewValue() {
-  return strcmp(_value, _last_value) != 0;
-}
-
 /*
    Sensor class
 */
@@ -352,6 +330,7 @@ Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
   _node = &nodeManager;
   _pin = pin;
   _report_timer = new Timer(_node);
+  _force_update_timer = new Timer(_node);
   _node->registerSensor(this);
 }
 
@@ -372,13 +351,10 @@ void Sensor::setTrackLastValue(bool value) {
   _track_last_value = value;
 }
 void Sensor::setForceUpdateMinutes(int value) {
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
-    child->force_update_timer->start(value,MINUTES);
-  }
+  _force_update_timer->start(value,MINUTES);
 }
 void Sensor::setForceUpdateHours(int value) {
-  setForceUpdateMinutes(value*60);
+  _force_update_timer->start(value,HOURS);
 }
 #if POWER_MANAGER == 1
     void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
@@ -493,8 +470,6 @@ void Sensor::loop(MyMessage* message) {
   // iterates over all the children
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
-    // update the force update timer if running
-    if (child->force_update_timer->isRunning()) child->force_update_timer->update();
     // if a specific child is requested, skip all the others
     if (message != nullptr && message->sensor != child->child_id) continue;
     // collect multiple samples if needed
@@ -506,13 +481,8 @@ void Sensor::loop(MyMessage* message) {
       // wait between samples
       if (_samples_interval > 0) _node->sleepOrWait(_samples_interval);
     }
-    // process the result and send a response back if 1) is not a loop 2) not tracking last value 3) tracking last value and there is a new value 4) tracking last value and timer is over
-    if (
-      message != nullptr || 
-      ! _track_last_value || 
-      _track_last_value && child->isNewValue() || 
-      _track_last_value && child->force_update_timer->isRunning() && child->force_update_timer->isOver()) 
-        child->sendValue();
+    // process the result and send a response back
+    child->sendValue();
   }
   // turn the sensor off
   #if POWER_MANAGER == 1
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -8,10 +8,6 @@
    PowerManager
 */
 
-PowerManager::PowerManager(int ground_pin, int vcc_pin, int wait_time) {
-  setPowerPins(ground_pin, vcc_pin, wait_time);
-}
-
 // set the vcc and ground pin the sensor is connected to
 void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
   _ground_pin = ground_pin;
@@ -36,6 +32,7 @@ void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
   _wait = wait_time;
 }
 
+
 // turn on the sensor by activating its power pins
 void PowerManager::powerOn() {
   if (_vcc_pin == -1) return;
@@ -383,18 +380,20 @@ void Sensor::setForceUpdateMinutes(int value) {
 void Sensor::setForceUpdateHours(int value) {
   setForceUpdateMinutes(value*60);
 }
-void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
-  if (_powerManager == nullptr) return;
-  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
-}
-void Sensor::powerOn() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOn();
-}
-void Sensor::powerOff() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOff();
-}
+#if POWER_MANAGER == 1
+    void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
+      _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
+    }
+    void Sensor::setAutoPowerPins(bool value) {
+      _auto_power_pins = value;
+    }
+    void Sensor::powerOn() {
+      _powerManager.powerOn();
+    }
+    void Sensor::powerOff() {
+      _powerManager.powerOff();
+    }
+#endif
 int Sensor::getInterruptPin() {
   return _interrupt_pin;
 }
@@ -486,8 +485,10 @@ void Sensor::loop(MyMessage* message) {
       if (! _report_timer->isOver() && ! first_run) return;
     }
   }
-  // turn the sensor on
-  powerOn();
+  #if POWER_MANAGER == 1
+    // turn the sensor on
+    if (_auto_power_pins) powerOn();
+  #endif
   // iterates over all the children
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
@@ -513,7 +514,9 @@ void Sensor::loop(MyMessage* message) {
         child->sendValue();
   }
   // turn the sensor off
-  powerOff();
+  #if POWER_MANAGER == 1
+    if (_auto_power_pins) powerOff();
+  #endif
   // if called from loop(), restart the report timer if over
   if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
 }
@@ -550,8 +553,11 @@ void Sensor::process(const Request & request) {
     case 6: setSamplesInterval(request.getValueInt()); break;
     case 7: setTrackLastValue(request.getValueInt()); break;
     case 9: setForceUpdateMinutes(request.getValueInt()); break;
-    case 13: powerOn(); break;
-    case 14: powerOff(); break;
+    #if POWER_MANAGER == 1
+      case 12: setAutoPowerPins(request.getValueInt()); break;
+      case 13: powerOn(); break;
+      case 14: powerOff(); break;
+    #endif
     case 16: setReportIntervalMinutes(request.getValueInt()); break;
     case 17: setReportIntervalSeconds(request.getValueInt()); break;
     case 19: setReportIntervalHours(request.getValueInt()); break;
@@ -571,11 +577,6 @@ Child* Sensor::getChild(int child_id) {
   return nullptr;
 }
 
-void Sensor::setPowerManager(const PowerManager& powerManager) {
-  _powerManager = &powerManager;
-}
-
-
 // virtual functions
 void Sensor::onBefore() {}
 void Sensor::onSetup(){}
@@ -3236,18 +3237,20 @@ void NodeManager::setInterrupt(int pin, int mode, int initial) {
 void NodeManager::setInterruptMinDelta(long value) {
   _interrupt_min_delta = value;
 }
-void NodeManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
-  if (_powerManager == nullptr) return;
-  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
-}
-void NodeManager::powerOn() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOn();
-}
-void NodeManager::powerOff() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOff();
-}
+#if POWER_MANAGER == 1
+  void NodeManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
+    _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
+  }
+  void NodeManager::setAutoPowerPins(bool value) {
+    _auto_power_pins = value;  
+  }
+  void NodeManager::powerOn() {
+    _powerManager.powerOn();
+  }
+  void NodeManager::powerOff() {
+    _powerManager.powerOff();
+  }
+#endif
 void NodeManager::setSleepBetweenSend(int value) {
   _sleep_between_send = value;
 }
@@ -3622,8 +3625,10 @@ void NodeManager::setup() {
 
 // run the main function for all the register sensors
 void NodeManager::loop() {
-  // turn on the pin powering all the sensors
-  powerOn();
+  #if POWER_MANAGER == 1
+    // turn on the pin powering all the sensors
+    if (_auto_power_pins) powerOn();
+  #endif
   // run loop for all the registered sensors
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3641,8 +3646,10 @@ void NodeManager::loop() {
       sensor->loop(nullptr);
     }
   }
-  // turn off the pin powering all the sensors
-  powerOff();
+  #if POWER_MANAGER == 1
+    // turn off the pin powering all the sensors
+    if (_auto_power_pins) powerOff();
+  #endif
   // continue/start sleeping as requested
   if (isSleepingNode()) _sleep();
 }
@@ -3673,12 +3680,16 @@ void NodeManager::receive(const MyMessage &message) {
   // dispatch the message to the registered sensor
   Sensor* sensor = getSensorWithChild(message.sensor);
   if (sensor != nullptr) {
-    // turn on the pin powering all the sensors
-    powerOn();
+    #if POWER_MANAGER == 1
+      // turn on the pin powering all the sensors
+      if (_auto_power_pins) powerOn();
+    #endif
     // call the sensor's receive()
     sensor->receive(message);
-    // turn off the pin powering all the sensors
-    powerOff();
+    #if POWER_MANAGER == 1
+      // turn off the pin powering all the sensors
+      if (_auto_power_pins) powerOff();
+    #endif
   }
 }
 
@@ -3736,8 +3747,11 @@ void NodeManager::process(Request & request) {
     case 20: setSleepBetweenSend(request.getValueInt()); break;
     case 21: setAck(request.getValueInt()); break;
     case 22: setIsMetric(request.getValueInt()); break;
-    case 24: powerOn(); break;
-    case 25: powerOff(); break;
+    #if POWER_MANAGER == 1
+      case 23: setAutoPowerPins(request.getValueInt()); break;
+      case 24: powerOn(); break;
+      case 25: powerOff(); break;
+    #endif
     case 27: saveToMemory(0,request.getValueInt()); break;
     case 28: setInterruptMinDelta(request.getValueInt()); break;
     case 30: setSleepOrWait(request.getValueInt()); break;
@@ -3994,10 +4008,6 @@ void NodeManager::_sendMessage(int child_id, int type) {
   }
 }
 
-void NodeManager::setPowerManager(const PowerManager& powerManager) {
-  _powerManager = &powerManager;
-}
-
 // return the requested child 
 Child* NodeManager::getChild(int child_id) {
   Sensor* sensor = getSensorWithChild(child_id);
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -380,6 +380,9 @@ void Sensor::setForceUpdateMinutes(int value) {
     child->force_update_timer->start(value,MINUTES);
   }
 }
+void Sensor::setForceUpdateHours(int value) {
+  setForceUpdateMinutes(value*60);
+}
 void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
   if (_powerManager == nullptr) return;
   _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
@@ -553,6 +556,7 @@ void Sensor::process(const Request & request) {
     case 17: setReportIntervalSeconds(request.getValueInt()); break;
     case 19: setReportIntervalHours(request.getValueInt()); break;
     case 20: setReportIntervalDays(request.getValueInt()); break;
+    case 18: setForceUpdateHours(request.getValueInt()); break;
     default: return;
   }
   _node->sendMessage(request.getChildId(),V_CUSTOM,function);
@@ -615,7 +622,6 @@ void SensorBattery::onBefore() {
 
 // what to do during setup
 void SensorBattery::onSetup() {
-  // when measuring the battery from a pin, analog reference must be internal
   if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
 }
 
@@ -645,7 +651,7 @@ void SensorBattery::onLoop(Child* child) {
 void SensorBattery::onReceive(MyMessage* message) {
   Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+  if (message->getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -658,6 +664,7 @@ void SensorBattery::onProcess(Request & request) {
     case 104: setBatteryInternalVcc(request.getValueInt()); break;
     case 105: setBatteryPin(request.getValueInt()); break;
     case 106: setBatteryVoltsPerBit(request.getValueFloat()); break;
+    case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
     default: return;
   }
   _node->sendMessage(request.getChildId(),V_CUSTOM,function);
@@ -707,7 +714,7 @@ void SensorSignal::onLoop(Child* child) {
 void SensorSignal::onReceive(MyMessage* message) {
   Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+  if (message->getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -1464,7 +1471,6 @@ SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  // register the child
   new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
   new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
   // initialize the library
@@ -1514,7 +1520,7 @@ void SensorSHT21::onLoop(Child* child) {
 void SensorSHT21::onReceive(MyMessage* message) {
   Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+  if (message->getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -3658,7 +3664,7 @@ void NodeManager::receive(const MyMessage &message) {
     Serial.print(F(" P="));
     Serial.println(message.getString());
   #endif
-  // process incoming messages to the configuration child
+  // process incoming configuration message
   if (message.sensor == CONFIGURATION_CHILD_ID && message.getCommand() == C_REQ && message.type == V_CUSTOM) {
     #if REMOTE_CONFIGURATION == 1
       // parse the request
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -166,26 +166,20 @@ float Timer::getElapsed() {
     Request
 */
 
-// contructor, tokenize a request in the format "child_id,function,value"
-Request::Request(int recipient_child_id, const char* string) {
-  _recipient_child_id = recipient_child_id;
+Request::Request(int child_id, const char* string) {
+  _child_id = child_id;
   char* ptr;
   // copy to working area
   strcpy((char*)&_value, string);
   // tokenize the string and split function from value
   strtok_r(_value, ",", &ptr);
-  // get child id
-  _child_id = atoi(_value);
-  // get the function id
-  strtok_r(NULL, ",", &ptr);
+  // get function code
   _function = atoi(_value);
   // move user data to working area
   strcpy(_value,ptr);
   #if DEBUG == 1
     Serial.print(F("REQ F="));
     Serial.print(getFunction());
-    Serial.print(F(" C="));
-    Serial.print(getChildId());
     Serial.print(F(" I="));
     Serial.print(getValueInt());
     Serial.print(F(" F="));
@@ -195,11 +189,6 @@ Request::Request(int child_id, const char* string) {
   #endif
 }
 
-// return the child id
-int Request::getRecipientChildId() {
-  return _recipient_child_id;
-}
-
 // return the child id
 int Request::getChildId() {
   return _child_id;
@@ -369,11 +358,6 @@ Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
   _node->registerSensor(this);
 }
 
-// return the name of the sensor
-char* Sensor::getName() {
-  return _name;
-}
-
 // setter/getter
 void Sensor::setPin(int value) {
   _pin = value;
@@ -539,8 +523,39 @@ void Sensor::interrupt() {
 
 // receive a message from the radio network
 void Sensor::receive(const MyMessage &message) {
-  // a request would make the sensor executing its main task passing along the message
-  loop(&message);
+  // check if it is a request for the API
+  if (message.getCommand() == C_REQ && message.type == V_CUSTOM) {
+    #if REMOTE_CONFIGURATION == 1
+      // parse the request
+      Request request = Request(message.sensor,message.getString());
+      // if it is for a sensor-generic function, call process(), otherwise the sensor-specific onProcess();
+      if (request.getFunction() < 100) process(request);
+      else onProcess(request);
+    #endif
+  } else {
+    // a request would make the sensor executing its main task passing along the message
+    loop(&message);
+  }
+}
+
+// process a remote configuration request message
+void Sensor::process(const Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 1: setPin(request.getValueInt()); break;
+    case 5: setSamples(request.getValueInt()); break;
+    case 6: setSamplesInterval(request.getValueInt()); break;
+    case 7: setTrackLastValue(request.getValueInt()); break;
+    case 9: setForceUpdateMinutes(request.getValueInt()); break;
+    case 13: powerOn(); break;
+    case 14: powerOff(); break;
+    case 16: setReportIntervalMinutes(request.getValueInt()); break;
+    case 17: setReportIntervalSeconds(request.getValueInt()); break;
+    case 19: setReportIntervalHours(request.getValueInt()); break;
+    case 20: setReportIntervalDays(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // return the requested child 
@@ -562,14 +577,15 @@ void Sensor::onBefore() {}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
 void Sensor::onReceive(MyMessage* message){}
+void Sensor::onProcess(Request & request){}
 void Sensor::onInterrupt(){}
 
 /*
    SensorBattery
 */
 // contructor
-SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager) {
-  _name = "BAT";
+SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager,A2) {
+  _name = F("BAT");
   // report battery level every 60 minutes by default
   setReportIntervalMinutes(60);
 }
@@ -653,8 +685,8 @@ void SensorBattery::onInterrupt() {
    SensorSignal
 */
 // contructor
-SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager) {
-  _name = "SIG";
+SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager,A2) {
+  _name = F("SIG");
   // report signal level every 60 minutes by default
   setReportIntervalMinutes(60);
 }
@@ -691,126 +723,20 @@ void SensorSignal::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorSignal::onInterrupt() {
-}
-
-/*
-   SensorConfiguration
-*/
-// contructor
-SensorConfiguration::SensorConfiguration(NodeManager& nodeManager): Sensor(nodeManager) {
-  _name = "CONF";
-}
-
-// what to do during before
-void SensorConfiguration::onBefore() {
-  new ChildInt(this,CONFIGURATION_CHILD_ID,S_CUSTOM,V_CUSTOM);
-}
-
-// what to do during setup
-void SensorConfiguration::onSetup() {
-
-}
-
-// what to do during loop
-void SensorConfiguration::onLoop(Child* child) {
-}
-
-// what to do as the main task when receiving a message
-void SensorConfiguration::onReceive(MyMessage* message) {
-  // parse the request
-  Request request = Request(message->sensor,message->getString());
+// what to do when receiving a remote message
+void SensorSignal::onProcess(Request & request) {
+#if REMOTE_CONFIGURATION == 1
   int function = request.getFunction();
-  int child_id = request.getChildId();
-  // if the message is for the board itself
-  if (child_id == 0) {
-    switch(function) {
-      case 1: _node->hello(); break;
-      case 3: _node->setSleepSeconds(request.getValueInt()); break;
-      case 4: _node->setSleepMinutes(request.getValueInt()); break;
-      case 5: _node->setSleepHours(request.getValueInt()); break;
-      case 29: _node->setSleepDays(request.getValueInt()); break;
-      #ifndef MY_GATEWAY_ESP8266
-        case 6: _node->reboot(); return;
-      #endif
-      case 7: _node->clearEeprom(); break;
-      case 8: _node->sendMessage(request.getChildId(),V_CUSTOM,VERSION); return;
-      case 9: _node->wakeup(); break;
-      case 10: _node->setRetries(request.getValueInt()); break;
-      case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
-      case 20: _node->setSleepBetweenSend(request.getValueInt()); break;
-      case 21: _node->setAck(request.getValueInt()); break;
-      case 22: _node->setIsMetric(request.getValueInt()); break;
-      case 24: _node->powerOn(); break;
-      case 25: _node->powerOff(); break;
-      case 27: _node->saveToMemory(0,request.getValueInt()); break;
-      case 28: _node->setInterruptMinDelta(request.getValueInt()); break;
-      case 30: _node->setSleepOrWait(request.getValueInt()); break;
-      case 31: _node->setRebootPin(request.getValueInt()); break;
-      case 32: _node->setADCOff(); break;
-      case 36: _node->setReportIntervalSeconds(request.getValueInt()); break;
-      case 37: _node->setReportIntervalMinutes(request.getValueInt()); break;
-      case 38: _node->setReportIntervalHours(request.getValueInt()); break;
-      case 39: _node->setReportIntervalDays(request.getValueInt()); break;
-      default: return; 
-    }
-  // the request is for a sensor
-  } else {
-    // retrieve the sensor the child is belonging to
-    Sensor* sensor = _node->getSensorWithChild(child_id);
-    if (sensor == nullptr) return;
-    // if the message is for a function common to all the sensors
-    if (request.getFunction() < 100) {
-      switch(function) {
-        case 1: sensor->setPin(request.getValueInt()); break;
-        case 5: sensor->setSamples(request.getValueInt()); break;
-        case 6: sensor->setSamplesInterval(request.getValueInt()); break;
-        case 7: sensor->setTrackLastValue(request.getValueInt()); break;
-        case 9: sensor->setForceUpdateMinutes(request.getValueInt()); break;
-        case 13: sensor->powerOn(); break;
-        case 14: sensor->powerOff(); break;
-        case 16: sensor->setReportIntervalMinutes(request.getValueInt()); break;
-        case 17: sensor->setReportIntervalSeconds(request.getValueInt()); break;
-        case 19: sensor->setReportIntervalHours(request.getValueInt()); break;
-        case 20: sensor->setReportIntervalDays(request.getValueInt()); break;
-        default: return;
-      }
-    } else {
-      // the message is for a function specific to a sensor
-      if (strcmp(sensor->getName(),"BAT") == 0) {
-        SensorBattery* custom_sensor = (SensorBattery*)sensor;
-        switch(function) {
-          case 102: custom_sensor->setMinVoltage(request.getValueFloat()); break;
-          case 103: custom_sensor->setMaxVoltage(request.getValueFloat()); break;
-          case 104: custom_sensor->setBatteryInternalVcc(request.getValueInt()); break;
-          case 105: custom_sensor->setBatteryPin(request.getValueInt()); break;
-          case 106: custom_sensor->setBatteryVoltsPerBit(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      if (strcmp(sensor->getName(),"SIG") == 0) {
-        SensorSignal* custom_sensor = (SensorSignal*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setSignalCommand(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #if MODULE_SHT21 == 1
-      if (strcmp(sensor->getName(),"SHT21") == 0) {
-        SensorSHT21* custom_sensor = (SensorSHT21*)sensor;
-        switch(function) {
-          default: return;
-        }
-      }
-      #endif
-    }
+  switch(function) {
+    case 101: setSignalCommand(request.getValueInt()); break;
+    default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+#endif
 }
 
 // what to do when receiving an interrupt
-void SensorConfiguration::onInterrupt() {
+void SensorSignal::onInterrupt() {
 }
 
 
@@ -885,7 +811,7 @@ void SensorAnalogInput::onProcess(Request & request) {
     case 105: setRangeMax(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1014,7 +940,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1140,7 +1066,7 @@ void SensorACS712::onProcess(Request & request) {
     case 102: setOffset(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1306,7 +1232,7 @@ void SensorDigitalOutput::onProcess(Request & request) {
     case 107: setWaitAfterSet(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1432,7 +1358,7 @@ void SensorLatchingRelay::onProcess(Request & request) {
     case 203: setPinOn(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // switch to the requested status
@@ -1546,7 +1472,7 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
-  _name = "SHT21";
+  _name = F("SHT");
 }
 
 // what to do during before
@@ -1677,7 +1603,7 @@ void SensorSwitch::onProcess(Request & request) {
     case 104: setInitial(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1783,7 +1709,7 @@ void SensorDs18b20::onProcess(Request & request) {
     case 102: setSleepDuringConversion(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1860,7 +1786,7 @@ void SensorBH1750::onProcess(Request & request) {
     case 101: setMode(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 
@@ -1986,7 +1912,7 @@ void SensorBosch::onProcess(Request & request) {
     case 101: setForecastSamplesCount(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2321,7 +2247,7 @@ void SensorHCSR04::onProcess(Request & request) {
     case 103: setMaxDistance(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2406,7 +2332,7 @@ void SensorSonoff::onProcess(Request & request) {
     case 103: setLedPin(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2604,7 +2530,7 @@ void SensorMQ::onProcess(Request & request) {
     case 8: setReadSampleInterval(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2759,7 +2685,7 @@ void SensorMHZ19::onProcess(Request & request) {
   switch(function) {
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2976,7 +2902,7 @@ void SensorTSL2561::onProcess(Request & request) {
     case 104: setAddress(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3038,7 +2964,7 @@ void SensorPT100::onProcess(Request & request) {
     case 101: setVoltageRef(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3107,7 +3033,7 @@ void SensorDimmer::onProcess(Request & request) {
     case 103: setStepDuration(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3209,7 +3135,7 @@ void SensorPulseMeter::onProcess(Request & request) {
     case 102: setPulseFactor(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3670,6 +3596,8 @@ void NodeManager::presentation() {
   // Send the sketch version information to the gateway and Controller
   if (_sleep_between_send > 0) sleep(_sleep_between_send);
   sendSketchInfo(SKETCH_NAME,SKETCH_VERSION);
+  // present the service as a custom sensor to the controller
+  _present(CONFIGURATION_CHILD_ID, S_CUSTOM);
   // present each sensor
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3743,6 +3671,15 @@ void NodeManager::receive(const MyMessage &message) {
     Serial.print(F(" P="));
     Serial.println(message.getString());
   #endif
+  // process incoming messages to the configuration child
+  if (message.sensor == CONFIGURATION_CHILD_ID && message.getCommand() == C_REQ && message.type == V_CUSTOM) {
+    #if REMOTE_CONFIGURATION == 1
+      // parse the request
+      Request request = Request(message.sensor,message.getString());
+      // process the request
+      process(request);
+    #endif
+  }
   // dispatch the message to the registered sensor
   Sensor* sensor = getSensorWithChild(message.sensor);
   if (sensor != nullptr) {
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -170,19 +170,28 @@ float Timer::getElapsed() {
 Request::Request(int recipient_child_id, const char* string) {
   _recipient_child_id = recipient_child_id;
   char* ptr;
-  // tokenize the string and get child id
-  _child_id = atoi(strtok_r(string, ",", &ptr));
-  // tokenize the string and get function id
-  _function = atoi(strtok_r(NULL, ",", &ptr));
-  // tokenize the string and get the value
-  _value = atof(strtok_r(NULL, ",", &ptr));
+  // copy to working area
+  strcpy((char*)&_value, string);
+  // tokenize the string and split function from value
+  strtok_r(_value, ",", &ptr);
+  // get child id
+  _child_id = atoi(_value);
+  // get the function id
+  strtok_r(NULL, ",", &ptr);
+  _function = atoi(_value);
+  // move user data to working area
+  strcpy(_value,ptr);
   #if DEBUG == 1
-    Serial.print(F("REQ C="));
+    Serial.print(F("REQ F="));
+    Serial.print(getFunction());
+    Serial.print(F(" C="));
     Serial.print(getChildId());
+    Serial.print(F(" I="));
+    Serial.print(getValueInt());
     Serial.print(F(" F="));
-    Serial.print(getFunction());
-    Serial.print(F(" V="));
     Serial.print(getValueFloat());
+    Serial.print(F(" S="));
+    Serial.println(getValueString());
   #endif
 }
 
@@ -203,15 +212,21 @@ int Request::getFunction() {
 
 // return the value as an int
 int Request::getValueInt() {
-  return _value;
+  return atoi(_value);
   
 }
 
 // return the value as a float
 float Request::getValueFloat() {
+  return atof(_value);
+}
+
+// return the value as a string
+char* Request::getValueString() {
   return _value;
 }
 
+
 /******************************************
     Sensors
 */
@@ -688,8 +703,6 @@ void SensorConfiguration::onLoop(Child* child) {
 
 // what to do as the main task when receiving a message
 void SensorConfiguration::onReceive(MyMessage* message) {
-  // expect a REQ, V_CUSTOM message
-  if (message->getCommand() != C_REQ && message->type != V_CUSTOM) return;
   // parse the request
   Request request = Request(message->sensor,message->getString());
   int function = request.getFunction();
@@ -706,7 +719,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         case 6: _node->reboot(); return;
       #endif
       case 7: _node->clearEeprom(); break;
-      case 8: _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,VERSION); return;
+      case 8: _node->sendMessage(request.getChildId(),V_CUSTOM,VERSION); return;
       case 9: _node->wakeup(); break;
       case 10: _node->setRetries(request.getValueInt()); break;
       case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
@@ -777,7 +790,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
       #endif
     }
   }
-  _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -981,7 +994,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 101: setNominalResistor((long)request.getValueInt()); break;
     case 102: setNominalTemperature(request.getValueInt()); break;
     case 103: setBCoefficient(request.getValueInt()); break;
-    case 104: setSeriesResistor((long)request.getValueInt()); break;
+    case 104: setSeriesResistor((long)request.getValueString()); break;
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -178,11 +178,11 @@ Request::Request(int recipient_child_id, const char* string) {
   _value = atof(strtok_r(NULL, ",", &ptr));
   #if DEBUG == 1
     Serial.print(F("REQ C="));
-    Serial.print(_child_id);
+    Serial.print(getChildId());
     Serial.print(F(" F="));
-    Serial.print(_function);
+    Serial.print(getFunction());
     Serial.print(F(" V="));
-    Serial.println(_value);
+    Serial.print(getValueFloat());
   #endif
 }
 
@@ -203,7 +203,7 @@ int Request::getFunction() {
 
 // return the value as an int
 int Request::getValueInt() {
-  return (int)_value;
+  return _value;
   
 }
 
@@ -255,10 +255,11 @@ void ChildInt::setValueInt(int value) {
 
 // send the value back to the controller
 void ChildInt::sendValue() {
-  if (_samples == 0) return;
+  if (_value == -255) return;
   _sensor->_node->sendMessage(child_id,type,_value);
   _last_value = _value;
-  _total = 0;
+  _value = -255;
+  _total = -255;
   _samples = 0;
 }
 
@@ -280,10 +281,11 @@ void ChildFloat::setValueFloat(float value) {
 
 // send the value back to the controller
 void ChildFloat::sendValue() {
-  if (_samples == 0) return;
+  if (_value == -255) return;
   _sensor->_node->sendMessage(child_id,type,_value);
   _last_value = _value;
-  _total = 0;
+  _value = -255;
+  _total = -255;
   _samples = 0;
 }
 
@@ -305,10 +307,11 @@ void ChildDouble::setValueDouble(double value) {
 
 // send the value back to the controller
 void ChildDouble::sendValue() {
-  if (_samples == 0) return;
+  if (_value == -255) return;
   _sensor->_node->sendMessage(child_id,type,_value);
   _last_value = _value;
-  _total = 0;
+  _value = -255;
+  _total = -255;
   _samples = 0;
 }
 
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -344,8 +344,8 @@ bool ChildString::isNewValue() {
 // constructor
 Sensor::Sensor() {  
 }
-Sensor::Sensor(const NodeManager& node_manager, int pin = -1) {
-  _node = &node_manager;
+Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
+  _node = &nodeManager;
   _pin = pin;
   _report_timer = new Timer(_node);
   _node->registerSensor(this);
@@ -550,7 +550,7 @@ void Sensor::onInterrupt(){}
    SensorBattery
 */
 // contructor
-SensorBattery::SensorBattery(const NodeManager& node_manager): Sensor(node_manager) {
+SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager) {
   _name = "BAT";
   // report battery level every 60 minutes by default
   setReportIntervalMinutes(60);
@@ -619,7 +619,7 @@ void SensorBattery::onInterrupt() {
    SensorSignal
 */
 // contructor
-SensorSignal::SensorSignal(const NodeManager& node_manager): Sensor(node_manager) {
+SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager) {
   _name = "SIG";
   // report signal level every 60 minutes by default
   setReportIntervalMinutes(60);
@@ -665,7 +665,7 @@ void SensorSignal::onInterrupt() {
    SensorConfiguration
 */
 // contructor
-SensorConfiguration::SensorConfiguration(const NodeManager& node_manager): Sensor(node_manager) {
+SensorConfiguration::SensorConfiguration(NodeManager& nodeManager): Sensor(nodeManager) {
   _name = "CONF";
 }
 
@@ -772,19 +772,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_ANALOG_INPUT == 1
-      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0) {
-        SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setReference(request.getValueInt()); break;
-          case 102: custom_sensor->setReverse(request.getValueInt()); break;
-          case 103: custom_sensor->setOutputPercentage(request.getValueInt()); break;
-          case 104: custom_sensor->setRangeMin(request.getValueInt()); break;
-          case 105: custom_sensor->setRangeMax(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -801,8 +788,7 @@ void SensorConfiguration::onInterrupt() {
 */
 
 // contructor
-SensorAnalogInput::SensorAnalogInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "A-IN";
+SensorAnalogInput::SensorAnalogInput(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
 }
 
 // setter/getter
@@ -824,13 +810,12 @@ void SensorAnalogInput::setRangeMax(int value) {
 
 // what to do during before
 void SensorAnalogInput::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+  // prepare the pin for input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during setup
 void SensorAnalogInput::onSetup() {
-  // prepare the pin for input
-  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -841,23 +826,34 @@ void SensorAnalogInput::onLoop(Child* child) {
   int percentage = 0;
   if (_output_percentage) percentage = _getPercentage(adc);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("A-IN I="));
+    Serial.print(_child_id);
     Serial.print(F(" V="));
     Serial.print(adc);
     Serial.print(F(" %="));
     Serial.println(percentage);
   #endif
   // store the result
-  ((ChildInt*)child)->setValueInt(_output_percentage ? percentage : adc);
+  _value_int = _output_percentage ? percentage : adc;
 }
 
 // what to do during loop
-void SensorAnalogInput::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorAnalogInput::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorAnalogInput::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setReference(request.getValueInt()); break;
+    case 102: setReverse(request.getValueInt()); break;
+    case 103: setOutputPercentage(request.getValueInt()); break;
+    case 104: setRangeMin(request.getValueInt()); break;
+    case 105: setRangeMax(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -897,17 +893,13 @@ int SensorAnalogInput::_getPercentage(int adc) {
 */
 
 // contructor
-SensorLDR::SensorLDR(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "LDR";
+SensorLDR::SensorLDR(NodeManager* node_manager, int child_id, int pin): SensorAnalogInput(node_manager, child_id, pin) {
+  // set presentation and type and reverse (0: no light, 100: max light)
+  setPresentation(S_LIGHT_LEVEL);
+  setType(V_LIGHT_LEVEL);
+  setReverse(true);
 }
 
-// what to do during before
-void SensorLDR::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
-  setReverse(true);
-}
-#endif
-#if MODULE_ANALOG_INPUT2 == 1
 /*
    SensorThermistor
 */
@@ -1521,7 +1513,7 @@ void SensorDHT::onInterrupt() {
 */
 #if MODULE_SHT21 == 1
 // contructor
-SensorSHT21::SensorSHT21(const NodeManager& node_manager): Sensor(node_manager) {
+SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
   _name = "SHT21";
 }
 
@@ -1530,12 +1522,12 @@ void SensorSHT21::onBefore() {
   // register the child
   new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
   new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+  // initialize the library
+  Wire.begin();
 }
 
 // what to do during setup
 void SensorSHT21::onSetup() {
-  // initialize the library
-  Wire.begin();
 }
 
 // what to do during loop
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -785,19 +785,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_THERMISTOR == 1
-      if (strcmp(sensor->getName(),"THER") == 0) {
-        SensorThermistor* custom_sensor = (SensorThermistor*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setNominalResistor((long)request.getValueInt()); break;
-          case 102: custom_sensor->setNominalTemperature(request.getValueInt()); break;
-          case 103: custom_sensor->setBCoefficient(request.getValueInt()); break;
-          case 104: custom_sensor->setSeriesResistor((long)request.getValueInt()); break;
-          case 105: custom_sensor->setOffset(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -920,15 +907,17 @@ void SensorLDR::onBefore() {
   setReverse(true);
 }
 #endif
-
-#if MODULE_THERMISTOR == 1
+#if MODULE_ANALOG_INPUT2 == 1
 /*
    SensorThermistor
 */
 
 // contructor
-SensorThermistor::SensorThermistor(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "THER";
+SensorThermistor::SensorThermistor(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
+  // set presentation, type and value type
+  setPresentation(S_TEMP);
+  setType(V_TEMP);
+  setValueType(TYPE_FLOAT);
 }
 
 // setter/getter
@@ -950,13 +939,12 @@ void SensorThermistor::setOffset(float value) {
 
 // what to do during before
 void SensorThermistor::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during setup
 void SensorThermistor::onSetup() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -975,49 +963,60 @@ void SensorThermistor::onLoop(Child* child) {
   temperature -= 273.15;                         // convert to C
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("THER I="));
+    Serial.print(_child_id);
     Serial.print(F(" V="));
     Serial.print(adc);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  _value_float = temperature;
 }
 
 // what to do as the main task when receiving a message
-void SensorThermistor::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorThermistor::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorThermistor::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setNominalResistor((long)request.getValueInt()); break;
+    case 102: setNominalTemperature(request.getValueInt()); break;
+    case 103: setBCoefficient(request.getValueInt()); break;
+    case 104: setSeriesResistor((long)request.getValueInt()); break;
+    case 105: setOffset(request.getValueFloat()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
 void SensorThermistor::onInterrupt() {
 }
-#endif
 
-#if MODULE_ML8511 == 1
 /*
    SensorML8511
 */
 
 // contructor
-SensorML8511::SensorML8511(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "UV";
+SensorML8511::SensorML8511(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
+  // set presentation, type and value type
+  setPresentation(S_UV);
+  setType(V_UV);
+  setValueType(TYPE_FLOAT);
 }
 
 // what to do during before
 void SensorML8511::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_UV,V_UV);
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during setup
 void SensorML8511::onSetup() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -1030,23 +1029,24 @@ void SensorML8511::onLoop(Child* child) {
   //Convert the voltage to a UV intensity level
   float uvIntensity = _mapfloat(outputVoltage, 0.99, 2.8, 0.0, 15.0); 
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("UV I="));
+    Serial.print(_child_id);
     Serial.print(F(" V="));
     Serial.print(outputVoltage);
     Serial.print(F(" I="));
     Serial.println(uvIntensity);
   #endif
   // store the value
-  ((ChildFloat*)child)->setValueFloat(uvIntensity);
+  _value_float = uvIntensity;
 }
 
 // what to do as the main task when receiving a message
-void SensorML8511::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorML8511::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorML8511::onProcess(Request & request) {
 }
 
 // what to do when receiving an interrupt
@@ -1057,9 +1057,7 @@ void SensorML8511::onInterrupt() {
 float SensorML8511::_mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
   return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 }
-#endif
 
-#if MODULE_ANALOG_INPUT2 == 1
 /*
    SensorACS712
 */
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -773,7 +773,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
       }
       #endif
       #if MODULE_ANALOG_INPUT == 1
-      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0 || strcmp(sensor->getName(),"RAIN") == 0 || strcmp(sensor->getName(),"SOIL") == 0) {
+      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0) {
         SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
         switch(function) {
           case 101: custom_sensor->setReference(request.getValueInt()); break;
@@ -798,16 +798,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_ACS712 == 1
-      if (strcmp(sensor->getName(),"ACS") == 0) {
-        SensorACS712* custom_sensor = (SensorACS712*)sensor;
-        switch(function) {
-          case 100: custom_sensor->setmVPerAmp(request.getValueInt()); break;
-          case 102: custom_sensor->setOffset(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -927,56 +917,7 @@ SensorLDR::SensorLDR(const NodeManager& node_manager, int pin): SensorAnalogInpu
 // what to do during before
 void SensorLDR::onBefore() {
   new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
-}
-
-// what to do during setup
-void SensorLDR::onSetup() {
-  setReverse(true);
-}
-
-/*
-   SensorRain
-*/
-
-// contructor
-SensorRain::SensorRain(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "RAIN";
-}
-
-// what to do during before
-void SensorRain::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_RAIN,V_RAINRATE);
-}
-
-// what to do during setup
-void SensorRain::onSetup() {
-  setReference(DEFAULT);
-  setOutputPercentage(true);
   setReverse(true);
-  setRangeMin(100);
-}
-
-/*
-   SensorSoilMoisture
-*/
-
-// contructor
-SensorSoilMoisture::SensorSoilMoisture(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "SOIL";
-}
-
-// what to do during before
-void SensorSoilMoisture::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_MOISTURE,V_LEVEL);
-}
-
-// what to do during setup
-void SensorSoilMoisture::onSetup() {
-  setReverse(true);
-  setReference(DEFAULT);
-  setOutputPercentage(true);
-  setReverse(true);
-  setRangeMin(100);
 }
 #endif
 
@@ -1118,14 +1059,17 @@ float SensorML8511::_mapfloat(float x, float in_min, float in_max, float out_min
 }
 #endif
 
-#if MODULE_ACS712 == 1
+#if MODULE_ANALOG_INPUT2 == 1
 /*
    SensorACS712
 */
 
 // contructor
-SensorACS712::SensorACS712(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "ACS";
+SensorACS712::SensorACS712(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
+  // set presentation, type and value type
+  setPresentation(S_MULTIMETER);
+  setType(V_CURRENT);
+  setValueType(TYPE_FLOAT);
 }
 
 // setter/getter
@@ -1138,13 +1082,12 @@ void SensorACS712::setOffset(int value) {
 
 // what to do during before
 void SensorACS712::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_MULTIMETER,V_CURRENT);
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during setup
 void SensorACS712::onSetup() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -1153,27 +1096,65 @@ void SensorACS712::onLoop(Child* child) {
   // convert the analog read in mV
   double voltage = (value / 1024.0) * 5000; 
   // convert voltage in amps
-  float value_float = ((voltage - _ACS_offset) / _mv_per_amp);
+  _value_float = ((voltage - _ACS_offset) / _mv_per_amp);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("ACS I="));
+    Serial.print(_child_id);
     Serial.print(F(" A="));
-    Serial.println(value_float);
+    Serial.println(_value_float);
   #endif
-  ((ChildFloat*)child)->setValueFloat(value_float);
 }
 
 // what to do as the main task when receiving a message
-void SensorACS712::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorACS712::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorACS712::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 100: setmVPerAmp(request.getValueInt()); break;
+    case 102: setOffset(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
 void SensorACS712::onInterrupt() {
 }
+
+/*
+   SensorRain
+*/
+
+// contructor
+SensorRain::SensorRain(NodeManager* node_manager, int child_id, int pin): SensorAnalogInput(node_manager,child_id, pin) {
+  // set presentation and type and reverse
+  setPresentation(S_RAIN);
+  setType(V_RAINRATE);
+  setReference(DEFAULT);
+  setOutputPercentage(true);
+  setReverse(true);
+  setRangeMin(100);
+}
+
+/*
+   SensorSoilMoisture
+*/
+
+// contructor
+SensorSoilMoisture::SensorSoilMoisture(NodeManager* node_manager, int child_id, int pin): SensorAnalogInput(node_manager, child_id, pin) {
+  // set presentation and type and reverse
+  setPresentation(S_MOISTURE);
+  setType(V_LEVEL);
+  setReference(DEFAULT);
+  setOutputPercentage(true);
+  setReverse(true);
+  setRangeMin(100);
+}
+
 #endif
 
 #if MODULE_DIGITAL_INPUT == 1
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -1182,20 +1182,17 @@ void SensorACS712::onInterrupt() {
 */
 
 // contructor
-SensorDigitalInput::SensorDigitalInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "D-IN";
+SensorDigitalInput::SensorDigitalInput(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id, pin) {
 }
 
 // what to do during before
 void SensorDigitalInput::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+  // set the pin for input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during setup
 void SensorDigitalInput::onSetup() {
-  // set the pin for input
-  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -1203,23 +1200,24 @@ void SensorDigitalInput::onLoop(Child* child) {
   // read the value
   int value = digitalRead(_pin);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("D-IN I="));
+    Serial.print(_child_id);
     Serial.print(F(" P="));
     Serial.print(_pin);
     Serial.print(F(" V="));
     Serial.println(value);
   #endif
   // store the value
-  ((ChildInt*)child)->setValueInt(value);
+  _value_int = value;
 }
 
 // what to do as the main task when receiving a message
-void SensorDigitalInput::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorDigitalInput::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorDigitalInput::onProcess(Request & request) {
 }
 
 // what to do when receiving an interrupt
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -808,28 +808,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_DIGITAL_OUTPUT == 1
-      if (strcmp(sensor->getName(),"DOUT") == 0 || strcmp(sensor->getName(),"REL") == 0 || strcmp(sensor->getName(),"LATC") == 0) {
-        SensorDigitalOutput* custom_sensor = (SensorDigitalOutput*)sensor;
-        switch(function) {
-            case 103: custom_sensor->setOnValue(request.getValueInt()); break;
-            case 104: custom_sensor->setLegacyMode(request.getValueInt()); break;
-            case 105: custom_sensor->setSafeguard(request.getValueInt()); break;
-            case 106: custom_sensor->setInputIsElapsed(request.getValueInt()); break;
-            case 107: custom_sensor->setWaitAfterSet(request.getValueInt()); break;
-          default: return;
-        }
-        if (function > 200 && strcmp(sensor->getName(),"LATC") == 0) {
-          SensorLatchingRelay* custom_sensor_2 = (SensorLatchingRelay*)sensor;
-          switch(function) {
-            case 201: custom_sensor_2->setPulseWidth(request.getValueInt()); break;
-            case 202: custom_sensor_2->setPinOff(request.getValueInt()); break;
-            case 203: custom_sensor_2->setPinOn(request.getValueInt()); break;
-          default: return;
-        }
-        }
-      }
-      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1255,19 +1233,18 @@ void SensorDigitalInput::onInterrupt() {
    SensorDigitalOutput
 */
 
-SensorDigitalOutput::SensorDigitalOutput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DOUT";
+SensorDigitalOutput::SensorDigitalOutput(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id, pin) {
+  _safeguard_timer = new Timer(node_manager);
 }
 
 // what to do during before
 void SensorDigitalOutput::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+  _setupPin(_pin);
+
 }
 
 // what to do during setup
 void SensorDigitalOutput::onSetup() {
-  _setupPin(children.get(1), _pin);
-  _safeguard_timer = new Timer(_node);
 }
 
 // setter/getter
@@ -1293,37 +1270,50 @@ void SensorDigitalOutput::setWaitAfterSet(int value) {
 // main task
 void SensorDigitalOutput::onLoop(Child* child) {
   // set the value to -1 so to avoid reporting to the gateway during loop
-  ((ChildInt*)child)->setValueInt(-1);
+  _value_int = -1;
+  _last_value_int = -1;
   // if a safeguard is set, check if it is time for it
   if (_safeguard_timer->isRunning()) {
     // update the timer
     _safeguard_timer->update();
     // if the time is over, turn the output off
-    if (_safeguard_timer->isOver()) setStatus(child->child_id,OFF);
+    if (_safeguard_timer->isOver()) setStatus(OFF);
   }
 }
 
 // what to do as the main task when receiving a message
-void SensorDigitalOutput::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
+void SensorDigitalOutput::onReceive(const MyMessage & message) {
   // by default handle a SET message but when legacy mode is set when a REQ message is expected instead
-  if ( (message->getCommand() == C_SET && ! _legacy_mode) || (message->getCommand() == C_REQ && _legacy_mode)) {
+  if ( (message.getCommand() == C_SET && ! _legacy_mode) || (message.getCommand() == C_REQ && _legacy_mode)) {
     // switch the output
-    setStatus(child, message->getInt());
+    setStatus(message.getInt());
   }
-  if (message->getCommand() == C_REQ && ! _legacy_mode) {
-    // just return the current status
-    ((ChildInt*)child)->setValueInt(_status);
+  if (message.getCommand() == C_REQ && ! _legacy_mode) {
+    // return the current status
+    _value_int = _status;
   }
 }
 
+// what to do when receiving a remote message
+void SensorDigitalOutput::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 103: setOnValue(request.getValueInt()); break;
+    case 104: setLegacyMode(request.getValueInt()); break;
+    case 105: setSafeguard(request.getValueInt()); break;
+    case 106: setInputIsElapsed(request.getValueInt()); break;
+    case 107: setWaitAfterSet(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+}
+
 // what to do when receiving an interrupt
 void SensorDigitalOutput::onInterrupt() {
 }
 
 // write the value to the output
-void SensorDigitalOutput::setStatus(Child* child, int value) {
+void SensorDigitalOutput::setStatus(int value) {
   // pre-process the input value
   if (_input_is_elapsed) {
     // the input provided is an elapsed time
@@ -1341,34 +1331,33 @@ void SensorDigitalOutput::setStatus(int value) {
     // if turning the output on and a safeguard timer is configured, start it
     if (value == ON && _safeguard_timer->isConfigured() && ! _safeguard_timer->isRunning()) _safeguard_timer->start();
   }
-  _setStatus(child, value);
+  _setStatus(value);
   // wait if needed for relay drawing a lot of current
   if (_wait_after_set > 0) _node->sleepOrWait(_wait_after_set);
   // store the new status so it will be sent to the controller
   _status = value;
-  ((ChildInt*)child)->setValueInt(value);
+  _value_int = value;
 }
 
 // setup the provided pin for output
-void SensorDigitalOutput::_setupPin(Child* child, int pin) {
+void SensorDigitalOutput::_setupPin(int pin) {
   // set the pin as output and initialize it accordingly
   pinMode(pin, OUTPUT);
   // setup the pin in a off status
   _status = ! _on_value;
   digitalWrite(pin, _status);
   // the initial value is now the current value
-  ((ChildInt*)child)->setValueInt(_status);
+  _value_int = _status;
 }
 
 // switch to the requested status
-void SensorDigitalOutput::_setStatus(Child* child, int value) {
+void SensorDigitalOutput::_setStatus(int value) {
   int value_to_write = _getValueToWrite(value);
   // set the value to the pin
   digitalWrite(_pin, value_to_write);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("DOUT I="));
+    Serial.print(_child_id);
     Serial.print(F(" P="));
     Serial.print(_pin);
     Serial.print(F(" V="));
@@ -1387,18 +1376,16 @@ int SensorDigitalOutput::_getValueToWrite(int value) {
   return value_to_write;
 }
 
+
 /*
    SensorRelay
 */
 
 // contructor
-SensorRelay::SensorRelay(const NodeManager& node_manager, int pin): SensorDigitalOutput(node_manager, pin) {
-  _name = "REL";
-}
-
-// what to do during before
-void SensorRelay::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
+SensorRelay::SensorRelay(NodeManager* node_manager, int child_id, int pin): SensorDigitalOutput(node_manager, child_id, pin) {
+  // set presentation and type
+  setPresentation(S_BINARY);
+  setType(V_STATUS);
 }
 
 /*
@@ -1406,10 +1393,11 @@ SensorRelay::SensorRelay(NodeManager* node_manager, int child_id, int pin): Sens
 */
 
 // contructor
-SensorLatchingRelay::SensorLatchingRelay(const NodeManager& node_manager, int pin): SensorRelay(node_manager, pin) {
-  // set the "off" pin to the provided pin and the "on" pin to the provided pin + 1
-  _pin_on = pin;
-  _pin_off = pin + 1;
+SensorLatchingRelay::SensorLatchingRelay(NodeManager* node_manager, int child_id, int pin): SensorRelay(node_manager, child_id, pin) {
+  // set the "off" pin to the provided pin
+  setPinOff(pin);
+  // set the "on" pin to the provided pin + 1
+  setPinOn(pin + 1);
 }
 
 // setter/getter
@@ -1425,17 +1413,29 @@ void SensorLatchingRelay::setPinOff(int value) {
 
 // what to do during before
 void SensorLatchingRelay::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
+  _setupPin(_pin_on);
+  _setupPin(_pin_off);
 }
 
-// what to do during setup
-void SensorLatchingRelay::onSetup() {
-  _setupPin(children.get(1),_pin_on);
-  _setupPin(children.get(1),_pin_off);
+// what to do when receiving a remote message
+void SensorLatchingRelay::onProcess(Request & request) {
+  int function = request.getFunction();
+  if (function < 200) {
+    // if this is for SensorDigitalOutput call its onProcess()
+    SensorDigitalOutput::onProcess(request);
+    return;
+  }
+  switch(function) {
+    case 201: setPulseWidth(request.getValueInt()); break;
+    case 202: setPinOff(request.getValueInt()); break;
+    case 203: setPinOn(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // switch to the requested status
-void SensorLatchingRelay::_setStatus(Child* child, int value) {
+void SensorLatchingRelay::_setStatus(int value) {
   // select the right pin to send the pulse to
   int pin = value == OFF ? _pin_off : _pin_on;
   // set the value
@@ -1445,7 +1445,7 @@ void SensorLatchingRelay::_setStatus(int value) {
   digitalWrite(pin, ! _on_value);
   #if DEBUG == 1
     Serial.print(F("LAT I="));
-    Serial.print(child->child_id);
+    Serial.print(_child_id);
     Serial.print(F(" P="));
     Serial.print(pin);
     Serial.print(F(" S="));
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -1458,29 +1458,36 @@ void SensorLatchingRelay::_setStatus(Child* child, int value) {
 }
 
 #endif
-
-#if MODULE_DHT == 1
 /*
    SensorDHT
 */
-
+#if MODULE_DHT == 1
 // contructor
-SensorDHT::SensorDHT(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DHT";
-  _dht_type = DHT::DHT11;
+SensorDHT::SensorDHT(NodeManager* node_manager, int child_id, int pin, DHT* dht, int sensor_type, int dht_type): Sensor(node_manager, child_id, pin) {
+  // store the dht object
+  _dht = dht;
+  _sensor_type = sensor_type;
+  _dht_type = dht_type;
+  if (_sensor_type == SensorDHT::TEMPERATURE) {
+    // temperature sensor
+    setPresentation(S_TEMP);
+    setType(V_TEMP);
+    setValueType(TYPE_FLOAT);
+  }
+  else if (_sensor_type == SensorDHT::HUMIDITY) {
+    // humidity sensor
+    setPresentation(S_HUM);
+    setType(V_HUM);
+    setValueType(TYPE_FLOAT);
+  }
 }
 
 // what to do during before
 void SensorDHT::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
 }
 
 // what to do during setup
 void SensorDHT::onSetup() {
-  // store the dht object
-  _dht = new DHT();
   // initialize the dht library
   _dht->setup(_pin,_dht_type);
 }
@@ -1490,66 +1497,46 @@ void SensorDHT::onLoop(Child* child) {
   _node->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
-  if (child->type == V_TEMP) {
+  if (_sensor_type == SensorDHT::TEMPERATURE) {
     // read the temperature
     float temperature = _dht->getTemperature();
     if (! _node->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("DHT I="));
+      Serial.print(_child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+    if (! isnan(temperature)) _value_float = temperature;
   }
   // humidity sensor
-  else if (child->type == V_HUM) {
+  else if (_sensor_type == SensorDHT::HUMIDITY) {
     // read humidity
     float humidity = _dht->getHumidity();
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("DHT I="));
+      Serial.print(_child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
     #endif
     // store the value
-    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+    if (! isnan(humidity)) _value_float = humidity;
   }
 }
 
 // what to do as the main task when receiving a message
-void SensorDHT::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorDHT::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorDHT::onProcess(Request & request) {
 }
 
 // what to do when receiving an interrupt
 void SensorDHT::onInterrupt() {
 }
-
-/*
-   SensorDHT11
-*/
-
-// contructor
-SensorDHT11::SensorDHT11(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
-  _name = "DHT11";
-  _dht_type = DHT::DHT11;
-}
-
-/*
-   SensorDHT11
-*/
-
-// contructor
-SensorDHT22::SensorDHT22(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
-  _name = "DHT22";
-  _dht_type = DHT::DHT22;
-}
 #endif
 
 /*
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -765,7 +765,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #if MODULE_SHT21 == 1
-      if (strcmp(sensor->getName(),"SHT21") == 0 || strcmp(sensor->getName(),"HTU21") == 0) {
+      if (strcmp(sensor->getName(),"SHT21") == 0) {
         SensorSHT21* custom_sensor = (SensorSHT21*)sensor;
         switch(function) {
           default: return;
@@ -830,18 +830,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_SWITCH == 1
-      if (strcmp(sensor->getName(),"SWITCH") == 0 || strcmp(sensor->getName(),"DOOR") == 0 || strcmp(sensor->getName(),"MOTION") == 0) {
-        SensorSwitch* custom_sensor = (SensorSwitch*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setMode(request.getValueInt()); break;
-          case 102: custom_sensor->setDebounce(request.getValueInt()); break;
-          case 103: custom_sensor->setTriggerTime(request.getValueInt()); break;
-          case 104: custom_sensor->setInitial(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1631,13 +1619,14 @@ void SensorSHT21::onReceive(MyMessage* message) {
 // what to do when receiving an interrupt
 void SensorSHT21::onInterrupt() {
 }
+#endif
 
 /*
  * SensorHTU21D
  */
- // constructor
+ #if MODULE_SHT21 == 1
+// constructor
 SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
-  _name = "HTU21";
 }
 #endif 
 
@@ -1645,8 +1634,8 @@ SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
 /*
  * SensorSwitch
  */
-SensorSwitch::SensorSwitch(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "SWITCH";
+SensorSwitch::SensorSwitch(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id,pin) {
+  setType(V_TRIPPED);
 }
 
 // setter/getter
@@ -1665,13 +1654,12 @@ void SensorSwitch::setInitial(int value) {
 
 // what to do during before
 void SensorSwitch::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_TRIPPED);
+  // set the interrupt pin so it will be called only when waking up from that interrupt
+  setInterrupt(_pin,_mode,_initial);
 }
 
 // what to do during setup
 void SensorSwitch::onSetup() {
-  // set the interrupt pin so it will be called only when waking up from that interrupt
-  setInterrupt(_pin,_mode,_initial);
   // report immediately
   _report_timer->unset();
 }
@@ -1681,18 +1669,27 @@ void SensorSwitch::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
-void SensorSwitch::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == V_STATUS) {
-    // return current status
-    ((ChildInt*)child)->setValueInt(digitalRead(_pin));
+void SensorSwitch::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) {
+    _value_int = digitalRead(_pin);
+  }
+}
+
+// what to do when receiving a remote message
+void SensorSwitch::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setMode(request.getValueInt()); break;
+    case 102: setDebounce(request.getValueInt()); break;
+    case 103: setTriggerTime(request.getValueInt()); break;
+    case 104: setInitial(request.getValueInt()); break;
+    default: return;
   }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
 void SensorSwitch::onInterrupt() {
-  Child* child = children.get(1);
   // wait to ensure the the input is not floating
   if (_debounce > 0) _node->sleepOrWait(_debounce);
   // read the value of the pin
@@ -1700,49 +1697,34 @@ void SensorSwitch::onInterrupt() {
   // process the value
   if ( (_mode == RISING && value == HIGH ) || (_mode == FALLING && value == LOW) || (_mode == CHANGE) )  {
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("SWITCH I="));
+      Serial.print(_child_id);
       Serial.print(F(" P="));
       Serial.print(_pin);
       Serial.print(F(" V="));
       Serial.println(value);
     #endif
-    ((ChildInt*)child)->setValueInt(value);
+    _value_int = value;
     // allow the signal to be restored to its normal value
     if (_trigger_time > 0) _node->sleepOrWait(_trigger_time);
   } else {
     // invalid
-    ((ChildInt*)child)->setValueInt(-1);
+    _value_int = -1;
   }
 }
 
 /*
  * SensorDoor
  */
-SensorDoor::SensorDoor(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
-  _name = "DOOR";
-}
-
-// what to do during before
-void SensorDoor::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_DOOR,V_TRIPPED);
+SensorDoor::SensorDoor(NodeManager* node_manager, int child_id, int pin): SensorSwitch(node_manager,child_id,pin) {
+  setPresentation(S_DOOR);
 }
 
 /*
  * SensorMotion
  */
-SensorMotion::SensorMotion(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
-  _name = "MOTION";
-}
-
-// what to do during before
-void SensorMotion::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_MOTION,V_TRIPPED);
-}
-
-// what to do during setup
-void SensorMotion::onSetup() {
+SensorMotion::SensorMotion(NodeManager* node_manager, int child_id, int pin): SensorSwitch(node_manager, child_id,pin) {
+  setPresentation(S_MOTION);
   // set initial value to LOW
   setInitial(LOW);
 }
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -242,10 +242,6 @@ void Child::sendValue() {
 bool Child::isNewValue() {
 }
 
-/*
- ChildInt class
-*/
-
 // ChildInt class
 ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -271,10 +267,6 @@ bool ChildInt::isNewValue() {
   return _last_value != _value;
 }
 
-/*
- ChildFloat class
-*/
-
 // ChildFloat class
 ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -300,18 +292,6 @@ bool ChildFloat::isNewValue() {
   return _last_value != _value;
 }
 
-/*
- ChildDs18b20 class
-*/
-
-ChildDs18b20::ChildDs18b20(Sensor* sensor, int child_id, int presentation, int type, int _index, char* description = ""): ChildFloat(sensor, child_id, presentation, type, description)  {
-  index = index;
-}
-
-/*
- ChildDouble class
-*/
-
 // ChildDouble class
 ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -337,10 +317,6 @@ bool ChildDouble::isNewValue() {
   return _last_value != _value;
 }
 
-/*
- ChildString class
-*/
-
 // ChildString class
 ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -866,16 +842,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_DS18B20 == 1
-      if (strcmp(sensor->getName(),"DS18B20") == 0) {
-        SensorDs18b20* custom_sensor = (SensorDs18b20*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setResolution(request.getValueInt()); break;
-          case 102: custom_sensor->setSleepDuringConversion(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1787,21 +1753,18 @@ void SensorMotion::onSetup() {
 */
 #if MODULE_DS18B20 == 1
 // contructor
-SensorDs18b20::SensorDs18b20(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DS18B20";
+SensorDs18b20::SensorDs18b20(NodeManager* node_manager, int child_id, int pin, DallasTemperature* sensors, int index): Sensor(node_manager,child_id, pin) {
+  setPresentation(S_TEMP);
+  setType(V_TEMP);
+  setValueType(TYPE_FLOAT);
+  _index = index;
+  _sensors = sensors;
+  // retrieve and store the address from the index
+  _sensors->getAddress(_device_address, index);
 }
 
 // what to do during before
 void SensorDs18b20::onBefore() {
-  // initialize the library
-  OneWire* oneWire = new OneWire(_pin);
-  DallasTemperature* _sensors = new DallasTemperature(oneWire);
-  // initialize the sensors
-  _sensors->begin();
-  // register a new child for each sensor on the bus
-  for(int i = 0; i < _sensors->getDeviceCount(); i++) {
-    new ChildDs18b20(this,_node->getAvailableChildId(),S_TEMP,V_TEMP,i);
-  }
 }
 
 // what to do during setup
@@ -1820,39 +1783,52 @@ void SensorDs18b20::onLoop(Child* child) {
     sleep(conversion_time);
   }
   // read the temperature
-  float temperature = _sensors->getTempCByIndex(((ChildDs18b20*)child)->index);
+  float temperature = _sensors->getTempCByIndex(_index);
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("DS18B20 I="));
+    Serial.print(_child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  _value_float = temperature;
 }
 
 // what to do as the main task when receiving a message
-void SensorDs18b20::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorDs18b20::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorDs18b20::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setResolution(request.getValueInt()); break;
+    case 102: setSleepDuringConversion(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
 void SensorDs18b20::onInterrupt() {
 }
 
+// function to print a device address
+DeviceAddress* SensorDs18b20::getDeviceAddress() {
+  return &_device_address;
+}
+
 // returns the sensor's resolution in bits
 int SensorDs18b20::getResolution() {
-  return _sensors->getResolution();
+  return _sensors->getResolution(_device_address);
 }
 
 // set the sensor's resolution in bits
 void SensorDs18b20::setResolution(int value) {
-  _sensors->setResolution(value);
+   _sensors->setResolution(_device_address, value);
 }
 
 // sleep while DS18B20 calculates temperature
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -876,15 +876,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_BH1750 == 1
-      if (strcmp(sensor->getName(),"BH1750") == 0) {
-        SensorBH1750* custom_sensor = (SensorBH1750*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setMode(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1876,46 +1867,53 @@ void SensorDs18b20::setSleepDuringConversion(bool value) {
 */
 #if MODULE_BH1750 == 1
 // contructor
-SensorBH1750::SensorBH1750(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "BH1750";
+SensorBH1750::SensorBH1750(NodeManager* node_manager, int child_id): Sensor(node_manager,child_id,A4) {
+  setPresentation(S_LIGHT_LEVEL);
+  setType(V_LEVEL);
+  _lightSensor = new BH1750();
 }
-// setter/getter
+
 void SensorBH1750::setMode(uint8_t mode) {
   _lightSensor->configure(mode);
 }
 
 // what to do during before
 void SensorBH1750::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
+  _lightSensor->begin();
 }
 
 // what to do during setup
 void SensorBH1750::onSetup() {
-  _lightSensor = new BH1750();
-  _lightSensor->begin();
 }
 
 // what to do during loop
 void SensorBH1750::onLoop(Child* child) {
   // request the light level
-  int value = _lightSensor->readLightLevel();
+  _value_int = _lightSensor->readLightLevel();
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("BH1 I="));
+    Serial.print(_child_id);
     Serial.print(F(" L="));
-    Serial.println(value);
+    Serial.println(_value_int);
   #endif
-  ((ChildInt*)child)->setValueInt(value);
 }
 
 // what to do as the main task when receiving a message
-void SensorBH1750::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorBH1750::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorBH1750::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setMode(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
+
 // what to do when receiving an interrupt
 void SensorBH1750::onInterrupt() {
 }
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -1926,44 +1926,46 @@ void SensorBH1750::onInterrupt() {
 */
 #if MODULE_MLX90614 == 1
 // contructor
-SensorMLX90614::SensorMLX90614(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "MLX90614";
+SensorMLX90614::SensorMLX90614(NodeManager* node_manager, int child_id, Adafruit_MLX90614* mlx, int sensor_type): Sensor(node_manager,child_id,A4) {
+  _sensor_type = sensor_type;
+  _mlx = mlx;
+  // set presentation and type
+  setPresentation(S_TEMP);
+  setType(V_TEMP);
+  setValueType(TYPE_FLOAT);
 }
 
 // what to do during before
 void SensorMLX90614::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  // initialize the library
+  _mlx->begin();
 }
 
 // what to do during setup
 void SensorMLX90614::onSetup() {
-  // initialize the library
-  _mlx->begin();
 }
 
 // what to do during loop
 void SensorMLX90614::onLoop(Child* child) {
-  float temperature;
-  // the first child is the ambient temperature, the second the object temperature
-  if (children.get(1) == child) temperature = _mlx->readAmbientTempC();
-  else temperature = _mlx->readObjectTempC();
+  float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("MLX I="));
-    Serial.print(child->child_id);
+    Serial.print(_child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  if (! isnan(temperature)) _value_float = temperature;
 }
 
 // what to do as the main task when receiving a message
-void SensorMLX90614::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorMLX90614::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorMLX90614::onProcess(Request & request) {
 }
 
 // what to do when receiving an interrupt
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -1809,7 +1817,7 @@ void SensorDs18b20::onBefore() {
   _sensors->begin();
   // register a new child for each sensor on the bus
   for(int i = 0; i < _sensors->getDeviceCount(); i++) {
-    new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+    new ChildDs18b20(this,_node->getAvailableChildId(),S_TEMP,V_TEMP,i);
   }
 }
 
@@ -1819,11 +1827,6 @@ void SensorDs18b20::onSetup() {
 
 // what to do during loop
 void SensorDs18b20::onLoop(Child* child) {
-  int index = -1;
-  // get the index of the requested child
-  for (int i = 1; i <= children.size(); i++) {
-    if (children.get(i) == child) index = i-1;
-  }
   // do not wait for conversion, will sleep manually during it
   if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
   // request the temperature
@@ -1834,7 +1837,7 @@ void SensorDs18b20::onLoop(Child* child) {
     sleep(conversion_time);
   }
   // read the temperature
-  float temperature = _sensors->getTempCByIndex(index);
+  float temperature = _sensors->getTempCByIndex(((ChildDs18b20*)child)->index);
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
@@ -1982,8 +1985,32 @@ void SensorMLX90614::onInterrupt() {
 */
 #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
 // contructor
-SensorBosch::SensorBosch(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "BOSH";
+SensorBosch::SensorBosch(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager, child_id,A4) {
+  _sensor_type = sensor_type;
+  if (_sensor_type == SensorBosch::TEMPERATURE) {
+    // temperature sensor
+    setPresentation(S_TEMP);
+    setType(V_TEMP);
+    setValueType(TYPE_FLOAT);
+  }
+  else if (_sensor_type == SensorBosch::HUMIDITY) {
+    // humidity sensor
+    setPresentation(S_HUM);
+    setType(V_HUM);
+    setValueType(TYPE_FLOAT);
+  }
+  else if (_sensor_type == SensorBosch::PRESSURE) {
+    // pressure sensor
+    setPresentation(S_BARO);
+    setType(V_PRESSURE);
+    setValueType(TYPE_FLOAT);
+  }
+  else if (_sensor_type == SensorBosch::FORECAST) {
+    // pressure sensor
+    setPresentation(S_BARO);
+    setType(V_FORECAST);
+    setValueType(TYPE_STRING);
+  }
 }
 
 // setter/getter
@@ -1993,17 +2020,12 @@ void SensorBosch::setForecastSamplesCount(int value) {
 
 // what to do during before
 void SensorBosch::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
+  // initialize the forecast samples array
+  _forecast_samples = new float[_forecast_samples_count];
 }
 
 // what to do during setup
 void SensorBosch::onSetup() {
-  // initialize the forecast samples array
-  _forecast_samples = new float[_forecast_samples_count];
 }
 
 // what to do during loop
@@ -2011,10 +2033,18 @@ void SensorBosch::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
-void SensorBosch::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorBosch::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorBosch::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setForecastSamplesCount(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2022,7 +2052,7 @@ void SensorBosch::onInterrupt() {
 }
 
 // calculate and send the forecast back
-char* SensorBosch::_forecast(float pressure) {
+void SensorBosch::_forecast(float pressure) {
   if (isnan(pressure)) return;
   // Calculate the average of the last n minutes.
   int index = _minute_count % _forecast_samples_count;
@@ -2085,16 +2115,17 @@ void SensorBosch::_forecast(float pressure) {
   else if ((_dP_dt > 0.05) && (_dP_dt < 0.25)) forecast = 1;
   else if ((_dP_dt >(-0.05)) && (_dP_dt < 0.05)) forecast = 0;
   else forecast = 5;
+  _value_string = _weather[forecast];
   #if DEBUG == 1
-    Serial.print(_name);
+    Serial.print(F("BMP I="));
+    Serial.print(_child_id);
     Serial.print(F(" M="));
     Serial.print(_minute_count);
     Serial.print(F(" dP="));
     Serial.print(_dP_dt);
     Serial.print(F(" F="));
-    Serial.println(_weather[forecast]);
+    Serial.println(_value_string);
   #endif
-  return _weather[forecast];
 }
 
 // returns the average of the latest pressure samples
@@ -2133,57 +2164,58 @@ uint8_t SensorBosch::GetI2CAddress(uint8_t chip_id) {
  * SensorBME280
  */
 #if MODULE_BME280 == 1
-SensorBME280::SensorBME280(const NodeManager& node_manager): SensorBosch(node_manager) {
-  _name = "BME280";
+SensorBME280::SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME280* bme, int sensor_type): SensorBosch(node_manager, child_id,sensor_type) {
+  _bme = bme;
 }
 
 void SensorBME280::onLoop(Child* child) {
   // temperature sensor
-  if (child->type == V_TEMP) {
+  if (_sensor_type == SensorBME280::TEMPERATURE) {
     // read the temperature
     float temperature = _bme->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("BME I="));
+      Serial.print(_child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
+    if (isnan(temperature)) return;
     // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+    _value_float = temperature;
   }
   // Humidity Sensor
-  else if (child->type == V_HUM) {
+  else if (_sensor_type == SensorBME280::HUMIDITY) {
     // read humidity
     float humidity = _bme->readHumidity();
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("BME I="));
+      Serial.print(_child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
     #endif
+    if (isnan(humidity)) return;
     // store the value
-    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+    _value_float = humidity;
   }
   // Pressure Sensor
-  else if (child->type == V_PRESSURE) {
+  else if (_sensor_type == SensorBME280::PRESSURE) {
     // read pressure
     float pressure = _bme->readPressure() / 100.0F;
+    if (isnan(pressure)) return;
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("BME I="));
+      Serial.print(_child_id);
       Serial.print(F(" P="));
       Serial.println(pressure);
     #endif
+    if (isnan(pressure)) return;
     // store the value
-    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
+    _value_float = pressure;
   }
   // Forecast Sensor
-  else if (child->type == V_FORECAST) {
+  else if (_sensor_type == SensorBME280::FORECAST) {
     float pressure = _bme->readPressure() / 100.0F;
     _forecast(pressure);
   }
@@ -2234,7 +2266,7 @@ void SensorBMP085::onLoop(Child* child) {
   // Forecast Sensor
   else if (_sensor_type == SensorBMP085::FORECAST) {
     float pressure = _bmp->readPressure() / 100.0F;
-    ((ChildString*)child)->setValueString(_forecast(pressure));
+    _forecast(pressure);    
   }
 }
 #endif
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -877,16 +877,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
-      if (strcmp(sensor->getName(),"BME280") == 0) {
-        SensorBosch* custom_sensor = (SensorBosch*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setForecastSamplesCount(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1995,6 +1985,11 @@ void SensorBosch::setForecastSamplesCount(int value) {
 
 // what to do during before
 void SensorBosch::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
 // what to do during setup
@@ -2134,20 +2129,11 @@ SensorBME280::SensorBME280(const NodeManager& node_manager): SensorBosch(node_ma
   _name = "BME280";
 }
 
-// what to do during before
-void SensorBME280::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
-}
-
 void SensorBME280::onLoop(Child* child) {
   // temperature sensor
   if (child->type == V_TEMP) {
     // read the temperature
-    float temperature = _bm->readTemperature();
+    float temperature = _bme->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
@@ -2163,7 +2149,7 @@ void SensorBME280::onLoop(Child* child) {
   // Humidity Sensor
   else if (child->type == V_HUM) {
     // read humidity
-    float humidity = _bm->readHumidity();
+    float humidity = _bme->readHumidity();
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -2177,7 +2163,7 @@ void SensorBME280::onLoop(Child* child) {
   // Pressure Sensor
   else if (child->type == V_PRESSURE) {
     // read pressure
-    float pressure = _bm->readPressure() / 100.0F;
+    float pressure = _bme->readPressure() / 100.0F;
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -2190,7 +2176,7 @@ void SensorBME280::onLoop(Child* child) {
   }
   // Forecast Sensor
   else if (child->type == V_FORECAST) {
-    float pressure = _bm->readPressure() / 100.0F;
+    float pressure = _bme->readPressure() / 100.0F;
     _forecast(pressure);
   }
 }
@@ -2201,54 +2187,46 @@ void SensorBME280::onLoop(Child* child) {
 */
 #if MODULE_BMP085 == 1
 // contructor
-SensorBMP085::SensorBMP085(const NodeManager& node_manager): SensorBosch(node_manager) {
-  _name = "BMP085";
-}
-
-// what to do during before
-void SensorBMP085::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
+SensorBMP085::SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP085* bmp, int sensor_type): SensorBosch(node_manager, child_id,sensor_type) {
+  _bmp = bmp;
 }
 
 // what to do during loop
 void SensorBMP085::onLoop(Child* child) {
   // temperature sensor
-  if (child->type == V_TEMP) {
+  if (_sensor_type == SensorBMP085::TEMPERATURE) {
     // read the temperature
-    float temperature = _bm->readTemperature();
+    float temperature = _bmp->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("BMP I="));
+      Serial.print(_child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
+    if (isnan(temperature)) return;
     // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+    _value_float = temperature;
   }
   // Pressure Sensor
-  else if (child->type == V_PRESSURE) {
+  else if (_sensor_type == SensorBMP085::PRESSURE) {
     // read pressure
-    float pressure = _bm->readPressure() / 100.0F;
+    float pressure = _bmp->readPressure() / 100.0F;
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("BMP I="));
+      Serial.print(_child_id);
       Serial.print(F(" P="));
       Serial.println(pressure);
     #endif
+    if (isnan(pressure)) return;
     // store the value
-    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
+    _value_float = pressure;
   }
   // Forecast Sensor
-  else if (child->type == V_FORECAST) {
-    float pressure = _bm->readPressure() / 100.0F;
-    _forecast(pressure);
+  else if (_sensor_type == SensorBMP085::FORECAST) {
+    float pressure = _bmp->readPressure() / 100.0F;
+    ((ChildString*)child)->setValueString(_forecast(pressure));
   }
 }
 #endif
@@ -2257,52 +2235,45 @@ void SensorBMP085::onLoop(Child* child) {
  * SensorBMP280
  */
 #if MODULE_BMP280 == 1
-SensorBMP280::SensorBMP280(const NodeManager& node_manager): SensorBosch(node_manager) {
-  _name = "BMP280";
-}
-
-  // what to do during before
-void SensorBMP280::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
+SensorBMP280::SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP280* bmp, int sensor_type): SensorBosch(node_manager, child_id,sensor_type) {
+  _bmp = bmp;
 }
 
 void SensorBMP280::onLoop(Child* child) {
   // temperature sensor
-  if (child->type == V_TEMP) {
+  if (_sensor_type == SensorBMP280::TEMPERATURE) {
     // read the temperature
-    float temperature = _bm->readTemperature();
+    float temperature = _bmp->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("BMP I="));
+      Serial.print(_child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
+    if (isnan(temperature)) return;
     // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+    _value_float = temperature;
   }
   // Pressure Sensor
-  else if (child->type == V_PRESSURE) {
+  else if (_sensor_type == SensorBMP280::PRESSURE) {
     // read pressure
-    float pressure = _bm->readPressure() / 100.0F;
+    float pressure = _bmp->readPressure() / 100.0F;
+    if (isnan(pressure)) return;
     #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("BMP I="));
+      Serial.print(_child_id);
       Serial.print(F(" P="));
       Serial.println(pressure);
     #endif
+    if (isnan(pressure)) return;
     // store the value
-    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
+    _value_float = pressure;
   }
   // Forecast Sensor
-  else if (child->type == V_FORECAST) {
-    float pressure = _bm->readPressure() / 100.0F;
+  else if (_sensor_type == SensorBMP280::FORECAST) {
+    float pressure = _bmp->readPressure() / 100.0F;
     _forecast(pressure);
   }
 }
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -2381,9 +2381,10 @@ void SensorHCSR04::onInterrupt() {
 */
 #if MODULE_SONOFF == 1
 // contructor
-SensorSonoff::SensorSonoff(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "SONOFF";
-} 
+SensorSonoff::SensorSonoff(NodeManager* node_manager, int child_id): Sensor(node_manager, child_id,1) {
+  setPresentation(S_BINARY);
+  setType(V_STATUS);
+}
 
 // setter/getter
 void SensorSonoff::setButtonPin(int value) {
@@ -2398,8 +2399,6 @@ void SensorSonoff::setLedPin(int value) {
 
 // what to do during before
 void SensorSonoff::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
 }
 
 // what to do during setup
@@ -2425,34 +2424,44 @@ void SensorSonoff::onLoop(Child* child) {
   int value = _debouncer.read();
   if (value != _old_value && value == 0) {
     // button pressed, toggle the state
-    _toggle(child);
+    _toggle();
   }
   _old_value = value;
 }
 
 // what to do as the main task when receiving a message
-void SensorSonoff::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_SET) {
+void SensorSonoff::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_SET) {
     // retrieve from the message the value to set
-    int value = message->getInt();
+    int value = message.getInt();
     if (value != 0 && value != 1 || value == _state) return;
     // toggle the state
-    _toggle(child);
+    _toggle();
   }
-  if (message->getCommand() == C_REQ) {
+  if (message.getCommand() == C_REQ) {
     // return the current state
-    ((ChildInt*)child)->setValueInt(_state);
+    _value_int = _state;
   }
 }
 
+// what to do when receiving a remote message
+void SensorSonoff::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setButtonPin(request.getValueInt()); break;
+    case 102: setRelayPin(request.getValueInt()); break;
+    case 103: setLedPin(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+}
+
 // what to do when receiving an interrupt
 void SensorSonoff::onInterrupt() {
 }
 
 // toggle the state
-void SensorSonoff::_toggle(Child* child) {
+void SensorSonoff::_toggle() {
   // toggle the state
   _state = _state ? false : true;
   // Change relay state
@@ -2460,13 +2469,12 @@ void SensorSonoff::_toggle() {
   // Change LED state
   digitalWrite(_led_pin, _state? _led_on: _led_off);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("SONOFF I="));
+    Serial.print(_child_id);
     Serial.print(F(" V="));
     Serial.println(_state);
   #endif
-  ((ChildInt*)child)->setValueInt(_state);
+  _value_int = _state;
 }
 
 // blink the led
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -886,28 +886,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_SONOFF == 1
-      if (strcmp(sensor->getName(),"SONOFF") == 0) {
-        SensorSonoff* custom_sensor = (SensorSonoff*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setButtonPin(request.getValueInt()); break;
-          case 102: custom_sensor->setRelayPin(request.getValueInt()); break;
-          case 103: custom_sensor->setLedPin(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_HCSR04 == 1
-      if (strcmp(sensor->getName(),"HCSR04") == 0) {
-        SensorHCSR04* custom_sensor = (SensorHCSR04*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setTriggerPin(request.getValueInt()); break;
-          case 102: custom_sensor->setEchoPin(request.getValueInt()); break;
-          case 103: custom_sensor->setMaxDistance(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
       
     }
   }
@@ -2503,64 +2549,6 @@ void SensorSonoff::_blink() {
 }
 #endif
 
-/*
-   SensorHCSR04
-*/
-#if MODULE_HCSR04 == 1
-// contructor
-SensorHCSR04::SensorHCSR04(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "HCSR04";
-  _trigger_pin = pin;
-  _echo_pin = pin;
-}
-
-// setter/getter
-void SensorHCSR04::setTriggerPin(int value) {
-  _trigger_pin = value;
-}
-void SensorHCSR04::setEchoPin(int value) {
-  _echo_pin = value;
-}
-void SensorHCSR04::setMaxDistance(int value) {
-  _max_distance = value;
-}
-
-// what to do during before
-void SensorHCSR04::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_DISTANCE,V_DISTANCE);
-}
-
-// what to do during setup
-void SensorHCSR04::onSetup() {
-  // initialize the library
-  _sonar = new NewPing(_trigger_pin,_echo_pin,_max_distance);
-}
-
-// what to do during loop
-void SensorHCSR04::onLoop(Child* child) {
-  int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" D="));
-    Serial.println(distance);
-  #endif
-  ((ChildInt*)child)->setValueInt(distance);
-}
-
-// what to do as the main task when receiving a message
-void SensorHCSR04::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorHCSR04::onInterrupt() {
-}
-#endif
 
 /*
    SensorMCP9808
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -1968,7 +1968,6 @@ void SensorMLX90614::onBefore() {
 // what to do during setup
 void SensorMLX90614::onSetup() {
   // initialize the library
-  _mlx = new Adafruit_MLX90614();
   _mlx->begin();
 }
 
@@ -2500,18 +2499,19 @@ void SensorHCSR04::onInterrupt() {
 */
 #if MODULE_MCP9808 == 1
 // contructor
-SensorMCP9808::SensorMCP9808(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "MCP9808";
+SensorMCP9808::SensorMCP9808(NodeManager* node_manager, int child_id, Adafruit_MCP9808* mcp): Sensor(node_manager, child_id,A2) {
+  _mcp = mcp;
+  setPresentation(S_TEMP);
+  setType(V_TEMP);
+  setValueType(TYPE_FLOAT);
 }
 
 // what to do during before
 void SensorMCP9808::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
 }
 
 // what to do during setup
 void SensorMCP9808::onSetup() {
-  _mcp = new Adafruit_MCP9808();
 }
 
 // what to do during loop
@@ -2520,21 +2520,22 @@ void SensorMCP9808::onLoop(Child* child) {
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("MCP I="));
+    Serial.print(_child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  if (! isnan(temperature)) _value_float = temperature;
 }
 
 // what to do as the main task when receiving a message
-void SensorMCP9808::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorMCP9808::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorMCP9808::onProcess(Request & request) {
 }
 
 // what to do when receiving an interrupt
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -908,22 +908,6 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_MQ == 1
-      if (strcmp(sensor->getName(),"MQ") == 0) {
-        SensorMQ* custom_sensor = (SensorMQ*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setTargetGas(request.getValueInt()); break;
-          case 102: custom_sensor->setRlValue(request.getValueFloat()); break;
-          case 103: custom_sensor->setRoValue(request.getValueFloat()); break;
-          case 104: custom_sensor->setCleanAirFactor(request.getValueFloat()); break;
-          case 105: custom_sensor->setCalibrationSampleTimes(request.getValueInt()); break;
-          case 106: custom_sensor->setCalibrationSampleInterval(request.getValueInt()); break;
-          case 107: custom_sensor->setReadSampleTimes(request.getValueInt()); break;
-          case 108: custom_sensor->setReadSampleInterval(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
       
     }
   }
@@ -2568,8 +2552,9 @@ static float SensorMQ::_default_LPGCurve[3] = {2.3,0.21,-0.47};
 static float SensorMQ::_default_COCurve[3] = {2.3,0.72,-0.34};
 static float SensorMQ::_default_SmokeCurve[3] = {2.3,0.53,-0.44};
 
-SensorMQ::SensorMQ(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "MQ";
+SensorMQ::SensorMQ(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id,pin) {
+  setPresentation(S_AIR_QUALITY);
+  setType(V_LEVEL);
   _LPGCurve = SensorMQ::_default_LPGCurve;
   _COCurve = SensorMQ::_default_COCurve;
   _SmokeCurve = SensorMQ::_default_SmokeCurve;
@@ -2614,8 +2599,6 @@ void SensorMQ::setSmokeCurve(float *value) {
 void SensorMQ::onBefore() {
   // prepare the pin for input
   pinMode(_pin, INPUT);
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
 }
 
 // what to do during setup
@@ -2637,9 +2620,8 @@ void SensorMQ::onLoop(Child* child) {
   if (_target_gas == _gas_co) value = co;
   if (_target_gas == _gas_smoke) value = smoke;
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("MQ I="));
+    Serial.print(_child_id);
     Serial.print(F(" V="));
     Serial.print(value);
     Serial.print(F(" LPG="));
@@ -2650,14 +2632,29 @@ void SensorMQ::onLoop(Child* child) {
     Serial.println(smoke);
   #endif
   // store the value
-  ((ChildInt*)child)->setValueInt((int16_t)ceil(value));
+  _value_int = (int16_t)ceil(value);
 }
 
 // what to do as the main task when receiving a message
-void SensorMQ::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorMQ::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorMQ::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 1: setTargetGas(request.getValueInt()); break;
+    case 2: setRlValue(request.getValueFloat()); break;
+    case 3: setRoValue(request.getValueFloat()); break;
+    case 4: setCleanAirFactor(request.getValueFloat()); break;
+    case 5: setCalibrationSampleTimes(request.getValueInt()); break;
+    case 6: setCalibrationSampleInterval(request.getValueInt()); break;
+    case 7: setReadSampleTimes(request.getValueInt()); break;
+    case 8: setReadSampleInterval(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -2723,16 +2723,21 @@ int SensorMQ::_MQGetPercentage(float rs_ro_ratio, float *pcurve) {
 */
 #if MODULE_MHZ19 == 1
 // contructor
-SensorMHZ19::SensorMHZ19(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "MHZ19";
-  _rx_pin = pin;
-  _tx_pin = pin+1;
+SensorMHZ19::SensorMHZ19(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
+  // set presentation, type and value type
+  setPresentation(S_AIR_QUALITY);
+  setType(V_LEVEL);
+  setRxTx(pin, pin+1);
+}
+
+void SensorMHZ19::setRxTx(int rxpin, int txpin) {
+  _rx_pin = rxpin;
+  _tx_pin = txpin;
 }
 
+
 // what to do during before
 void SensorMHZ19::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
 }
 
 // what to do during setup
@@ -2740,46 +2745,36 @@ void SensorMHZ19::onSetup() {
   _ser = new SoftwareSerial(_rx_pin, _tx_pin);
   _ser->begin(9600);
   delay(2000);
-  // clear CO2 buffer
-  while (_ser->read()!=-1) {};  
+  while (_ser->read()!=-1) {};  // clear CO2 buffer.
 }
 
 // what to do during loop
 void SensorMHZ19::onLoop(Child* child) {
   // Read the ppm value
-  int co2ppm = _readCO2(); 
+  int co2ppm = readCO2(); // This is there the function gets called that talks to the Co2 sensor.
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("CO2 I="));
+    Serial.print(_child_id);
     Serial.print(F(" ppm="));
     Serial.println(co2ppm);
   #endif
   // store the value
-  ((ChildInt*)child)->setValueInt(co2ppm);
-}
-
-
-// what to do as the main task when receiving a message
-void SensorMHZ19::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorMHZ19::onInterrupt() {
+  _value_int = co2ppm;
 }
 
 // Read out the CO2 data
-int SensorMHZ19::_readCO2() {
+int SensorMHZ19::readCO2() {
   while (_ser->read() != -1) {};  //clear serial buffer
+
   unsigned char response[9]; // for answer
   byte cmd[9] = {0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79};
+
   // Command to ask for data.
   _ser->write(cmd, 9); //request PPM CO2
+
   // Then for 1 second listen for 9 bytes of data.
   _ser->readBytes(response, 9);
+
   #if DEBUG == 1
   for (int i=0; i<9; i++) {
     Serial.print(response[i], HEX);
@@ -2787,20 +2782,43 @@ int SensorMHZ19::readCO2() {
   }
   Serial.println(F("END"));
   #endif
+
   if (response[0] != 0xFF) {
-    Serial.println(F("ERR byte"));
+    Serial.println(F("Wrong starting byte from co2 sensor! (should be FF)"));
     return -1;
   }
+
   if (response[1] != 0x86) {
-    Serial.println(F("ERR command"));
+    Serial.println(F("Wrong command from co2 sensor! (should be 86)"));
     return -1;
   }
+
   int responseHigh = (int) response[2];
   int responseLow = (int) response[3];
   int ppm = (256 * responseHigh) + responseLow;
+  
   return ppm;
 }
 
+
+// what to do as the main task when receiving a message
+void SensorMHZ19::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorMHZ19::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+}
+
+// what to do when receiving an interrupt
+void SensorMHZ19::onInterrupt() {
+}
+
 #endif
 
 /*
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -257,11 +257,6 @@ void ChildInt::setValueInt(int value) {
   _value = (int) (_total / _samples);
 }
 
-// return the value
-int ChildInt::getValueInt() {
-  return _value;
-}
-
 // send the value back to the controller
 void ChildInt::sendValue() {
   if (_samples == 0) return;
@@ -291,11 +286,6 @@ void ChildFloat::setValueFloat(float value) {
   _value = _total / _samples;
 }
 
-// return the value
-float ChildFloat::getValueFloat() {
-  return _value;
-}
-
 // send the value back to the controller
 void ChildFloat::sendValue() {
   if (_samples == 0) return;
@@ -325,11 +315,6 @@ void ChildDouble::setValueDouble(double value) {
   _value = _total / _samples;
 }
 
-// return the value
-double ChildDouble::getValueDouble() {
-  return _value;
-}
-
 // send the value back to the controller
 void ChildDouble::sendValue() {
   if (_samples == 0) return;
@@ -357,11 +342,6 @@ void ChildString::setValueString(char* value) {
   _value = value;
 }
 
-// return the value
-char* ChildString::getValueString() {
-  return _value;
-}
-
 // send the value back to the controller
 void ChildString::sendValue() {
   _sensor->_node->sendMessage(child_id,type,_value);
@@ -944,18 +924,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      #if MODULE_TSL2561 == 1
-      if (strcmp(sensor->getName(),"TSL2561") == 0) {
-        SensorTSL2561* custom_sensor = (SensorTSL2561*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setGain(request.getValueInt()); break;
-          case 102: custom_sensor->setTiming(request.getValueInt()); break;
-          case 103: custom_sensor->setSpectrum(request.getValueInt()); break;
-          case 104: custom_sensor->setAddress(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif      
+      
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -2839,61 +2808,76 @@ int SensorMHZ19::_readCO2() {
 */
 #if MODULE_AM2320 == 1
 // constructor
-SensorAM2320::SensorAM2320(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "AM2320";
+SensorAM2320::SensorAM2320(NodeManager* node_manager, int child_id, AM2320* th, int sensor_type): Sensor(node_manager, child_id,A2) {
+  _th = th;
+  _sensor_type = sensor_type;
+  if (_sensor_type == SensorAM2320::TEMPERATURE) {
+    // temperature sensor
+    setPresentation(S_TEMP);
+    setType(V_TEMP);
+    setValueType(TYPE_FLOAT);
+  }
+  else if (_sensor_type == SensorAM2320::HUMIDITY) {
+    // humidity sensor
+    setPresentation(S_HUM);
+    setType(V_HUM);
+    setValueType(TYPE_FLOAT);
+  }
 }
 
 // what do to during before
 void SensorAM2320::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+
 }
 
 // what do to during setup
 void SensorAM2320::onSetup() {
-  _th = new AM2320();
 }
 
 // what do to during loop
 void SensorAM2320::onLoop(Child* child) {
-  // read data from the sensor
-  int status = _th->Read();
-  if (status != 0) return;
-  // temperature sensor
-  if (child->type == V_TEMP) {
-    float temperature = _th->t;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-  }
-  // Humidity Sensor
-  else if (child->type == V_HUM) {
-    // read humidity
-    float humidity = _th->h;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(humidity);
-    #endif
-    // store the value
-    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
-  }
+  switch(_th->Read()) {
+    case 0:
+      // temperature sensor
+      if (_sensor_type == SensorAM2320::TEMPERATURE) {
+        // read the temperature
+        float temperature = _th->t;
+        #if DEBUG == 1
+          Serial.print(F("AM2320 I="));
+          Serial.print(_child_id);
+          Serial.print(F(" T="));
+          Serial.println(temperature);
+        #endif
+        // store the value
+        _value_float = temperature;
+      }
+      // humidity sensor
+      else if (_sensor_type == SensorAM2320::HUMIDITY) {
+        // read humidity
+        float humidity = _th->h;
+        if (isnan(humidity)) return;
+          #if DEBUG == 1
+            Serial.print(F("AM2320 I="));
+            Serial.print(_child_id);
+            Serial.print(F(" H="));
+            Serial.println(humidity);
+          #endif
+          // store the value
+          _value_float = humidity;
+        }
+        break;
+      case 1: Serial.println(F("AM2320 offline")); break;
+      case 2: Serial.println(F("AM2320 CRC failed")); break;
+    }
 }
 
 // what do to as the main task when receiving a message
-void SensorAM2320::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorAM2320::onReceive(const MyMessage & message) {
+  onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorAM2320::onProcess(Request & request) {
 }
 
 // what to do when receiving an interrupt
@@ -2906,8 +2890,9 @@ void SensorAM2320::onInterrupt() {
 */
 #if MODULE_TSL2561 == 1
 // contructor
-SensorTSL2561::SensorTSL2561(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "TSL2561";
+SensorTSL2561::SensorTSL2561(NodeManager* node_manager, int child_id): Sensor(node_manager, child_id,A2) {
+  setPresentation(S_LIGHT_LEVEL);
+  setType(V_LEVEL);
 }
 
 // setter/getter
@@ -2926,12 +2911,6 @@ void SensorTSL2561::setAddress(int value) {
 
 // what do to during before
 void SensorTSL2561::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
-}
-
-// what do to during setup
-void SensorTSL2561::onSetup() {
    switch (_tsl_address) {
     case SensorTSL2561::ADDR_FLOAT:
       _tsl = new TSL2561(TSL2561_ADDR_FLOAT);
@@ -2943,7 +2922,11 @@ void SensorTSL2561::onBefore() {
       _tsl = new TSL2561(TSL2561_ADDR_HIGH);
       break;   
   }
-  if (_tsl->begin()) {
+}
+
+// what do to during setup
+void SensorTSL2561::onSetup() {
+   if (_tsl->begin()) {
     switch (_tsl_gain) {
       case SensorTSL2561::GAIN_0X:
         _tsl->setGain(TSL2561_GAIN_0X);
@@ -2965,9 +2948,7 @@ void SensorTSL2561::onSetup() {
     }
   }
   else {
-    #if DEBUG == 1
-      Serial.println(F("ERROR"));
-    #endif
+    Serial.println(F("TSL2561 offline"));
   } 
 }
 
@@ -2976,13 +2957,13 @@ void SensorTSL2561::onLoop(Child* child) {
   // request the light level
    switch (_tsl_spectrum) {
     case SensorTSL2561::VISIBLE:
-      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_VISIBLE));
+      _value_int = _tsl->getLuminosity(TSL2561_VISIBLE); 
       break; 
     case SensorTSL2561::FULLSPECTRUM:
-      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_FULLSPECTRUM));
+      _value_int = _tsl->getLuminosity(TSL2561_FULLSPECTRUM); 
       break; 
     case SensorTSL2561::INFRARED:
-      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_INFRARED));
+      _value_int = _tsl->getLuminosity(TSL2561_INFRARED); 
       break; 
     case SensorTSL2561::FULL:
       // request the full light level
@@ -2990,38 +2971,47 @@ void SensorTSL2561::onLoop(Child* child) {
       uint16_t ir, full;
       ir = lum >> 16;
       full = lum & 0xFFFF;
-      ((ChildInt*)child)->setValueInt(_tsl->calculateLux(full, ir));
-      #if DEBUG == 1
-        Serial.print(_name);
-        Serial.print(F(" I="));
-        Serial.print(child->child_id);
-        Serial.print(F(" LUX="));
-        Serial.print(((ChildInt*)child)->getValueInt());
-        Serial.print(F(" IR="));
-        Serial.print(ir);
-        Serial.print(F(" FULL="));
-        Serial.print(full);
-        Serial.print(F(" VIS="));
-        Serial.println(full-ir);
-      #endif
+      _value_int = _tsl->calculateLux(full, ir);
+  #if DEBUG == 1
+      Serial.print(F("TSL I="));
+      Serial.print(_child_id);
+      Serial.print(F(" LUX="));
+      Serial.print(_value_int);
+      Serial.print(F(" IR="));
+      Serial.print(ir);
+      Serial.print(F(" FULL="));
+      Serial.print(full);
+      Serial.print(F(" VIS="));
+      Serial.println(full-ir);
+   #endif
       break; 
   }
   #if DEBUG == 1
     if (_tsl_spectrum < 3) {
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
+      Serial.print(F("TSL I="));
+      Serial.print(_child_id);
       Serial.print(F(" L="));
-      Serial.println(((ChildInt*)child)->getValueInt());
+      Serial.println(_value_int);
     }
   #endif
 }
 
 // what do to as the main task when receiving a message
-void SensorTSL2561::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorTSL2561::onReceive(const MyMessage & message) {
+  onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorTSL2561::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setGain(request.getValueInt()); break;
+    case 102: setTiming(request.getValueInt()); break;
+    case 103: setSpectrum(request.getValueInt()); break;
+    case 104: setAddress(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -955,16 +955,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
           default: return;
         }
       }
-      #endif
-      #if MODULE_PT100 == 1
-      if (strcmp(sensor->getName(),"PT100") == 0) {
-        SensorPT100* custom_sensor = (SensorPT100*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setVoltageRef(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      #endif
+      #endif      
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -3043,8 +3034,11 @@ void SensorTSL2561::onInterrupt() {
 */
 #if MODULE_PT100 == 1
 // contructor
-SensorPT100::SensorPT100(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "PT100";
+SensorPT100::SensorPT100(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
+  // set presentation, type and value type
+  setPresentation(S_TEMP);
+  setType(V_TEMP);
+  setValueType(TYPE_FLOAT);
 }
 
 // setter/getter
@@ -3054,16 +3048,13 @@ void SensorPT100::setVoltageRef(float value) {
 
 // what to do during before
 void SensorPT100::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  _PT100 = new DFRobotHighTemperature(_voltageRef); 
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during setup
 void SensorPT100::onSetup() {
-  _PT100 = new DFRobotHighTemperature(_voltageRef); 
-  // set the pin as input
-  pinMode(_pin, INPUT);
-
 }
 
 // what to do during loop
@@ -3071,21 +3062,28 @@ void SensorPT100::onLoop(Child* child) {
   // read the PT100 sensor
   int temperature = _PT100->readTemperature(_pin);  
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("PT100 I="));
+    Serial.print(_child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  _value_float = temperature;
 }
 
 // what to do as the main task when receiving a message
-void SensorPT100::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+void SensorPT100::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) onLoop(NULL);
+}
+
+// what to do when receiving a remote message
+void SensorPT100::onProcess(Request & request) {
+   int function = request.getFunction();
+  switch(function) {
+    case 101: setVoltageRef(request.getValueFloat()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -3099,8 +3099,10 @@ void SensorPT100::onInterrupt() {
 
 #if MODULE_DIMMER == 1
 // contructor
-SensorDimmer::SensorDimmer(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DIMMER";
+SensorDimmer::SensorDimmer(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
+  // set presentation, type and value type
+  setPresentation(S_DIMMER);
+  setType(V_PERCENTAGE);
 }
 
 // setter/getter
@@ -3116,13 +3118,11 @@ void SensorDimmer::setStepDuration(int value) {
 
 // what to do during before
 void SensorDimmer::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_DIMMER,V_PERCENTAGE);
+  pinMode(_pin, OUTPUT);
 }
 
 // what to do during setup
 void SensorDimmer::onSetup() {
-  pinMode(_pin, OUTPUT);
 }
 
 // what to do during loop
@@ -3130,33 +3130,42 @@ void SensorDimmer::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
-void SensorDimmer::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_SET && message->type == child->type) {
-    int percentage = message->getInt();
+void SensorDimmer::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_SET) {
+    int percentage = message.getInt();
     // normalize the provided percentage
     if (percentage < 0) percentage = 0;
     if (percentage > 100) percentage = 100;
-    _fadeTo(child,percentage);
-    ((ChildInt*)child)->setValueInt(_percentage);
+    fadeTo(percentage);
+    _value_int = percentage;
   }
-  if (message->getCommand() == C_REQ) {
+  if (message.getCommand() == C_REQ) {
     // return the current status
-    ((ChildInt*)child)->setValueInt(_percentage);
+    _value_int = _percentage;
   }
 }
 
+// what to do when receiving a remote message
+void SensorDimmer::onProcess(Request & request) {
+   int function = request.getFunction();
+  switch(function) {
+    case 101: setEasing(request.getValueInt()); break;
+    case 102: setDuration(request.getValueInt()); break;
+    case 103: setStepDuration(request.getValueInt()); break;
+    default: return;
+  }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+}
+
 // what to do when receiving an interrupt
 void SensorDimmer::onInterrupt() {
 }
 
 // fade to the provided value
-void SensorDimmer::_fadeTo(Child* child, int target_percentage) {
+void SensorDimmer::fadeTo(int target_percentage) {
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("DIM I="));
+    Serial.print(_child_id);
     Serial.print(F(" V="));
     Serial.println(target_percentage);
   #endif
--- NodeManager.cpp
+++ NodeManager.cpp
@@ -3190,8 +3190,9 @@ float SensorDimmer::_getEasing(float t, float b, float c, float d) {
 */
 #if MODULE_PULSE_METER == 1
 // contructor
-SensorPulseMeter::SensorPulseMeter(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "PULSE";
+SensorPulseMeter::SensorPulseMeter(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id, pin) {
+  // set presentation, type and value type
+  setValueType(TYPE_FLOAT);
 }
 
 // setter/getter
@@ -3207,14 +3208,12 @@ void SensorPulseMeter::setInterruptMode(int value) {
 
 // what to do during before
 void SensorPulseMeter::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+  // configure the interrupt pin so onInterrupt() will be called on tip
+  setInterrupt(_pin,_interrupt_mode,_initial_value);
 }
 
 // what to do during setup
 void SensorPulseMeter::onSetup() {
-  // configure the interrupt pin so onInterrupt() will be called on tip
-  setInterrupt(_pin,_interrupt_mode,_initial_value);
 }
 
 // what to do during loop
@@ -3222,26 +3221,33 @@ void SensorPulseMeter::onLoop(Child* child) {
   // do not report anything if called by an interrupt
   if (_node->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
-  _reportTotal(child);
+  _reportTotal();
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
+    Serial.print(F("PLS I="));
+    Serial.print(_child_id);
     Serial.print(F(" T="));
-    Serial.println(((ChildFloat*)child)->getValueFloat());
+    Serial.println(_value_float);
   #endif
   // reset the counter
   _count = 0;
 }
 
 // what to do as the main task when receiving a message
-void SensorPulseMeter::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) {
+void SensorPulseMeter::onReceive(const MyMessage & message) {
+  if (message.getCommand() == C_REQ) {
     // report the total the last period
-    _reportTotal(child);
+    _reportTotal();
+  }
+}
+
+// what to do when receiving a remote message
+void SensorPulseMeter::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 102: setPulseFactor(request.getValueFloat()); break;
+    default: return;
   }
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3249,28 +3255,23 @@ void SensorPulseMeter::onInterrupt() {
   // increase the counter
   _count++;
   #if DEBUG == 1
-    Serial.print(_name);
-    Serial.println(F("+"));
+    Serial.println(F("PLS+"));
   #endif
 }
 
 // return the total based on the pulses counted
-void SensorPulseMeter::_reportTotal(Child* child) {
-  ((ChildFloat*)child)->setValueFloat(_count / _pulse_factor);
+void SensorPulseMeter::_reportTotal() {
+  if (_value_type == TYPE_DOUBLE) _value_double = _count / _pulse_factor;
+  else _value_float = _count / _pulse_factor;
 }
 
 /*
    SensorRainGauge
 */
 // contructor
-SensorRainGauge::SensorRainGauge(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "RAING";
-}
-
-// what to do during before
-void SensorRainGauge::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_RAIN,V_RAIN);
+SensorRainGauge::SensorRainGauge(NodeManager* node_manager, int child_id, int pin): SensorPulseMeter(node_manager,child_id, pin) {
+  setPresentation(S_RAIN);
+  setType(V_RAIN);
   setPulseFactor(9.09);
 }
 
@@ -3278,41 +3279,23 @@ SensorRainGauge::SensorRainGauge(NodeManager* node_manager, int child_id, int pi
    SensorPowerMeter
 */
 // contructor
-SensorPowerMeter::SensorPowerMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "POWER";
-}
-
-// what to do during before
-void SensorPowerMeter::onBefore() {
-  // register the child
-  new ChildDouble(this,_node->getAvailableChildId(),S_POWER,V_KWH);
+SensorPowerMeter::SensorPowerMeter(NodeManager* node_manager, int child_id, int pin): SensorPulseMeter(node_manager,child_id, pin) {
+  setPresentation(S_POWER);
+  setType(V_KWH);
+  setValueType(TYPE_DOUBLE);
   setPulseFactor(1000);
 }
 
-// return the total based on the pulses counted
-void SensorPowerMeter::_reportTotal(Child* child) {
-  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
-}
-
 /*
    SensorWaterMeter
 */
 // contructor
-SensorWaterMeter::SensorWaterMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "WATER";
-}
-
-// what to do during before
-void SensorWaterMeter::onBefore() {
-  // register the child
-  new ChildDouble(this,_node->getAvailableChildId(),S_WATER,V_VOLUME);
+SensorWaterMeter::SensorWaterMeter(NodeManager* node_manager, int child_id, int pin): SensorPulseMeter(node_manager,child_id, pin) {
+  setPresentation(S_WATER);
+  setType(V_VOLUME);
+  setValueType(TYPE_DOUBLE);
   setPulseFactor(1000);
 }
-
-// return the total based on the pulses counted
-void SensorWaterMeter::_reportTotal(Child* child) {
-  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
-}
 #endif
 
 /*******************************************
