From c04e11fc4611636e90d45d9cb5790cc5aba6bcd5 Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sun, 1 Oct 2017 17:20:51 +0200
Subject: [PATCH 01/51] First Commit

---
 NodeManager.cpp | 25 ++++++++++++++++++++++++-
 NodeManager.h   | 31 ++++++++++++++++++++++++++-----
 NodeManager.ino |  2 +-
 config.h        | 24 ++++++++++++------------
 4 files changed, 63 insertions(+), 19 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 1302c1a..012c65a 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -211,6 +211,17 @@ char* Request::getValueString() {
     Sensors
 */
 
+/*
+ Child class
+ */
+
+Child::Child(int child_id, int presentation, int type, int value_type, char* description) {
+  _child_id = child_id;
+  _presentation = presentation;
+  _value_type = value_type;
+  _description = description;
+}
+
 /*
    Sensor class
 */
@@ -1275,6 +1286,10 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
+//  _children = new Child[2];
+  _children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
+  _children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
+  
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
   if (_sensor_type == SensorSHT21::TEMPERATURE) {
@@ -1303,6 +1318,14 @@ void SensorSHT21::onSetup() {
 
 // what to do during loop
 void SensorSHT21::onLoop() {
+  for (int i = 0; i < MAX_CHILDREN; i++) {
+    if (_children[i] == 0) break;
+    if (i == temperature) {
+      // read the temperature
+      float temperature = SHT2x.GetTemperature();
+    }
+  }
+  
   // temperature sensor
   if (_sensor_type == SensorSHT21::TEMPERATURE) {
     // read the temperature
@@ -3934,7 +3957,7 @@ void NodeManager::sleepOrWait(long value) {
       Serial.println(value);
     #endif
     // report signal level
-	_sendSignalChild(_msg.set(value));
+	//_sendSignalChild(_msg.set(value));
   }
 #endif
 
diff --git a/NodeManager.h b/NodeManager.h
index 7660dee..8d41ffd 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -106,6 +106,10 @@
 #ifndef MAX_SENSORS
   #define MAX_SENSORS 10
 #endif
+// define the maximum number of children that a sensor can have
+#ifndef MAX_CHILDREN
+  #define MAX_CHILDREN 5
+#endif
 // define default sketch name and version
 #ifndef SKETCH_NAME
   #define SKETCH_NAME "NodeManager"
@@ -499,6 +503,17 @@ class Request {
 /***************************************
    Sensor: generic sensor class
 */
+
+class Child {
+  public:
+    Child(int child_id, int presentation, int type, int value_type, char* description);
+    int _child_id;
+    int _presentation = S_CUSTOM;
+    int _type = V_CUSTOM;
+    char* _description = "";
+    int _value_type = TYPE_INTEGER;
+};
+
 class Sensor {
   public:
     Sensor(NodeManager* node_manager, int child_id, int pin);
@@ -581,14 +596,9 @@ class Sensor {
     MyMessage* _msg;
     NodeManager* _node_manager;
     int _pin = -1;
-    int _child_id;
-    int _presentation = S_CUSTOM;
-    int _type = V_CUSTOM;
-    char* _description = "";
     int _samples = 1;
     int _samples_interval = 0;
     bool _track_last_value = false;
-    int _value_type = TYPE_INTEGER;
     int _float_precision = 2;
     int _double_precision = 4;
     int _value_int = -1;
@@ -610,6 +620,12 @@ class Sensor {
     void _sendServiceMessage(MyMessage & msg);
     bool _isReceive(const MyMessage & message);
     bool _isWorthSending(bool comparison);
+    int _child_id;
+    int _presentation = S_CUSTOM;
+    int _type = V_CUSTOM;
+    char* _description = "";
+    int _value_type = TYPE_INTEGER;
+    Child* _children[MAX_CHILDREN+1] = {0};
 };
 
 #if MODULE_ANALOG_INPUT == 1
@@ -875,6 +891,11 @@ class SensorSHT21: public Sensor {
     // constants
     const static int TEMPERATURE = 0;
     const static int HUMIDITY = 1;
+    enum children
+    {
+        temperature,
+        humidity,
+    };
   protected:
     float _offset = 0;
     int _sensor_type = 0;
diff --git a/NodeManager.ino b/NodeManager.ino
index 38bf742..b43242d 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -34,8 +34,8 @@ void before() {
    * Register below your sensors
   */
   
+  nodeManager.registerSensor(SENSOR_SHT21);
   
-
   
   /*
    * Register above your sensors
diff --git a/config.h b/config.h
index d93ab3f..56b438c 100755
--- a/config.h
+++ b/config.h
@@ -15,11 +15,11 @@
 // General settings
 #define MY_BAUD_RATE 9600
 //#define MY_DEBUG
-//#define MY_NODE_ID 100
+#define MY_NODE_ID 3
 //#define MY_SMART_SLEEP_WAIT_DURATION_MS 500
 
 // NRF24 radio settings
-#define MY_RADIO_NRF24
+//#define MY_RADIO_NRF24
 //#define MY_RF24_ENABLE_ENCRYPTION
 //#define MY_RF24_CHANNEL 76
 //#define MY_RF24_PA_LEVEL RF24_PA_HIGH
@@ -27,11 +27,11 @@
 //#define MY_RF24_DATARATE RF24_250KBPS
 
 // RFM69 radio settings
-//#define MY_RADIO_RFM69
+#define MY_RADIO_RFM69
 //#define MY_RFM69_FREQUENCY RF69_868MHZ
-//#define MY_RFM69_FREQUENCY RFM69_868MHZ
-//#define MY_IS_RFM69HW
-//#define MY_RFM69_NEW_DRIVER
+#define MY_RFM69_FREQUENCY RFM69_868MHZ
+#define MY_IS_RFM69HW
+#define MY_RFM69_NEW_DRIVER
 //#define MY_RFM69_ENABLE_ENCRYPTION
 //#define MY_RFM69_NETWORKID 100
 //#define MY_DEBUG_VERBOSE_RFM69
@@ -113,7 +113,7 @@
 #define DEBUG 1
 
 // if enabled, enable the capability to power on sensors with the arduino's pins to save battery while sleeping
-#define POWER_MANAGER 1
+#define POWER_MANAGER 0
 // if enabled, will load the battery manager library to allow the battery level to be reported automatically or on demand
 #define BATTERY_MANAGER 1
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
@@ -123,20 +123,20 @@
 // if enabled, a battery sensor will be created at BATTERY_CHILD_ID (201 by default) and will report vcc voltage together with the battery level percentage
 #define BATTERY_SENSOR 1
 // if enabled, a signal sensor will be created at RSSI_CHILD_ID (202 by default) and will report the signal quality of the transport layer
-#define SIGNAL_SENSOR 0
+#define SIGNAL_SENSOR 1
 // if enabled, send a SLEEPING and AWAKE service messages just before entering and just after leaving a sleep cycle and STARTED when starting/rebooting
 #define SERVICE_MESSAGES 0
 
 // Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
-#define MODULE_ANALOG_INPUT 1
+#define MODULE_ANALOG_INPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT
-#define MODULE_DIGITAL_INPUT 1
+#define MODULE_DIGITAL_INPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_OUTPUT, SENSOR_RELAY, SENSOR_LATCHING_RELAY
-#define MODULE_DIGITAL_OUTPUT 1
+#define MODULE_DIGITAL_OUTPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
 #define MODULE_DHT 0
 // Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
-#define MODULE_SHT21 0
+#define MODULE_SHT21 1
 // Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION
 #define MODULE_SWITCH 0
 // Enable this module to use one of the following sensors: SENSOR_DS18B20

From f350423fae49c5450429068f18a61a97b010e199 Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sun, 1 Oct 2017 19:29:12 +0200
Subject: [PATCH 02/51] Added a sample list data structure

---
 NodeManager.cpp |   9 +-
 NodeManager.h   | 248 ++++++++++++++++++++++++++++++++++++++++++++++++
 NodeManager.ino |   1 +
 3 files changed, 256 insertions(+), 2 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 012c65a..24aaf86 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -215,6 +215,9 @@ char* Request::getValueString() {
  Child class
  */
 
+Child::Child() {
+  
+}
 Child::Child(int child_id, int presentation, int type, int value_type, char* description) {
   _child_id = child_id;
   _presentation = presentation;
@@ -1287,8 +1290,10 @@ void SensorDHT::onInterrupt() {
 // contructor
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
 //  _children = new Child[2];
-  _children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
-  _children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
+  //_children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
+  //_children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
+  myList.push_back(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  myList.push_back(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
diff --git a/NodeManager.h b/NodeManager.h
index 8d41ffd..a09dc6b 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -418,6 +418,252 @@ enum supported_sensors {
 */
 class NodeManager;
 
+template<typename T>
+class SimpleList
+{
+public:
+    typedef T* iterator;
+
+    SimpleList()
+    {
+        _internalArray = NULL;
+        _endPosition = 0;
+        _allocBlocks = 0;
+        _preAllocBlocks = 0;
+    }
+
+    ~SimpleList()
+    {
+        delete[] _internalArray;
+        _internalArray = NULL;
+        _endPosition = 0;
+        _allocBlocks = 0;
+        _preAllocBlocks = 0;
+    }
+
+    SimpleList(const SimpleList& from)
+    {
+        _endPosition = from._endPosition;
+        _allocBlocks = from._allocBlocks;
+        _preAllocBlocks = from._preAllocBlocks;
+
+        _internalArray = new T[_allocBlocks];
+
+        for (int i = 0; i < _endPosition; ++i)
+            _internalArray[i] = from._internalArray[i];
+    }
+
+    SimpleList& operator=(const SimpleList& from)
+    {
+        if (this != &from)
+        {
+            _endPosition = from._endPosition;
+            _allocBlocks = from._allocBlocks;
+            _preAllocBlocks = from._preAllocBlocks;
+
+            delete[] _internalArray;
+            _internalArray = NULL;
+
+            if (_allocBlocks)
+            {
+                _internalArray = new T[_allocBlocks];
+
+                for (int i = 0; i < _endPosition; ++i)
+                    _internalArray[i] = from._internalArray[i];
+            }
+        }
+
+        return *this;
+    }
+
+    void push_back(T item)
+    {
+        if (_endPosition == _allocBlocks)
+            AllocOneBlock(false);
+
+        _internalArray[_endPosition] = item;
+        ++_endPosition;
+    }
+
+    void push_front(T item)
+    {
+        if (_endPosition == _allocBlocks)
+            AllocOneBlock(true);
+        else
+        {
+            for (int i = _endPosition; i > 0; --i)
+                _internalArray[i] = _internalArray[i - 1];
+        }
+
+        _internalArray[0] = item;
+        ++_endPosition;
+    }
+
+    void pop_back()
+    {
+        if (_endPosition == 0)
+            return;
+
+        --_endPosition;
+
+        if (_allocBlocks > _preAllocBlocks)
+            DeAllocOneBlock(false);
+    }
+
+    void pop_front()
+    {
+        if (_endPosition == 0)
+            return;
+
+        --_endPosition;
+
+        if (_allocBlocks > _preAllocBlocks)
+            DeAllocOneBlock(true);
+        else
+        {
+            for (int i = 0; i < _endPosition; ++i)
+                _internalArray[i] = _internalArray[i + 1];
+        }
+    }
+
+    iterator erase(iterator position)
+    {
+        int offSet = int(position - _internalArray);
+
+        if (offSet == _endPosition - 1) // Last item.
+        {
+            pop_back();
+            return end();
+        }
+
+        --_endPosition;
+
+        if (_allocBlocks > _preAllocBlocks)
+        {
+            --_allocBlocks;
+            T* newArray = new T[_allocBlocks];
+
+            for (int i = 0; i < _endPosition; ++i)
+            {
+                if (i >= offSet)
+                    newArray[i] = _internalArray[i + 1];
+                else
+                    newArray[i] = _internalArray[i];
+            }
+
+            delete[] _internalArray;
+            _internalArray = newArray;
+        }
+        else
+        {
+            for (int i = offSet; i < _endPosition; ++i)
+                _internalArray[i] = _internalArray[i + 1];
+        }
+
+        return _internalArray + offSet;
+    }
+
+    void reserve(int size)
+    {
+        if (size == 0 || size < _allocBlocks)
+            return;
+
+        _allocBlocks = size;
+        _preAllocBlocks = size;
+
+        T* newArray = new T[_allocBlocks];
+
+        for (int i = 0; i < _endPosition; ++i)
+            newArray[i] = _internalArray[i];
+
+        delete[] _internalArray;
+        _internalArray = newArray;
+    }
+
+    void clear()
+    {
+        if (_allocBlocks > _preAllocBlocks)
+        {
+            _allocBlocks = _preAllocBlocks;
+
+            T* newArray = NULL;
+
+            if (_allocBlocks > 0)
+                newArray = new T[_allocBlocks];
+
+            delete[] _internalArray;
+            _internalArray = newArray;
+        }
+
+        _endPosition = 0;
+    }
+
+    void shrink_to_fit()
+    {
+        _preAllocBlocks = _endPosition;
+        _allocBlocks = _endPosition;
+
+        T* newArray = NULL;
+
+        if (_allocBlocks > 0)
+            newArray = new T[_allocBlocks];
+
+        for (int i = 0; i < _endPosition; ++i)
+            newArray[i] = _internalArray[i];
+
+        delete[] _internalArray;
+        _internalArray = newArray;
+    }
+
+    inline iterator begin() { return _internalArray; }
+    inline iterator end() { return _internalArray + _endPosition; }
+
+    inline bool empty() { return (_endPosition == 0); }
+    inline unsigned int size() { return _endPosition; }
+    inline unsigned int capacity() { return _allocBlocks; }
+
+private:
+
+    void AllocOneBlock(bool shiftItems)
+    {
+        ++_allocBlocks;
+        T* newArray = new T[_allocBlocks];
+
+        for (int i = 0; i < _endPosition; ++i)
+            newArray[shiftItems ? (i + 1) : i] = _internalArray[i];
+
+        delete[] _internalArray;
+        _internalArray = newArray;
+    }
+
+    void DeAllocOneBlock(bool shiftItems)
+    {
+        --_allocBlocks;
+
+        if (_allocBlocks == 0)
+        {
+            delete[] _internalArray;
+            _internalArray = NULL;
+            return;
+        }
+
+        T* newArray = new T[_allocBlocks];
+
+        for (int i = 0; i < _endPosition; ++i)
+            newArray[i] = _internalArray[shiftItems ? (i + 1) : i];
+
+        delete[] _internalArray;
+        _internalArray = newArray;
+    }
+
+private:
+
+    T* _internalArray;
+    int _endPosition;
+    int _allocBlocks;
+    int _preAllocBlocks;
+};
+
 /*
    PowerManager
 */
@@ -506,6 +752,7 @@ class Request {
 
 class Child {
   public:
+    Child();
     Child(int child_id, int presentation, int type, int value_type, char* description);
     int _child_id;
     int _presentation = S_CUSTOM;
@@ -626,6 +873,7 @@ class Sensor {
     char* _description = "";
     int _value_type = TYPE_INTEGER;
     Child* _children[MAX_CHILDREN+1] = {0};
+    SimpleList<Child> myList;
 };
 
 #if MODULE_ANALOG_INPUT == 1
diff --git a/NodeManager.ino b/NodeManager.ino
index b43242d..f8544f4 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -37,6 +37,7 @@ void before() {
   nodeManager.registerSensor(SENSOR_SHT21);
   
   
+  
   /*
    * Register above your sensors
   */

From ce5e5a9fb15f7da3fbca52cd65ce259ff0cb902b Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sat, 14 Oct 2017 17:39:13 +0200
Subject: [PATCH 03/51] Integrated SimpleList

---
 NodeManager.cpp |   5 +-
 NodeManager.h   | 297 +++++++++---------------------------------------
 2 files changed, 58 insertions(+), 244 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 24aaf86..e52a37b 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -1292,8 +1292,8 @@ SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_typ
 //  _children = new Child[2];
   //_children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
   //_children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
-  myList.push_back(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  myList.push_back(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+  myList.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  myList.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
@@ -4161,3 +4161,4 @@ void NodeManager::_saveConfig() {
   saveState(EEPROM_SLEEP_2,bit_2);
   saveState(EEPROM_SLEEP_3,bit_3);
 }
+
diff --git a/NodeManager.h b/NodeManager.h
index a09dc6b..bc17f85 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -418,250 +418,63 @@ enum supported_sensors {
 */
 class NodeManager;
 
-template<typename T>
-class SimpleList
-{
+/*
+ * List
+ */
+template<typename T> class List {
 public:
-    typedef T* iterator;
-
-    SimpleList()
-    {
-        _internalArray = NULL;
-        _endPosition = 0;
-        _allocBlocks = 0;
-        _preAllocBlocks = 0;
-    }
-
-    ~SimpleList()
-    {
-        delete[] _internalArray;
-        _internalArray = NULL;
-        _endPosition = 0;
-        _allocBlocks = 0;
-        _preAllocBlocks = 0;
-    }
-
-    SimpleList(const SimpleList& from)
-    {
-        _endPosition = from._endPosition;
-        _allocBlocks = from._allocBlocks;
-        _preAllocBlocks = from._preAllocBlocks;
-
-        _internalArray = new T[_allocBlocks];
-
-        for (int i = 0; i < _endPosition; ++i)
-            _internalArray[i] = from._internalArray[i];
-    }
-
-    SimpleList& operator=(const SimpleList& from)
-    {
-        if (this != &from)
-        {
-            _endPosition = from._endPosition;
-            _allocBlocks = from._allocBlocks;
-            _preAllocBlocks = from._preAllocBlocks;
-
-            delete[] _internalArray;
-            _internalArray = NULL;
-
-            if (_allocBlocks)
-            {
-                _internalArray = new T[_allocBlocks];
-
-                for (int i = 0; i < _endPosition; ++i)
-                    _internalArray[i] = from._internalArray[i];
-            }
-        }
-
-        return *this;
-    }
-
-    void push_back(T item)
-    {
-        if (_endPosition == _allocBlocks)
-            AllocOneBlock(false);
-
-        _internalArray[_endPosition] = item;
-        ++_endPosition;
-    }
-
-    void push_front(T item)
-    {
-        if (_endPosition == _allocBlocks)
-            AllocOneBlock(true);
-        else
-        {
-            for (int i = _endPosition; i > 0; --i)
-                _internalArray[i] = _internalArray[i - 1];
-        }
-
-        _internalArray[0] = item;
-        ++_endPosition;
-    }
-
-    void pop_back()
-    {
-        if (_endPosition == 0)
-            return;
-
-        --_endPosition;
-
-        if (_allocBlocks > _preAllocBlocks)
-            DeAllocOneBlock(false);
-    }
-
-    void pop_front()
-    {
-        if (_endPosition == 0)
-            return;
-
-        --_endPosition;
-
-        if (_allocBlocks > _preAllocBlocks)
-            DeAllocOneBlock(true);
-        else
-        {
-            for (int i = 0; i < _endPosition; ++i)
-                _internalArray[i] = _internalArray[i + 1];
-        }
-    }
-
-    iterator erase(iterator position)
-    {
-        int offSet = int(position - _internalArray);
-
-        if (offSet == _endPosition - 1) // Last item.
-        {
-            pop_back();
-            return end();
-        }
-
-        --_endPosition;
-
-        if (_allocBlocks > _preAllocBlocks)
-        {
-            --_allocBlocks;
-            T* newArray = new T[_allocBlocks];
-
-            for (int i = 0; i < _endPosition; ++i)
-            {
-                if (i >= offSet)
-                    newArray[i] = _internalArray[i + 1];
-                else
-                    newArray[i] = _internalArray[i];
-            }
-
-            delete[] _internalArray;
-            _internalArray = newArray;
-        }
-        else
-        {
-            for (int i = offSet; i < _endPosition; ++i)
-                _internalArray[i] = _internalArray[i + 1];
-        }
-
-        return _internalArray + offSet;
-    }
-
-    void reserve(int size)
-    {
-        if (size == 0 || size < _allocBlocks)
-            return;
-
-        _allocBlocks = size;
-        _preAllocBlocks = size;
-
-        T* newArray = new T[_allocBlocks];
-
-        for (int i = 0; i < _endPosition; ++i)
-            newArray[i] = _internalArray[i];
-
-        delete[] _internalArray;
-        _internalArray = newArray;
-    }
-
-    void clear()
-    {
-        if (_allocBlocks > _preAllocBlocks)
-        {
-            _allocBlocks = _preAllocBlocks;
-
-            T* newArray = NULL;
-
-            if (_allocBlocks > 0)
-                newArray = new T[_allocBlocks];
-
-            delete[] _internalArray;
-            _internalArray = newArray;
-        }
-
-        _endPosition = 0;
-    }
-
-    void shrink_to_fit()
-    {
-        _preAllocBlocks = _endPosition;
-        _allocBlocks = _endPosition;
-
-        T* newArray = NULL;
-
-        if (_allocBlocks > 0)
-            newArray = new T[_allocBlocks];
-
-        for (int i = 0; i < _endPosition; ++i)
-            newArray[i] = _internalArray[i];
-
-        delete[] _internalArray;
-        _internalArray = newArray;
-    }
-
-    inline iterator begin() { return _internalArray; }
-    inline iterator end() { return _internalArray + _endPosition; }
-
-    inline bool empty() { return (_endPosition == 0); }
-    inline unsigned int size() { return _endPosition; }
-    inline unsigned int capacity() { return _allocBlocks; }
-
+  typedef T* iterator;
+  List() {
+    _internalArray = NULL;
+    _endPosition = 0;
+    _allocBlocks = 0;
+    _preAllocBlocks = 0;
+  }
+  ~List() {
+    delete[] _internalArray;
+    _internalArray = NULL;
+    _endPosition = 0;
+    _allocBlocks = 0;
+    _preAllocBlocks = 0;
+  }
+  void push(T item) {
+    if (_endPosition == _allocBlocks) _AllocOneBlock(false);
+    _internalArray[_endPosition] = item;
+    ++_endPosition;
+  }
+  void pop() {
+    if (_endPosition == 0) return;
+    --_endPosition;
+    if (_allocBlocks > _preAllocBlocks) _DeAllocOneBlock(false);
+  }
+  inline iterator begin() { return _internalArray; }
+  inline iterator end() { return _internalArray + _endPosition; }
+  inline bool empty() { return (_endPosition == 0); }
+  inline unsigned int size() { return _endPosition; }
 private:
-
-    void AllocOneBlock(bool shiftItems)
-    {
-        ++_allocBlocks;
-        T* newArray = new T[_allocBlocks];
-
-        for (int i = 0; i < _endPosition; ++i)
-            newArray[shiftItems ? (i + 1) : i] = _internalArray[i];
-
-        delete[] _internalArray;
-        _internalArray = newArray;
+  T* _internalArray;
+  int _endPosition;
+  int _allocBlocks;
+  int _preAllocBlocks;
+  void _AllocOneBlock(bool shiftItems) {
+    ++_allocBlocks;
+    T* newArray = new T[_allocBlocks];
+    for (int i = 0; i < _endPosition; ++i) newArray[shiftItems ? (i + 1) : i] = _internalArray[i];
+    delete[] _internalArray;
+    _internalArray = newArray;
+  }
+  void _DeAllocOneBlock(bool shiftItems) {
+    --_allocBlocks;
+    if (_allocBlocks == 0) {
+      delete[] _internalArray;
+      _internalArray = NULL;
+      return;
     }
-
-    void DeAllocOneBlock(bool shiftItems)
-    {
-        --_allocBlocks;
-
-        if (_allocBlocks == 0)
-        {
-            delete[] _internalArray;
-            _internalArray = NULL;
-            return;
-        }
-
-        T* newArray = new T[_allocBlocks];
-
-        for (int i = 0; i < _endPosition; ++i)
-            newArray[i] = _internalArray[shiftItems ? (i + 1) : i];
-
-        delete[] _internalArray;
-        _internalArray = newArray;
-    }
-
-private:
-
-    T* _internalArray;
-    int _endPosition;
-    int _allocBlocks;
-    int _preAllocBlocks;
+    T* newArray = new T[_allocBlocks];
+    for (int i = 0; i < _endPosition; ++i) newArray[i] = _internalArray[shiftItems ? (i + 1) : i];
+    delete[] _internalArray;
+    _internalArray = newArray;
+  }
 };
 
 /*
@@ -873,7 +686,7 @@ class Sensor {
     char* _description = "";
     int _value_type = TYPE_INTEGER;
     Child* _children[MAX_CHILDREN+1] = {0};
-    SimpleList<Child> myList;
+    List<Child> myList;
 };
 
 #if MODULE_ANALOG_INPUT == 1

From 26504f9ac4e1c8b42fbd61265330471a7c9f6f27 Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sat, 14 Oct 2017 18:19:15 +0200
Subject: [PATCH 04/51] SensorSHT21 testing

---
 NodeManager.cpp | 81 +++++++++++++++++++++++--------------------------
 NodeManager.h   | 16 ++++------
 2 files changed, 44 insertions(+), 53 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index e52a37b..37c4096 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -218,11 +218,11 @@ char* Request::getValueString() {
 Child::Child() {
   
 }
-Child::Child(int child_id, int presentation, int type, int value_type, char* description) {
-  _child_id = child_id;
-  _presentation = presentation;
-  _value_type = value_type;
-  _description = description;
+Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
+  child_id = _child_id;
+  presentation = _presentation;
+  value_type = _value_type;
+  description = _description;
 }
 
 /*
@@ -394,6 +394,9 @@ void Sensor::loop(const MyMessage & message) {
     // turn the sensor on
     if (_auto_power_pins) powerOn();
   #endif
+  
+  // FOR ALL CHILD
+  
   // for numeric sensor requiring multiple samples, keep track of the total
   double total = 0;
   // collect multiple samples if needed
@@ -1289,11 +1292,8 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
-//  _children = new Child[2];
-  //_children[temperature] = new Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,"");
-  //_children[humidity] = new Child(2,S_HUM,V_HUM,TYPE_FLOAT,"");
-  myList.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  myList.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+  _children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  _children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   
   // store the sensor type (0: temperature, 1: humidity)
   _sensor_type = sensor_type;
@@ -1323,42 +1323,37 @@ void SensorSHT21::onSetup() {
 
 // what to do during loop
 void SensorSHT21::onLoop() {
-  for (int i = 0; i < MAX_CHILDREN; i++) {
-    if (_children[i] == 0) break;
-    if (i == temperature) {
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    // temperature sensor
+    Child c = (*itr);
+    if (c.type == V_TEMP) {
       // read the temperature
       float temperature = SHT2x.GetTemperature();
+      // convert it
+      temperature = _node_manager->celsiusToFahrenheit(temperature);
+      #if DEBUG == 1
+        Serial.print(F("SHT I="));
+        Serial.print((*itr).child_id);
+        Serial.print(F(" T="));
+        Serial.println(temperature);
+      #endif
+      // store the value
+      if (! isnan(temperature)) _value_float = temperature;
+    }
+    // Humidity Sensor
+    else if ((*itr).type == V_HUM) {
+      // read humidity
+      float humidity = SHT2x.GetHumidity();
+      if (isnan(humidity)) return;
+      #if DEBUG == 1
+        Serial.print(F("SHT I="));
+        Serial.print((*itr).child_id);
+        Serial.print(F(" H="));
+        Serial.println(humidity);
+      #endif
+      // store the value
+      if (! isnan(humidity)) _value_float = humidity;
     }
-  }
-  
-  // temperature sensor
-  if (_sensor_type == SensorSHT21::TEMPERATURE) {
-    // read the temperature
-    float temperature = SHT2x.GetTemperature();
-    // convert it
-    temperature = _node_manager->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
-      Serial.print(F("SHT I="));
-      Serial.print(_child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) _value_float = temperature;
-  }
-  // Humidity Sensor
-  else if (_sensor_type == SensorSHT21::HUMIDITY) {
-    // read humidity
-    float humidity = SHT2x.GetHumidity();
-    if (isnan(humidity)) return;
-    #if DEBUG == 1
-      Serial.print(F("SHT I="));
-      Serial.print(_child_id);
-      Serial.print(F(" H="));
-      Serial.println(humidity);
-    #endif
-    // store the value
-    if (! isnan(humidity)) _value_float = humidity;
   }
 }
 
diff --git a/NodeManager.h b/NodeManager.h
index bc17f85..771fa96 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -107,9 +107,6 @@
   #define MAX_SENSORS 10
 #endif
 // define the maximum number of children that a sensor can have
-#ifndef MAX_CHILDREN
-  #define MAX_CHILDREN 5
-#endif
 // define default sketch name and version
 #ifndef SKETCH_NAME
   #define SKETCH_NAME "NodeManager"
@@ -567,11 +564,11 @@ class Child {
   public:
     Child();
     Child(int child_id, int presentation, int type, int value_type, char* description);
-    int _child_id;
-    int _presentation = S_CUSTOM;
-    int _type = V_CUSTOM;
-    char* _description = "";
-    int _value_type = TYPE_INTEGER;
+    int child_id;
+    int presentation = S_CUSTOM;
+    int type = V_CUSTOM;
+    char* description = "";
+    int value_type = TYPE_INTEGER;
 };
 
 class Sensor {
@@ -685,8 +682,7 @@ class Sensor {
     int _type = V_CUSTOM;
     char* _description = "";
     int _value_type = TYPE_INTEGER;
-    Child* _children[MAX_CHILDREN+1] = {0};
-    List<Child> myList;
+    List<Child> _children;
 };
 
 #if MODULE_ANALOG_INPUT == 1

From 0cd7f3613e4804178ab23429c17b7e1ce489dd27 Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sat, 14 Oct 2017 18:43:37 +0200
Subject: [PATCH 05/51] Completed first draft of SensorSHT21

---
 NodeManager.cpp | 285 +++++++++++++++++++++++-------------------------
 NodeManager.h   |  54 ++++-----
 2 files changed, 163 insertions(+), 176 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 37c4096..a441481 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -396,67 +396,69 @@ void Sensor::loop(const MyMessage & message) {
   #endif
   
   // FOR ALL CHILD
-  
-  // for numeric sensor requiring multiple samples, keep track of the total
-  double total = 0;
-  // collect multiple samples if needed
-  for (int i = 0; i < _samples; i++) {
-    // call the sensor-specific implementation of the main task which will store the result in the _value variable
-    if (_isReceive(message)) {
-      // we've been called from receive(), pass the message along
-      onReceive(message);
-    }
-    else {
-      // we'be been called from loop()
-      onLoop();
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    Child child = (*itr);
+    // for numeric sensor requiring multiple samples, keep track of the total
+    double total = 0;
+    // collect multiple samples if needed
+    for (int i = 0; i < _samples; i++) {
+      // call the sensor-specific implementation of the main task which will store the result in the _value variable
+      if (_isReceive(message)) {
+        // we've been called from receive(), pass the message along
+        onReceive(message);
+      }
+      else {
+        // we'be been called from loop()
+        onLoop(child);
+      }
+      // for integers, floats and doubles, keep track of the total
+      if (_value_type == TYPE_INTEGER) total += (float)_value_int;
+      else if (_value_type == TYPE_FLOAT) total += _value_float;
+      else if (_value_type == TYPE_DOUBLE) total += _value_double;
+      // wait between samples
+      if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
-    // for integers, floats and doubles, keep track of the total
-    if (_value_type == TYPE_INTEGER) total += (float)_value_int;
-    else if (_value_type == TYPE_FLOAT) total += _value_float;
-    else if (_value_type == TYPE_DOUBLE) total += _value_double;
-    // wait between samples
-    if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
-  }
-  // process the result and send a response back
-  if (_value_type == TYPE_INTEGER && total > -1) {
-    // if the value is an integer, calculate the average value of the samples
-    int avg = (int) (total / _samples);
-    // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-    if (_isReceive(message) || _isWorthSending(avg != _last_value_int))  {
-      _last_value_int = avg;
-      _sendSensorMessage(_msg->set(avg));
-      _value_int = -1;
+    // process the result and send a response back
+    if (_value_type == TYPE_INTEGER && total > -1) {
+      // if the value is an integer, calculate the average value of the samples
+      int avg = (int) (total / _samples);
+      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
+      if (_isReceive(message) || _isWorthSending(avg != _last_value_int))  {
+        _last_value_int = avg;
+        _sendSensorMessage(_msg->set(avg));
+        _value_int = -1;
+      }
     }
-  }
-  // process a float value
-  else if (_value_type == TYPE_FLOAT && total > -1) {
-    // calculate the average value of the samples
-    float avg = total / _samples;
-    // report the value back
-    if (_isReceive(message) || _isWorthSending(avg != _last_value_float))  {
-      _last_value_float = avg;
-      _sendSensorMessage(_msg->set(avg, _float_precision));
-      _value_float = -1;
+    // process a float value
+    else if (_value_type == TYPE_FLOAT && total > -1) {
+      // calculate the average value of the samples
+      float avg = total / _samples;
+      // report the value back
+      if (_isReceive(message) || _isWorthSending(avg != _last_value_float))  {
+        _last_value_float = avg;
+        _sendSensorMessage(_msg->set(avg, _float_precision));
+        _value_float = -1;
+      }
     }
-  }
-  // process a double value
-  else if (_value_type == TYPE_DOUBLE && total > -1) {
-    // calculate the average value of the samples
-    double avg = total / _samples;
-    // report the value back
-    if (_isReceive(message) || _isWorthSending(avg != _last_value_double))  {
-      _last_value_double = avg;
-      _sendSensorMessage(_msg->set(avg, _double_precision));
-      _value_double = -1;
+    // process a double value
+    else if (_value_type == TYPE_DOUBLE && total > -1) {
+      // calculate the average value of the samples
+      double avg = total / _samples;
+      // report the value back
+      if (_isReceive(message) || _isWorthSending(avg != _last_value_double))  {
+        _last_value_double = avg;
+        _sendSensorMessage(_msg->set(avg, _double_precision));
+        _value_double = -1;
+      }
     }
-  }
-  // process a string value
-  else if (_value_type == TYPE_STRING) {
-    // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-    if (_isReceive(message) || _isWorthSending(strcmp(_value_string, _last_value_string) != 0))  {
-      _last_value_string = _value_string;
-      _sendSensorMessage(_msg->set(_value_string));
-      _value_string = "";
+    // process a string value
+    else if (_value_type == TYPE_STRING) {
+      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
+      if (_isReceive(message) || _isWorthSending(strcmp(_value_string, _last_value_string) != 0))  {
+        _last_value_string = _value_string;
+        _sendSensorMessage(_msg->set(_value_string));
+        _value_string = "";
+      }
     }
   }
   // turn the sensor off
@@ -597,7 +599,7 @@ void SensorAnalogInput::onSetup() {
 }
 
 // what to do during loop
-void SensorAnalogInput::onLoop() {
+void SensorAnalogInput::onLoop(Child child) {
   // read the input
   int adc = _getAnalogRead();
   // calculate the percentage
@@ -617,7 +619,7 @@ void SensorAnalogInput::onLoop() {
 
 // what to do during loop
 void SensorAnalogInput::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -718,7 +720,7 @@ void SensorThermistor::onSetup() {
 }
 
 // what to do during loop
-void SensorThermistor::onLoop() {
+void SensorThermistor::onLoop(Child child) {
   // read the voltage across the thermistor
   float adc = analogRead(_pin);
   // calculate the temperature
@@ -746,7 +748,7 @@ void SensorThermistor::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorThermistor::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -790,7 +792,7 @@ void SensorML8511::onSetup() {
 }
 
 // what to do during loop
-void SensorML8511::onLoop() {
+void SensorML8511::onLoop(Child child) {
   // read the voltage 
   int uvLevel = analogRead(_pin);
   int refLevel = _node_manager->getVcc()*1024/3.3;
@@ -812,7 +814,7 @@ void SensorML8511::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorML8511::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -859,7 +861,7 @@ void SensorACS712::onSetup() {
 }
 
 // what to do during loop
-void SensorACS712::onLoop() {
+void SensorACS712::onLoop(Child child) {
   int value = analogRead(_pin);
   // convert the analog read in mV
   double voltage = (value / 1024.0) * 5000; 
@@ -875,7 +877,7 @@ void SensorACS712::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorACS712::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -945,7 +947,7 @@ void SensorDigitalInput::onSetup() {
 }
 
 // what to do during loop
-void SensorDigitalInput::onLoop() {
+void SensorDigitalInput::onLoop(Child child) {
   // read the value
   int value = digitalRead(_pin);
   #if DEBUG == 1
@@ -962,7 +964,7 @@ void SensorDigitalInput::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorDigitalInput::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -1015,7 +1017,7 @@ void SensorDigitalOutput::setWaitAfterSet(int value) {
 }
 
 // main task
-void SensorDigitalOutput::onLoop() {
+void SensorDigitalOutput::onLoop(Child child) {
   // set the value to -1 so to avoid reporting to the gateway during loop
   _value_int = -1;
   _last_value_int = -1;
@@ -1240,7 +1242,7 @@ void SensorDHT::onSetup() {
 }
 
 // what to do during loop
-void SensorDHT::onLoop() {
+void SensorDHT::onLoop(Child child) {
   _node_manager->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
@@ -1274,7 +1276,7 @@ void SensorDHT::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorDHT::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -1294,21 +1296,6 @@ void SensorDHT::onInterrupt() {
 SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
   _children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
   _children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
-  
-  // store the sensor type (0: temperature, 1: humidity)
-  _sensor_type = sensor_type;
-  if (_sensor_type == SensorSHT21::TEMPERATURE) {
-    // temperature sensor
-    setPresentation(S_TEMP);
-    setType(V_TEMP);
-    setValueType(TYPE_FLOAT);
-  }
-  else if (_sensor_type == SensorSHT21::HUMIDITY) {
-    // humidity sensor
-    setPresentation(S_HUM);
-    setType(V_HUM);
-    setValueType(TYPE_FLOAT);
-  }
 }
 
 // what to do during before
@@ -1322,44 +1309,44 @@ void SensorSHT21::onSetup() {
 }
 
 // what to do during loop
-void SensorSHT21::onLoop() {
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    // temperature sensor
-    Child c = (*itr);
-    if (c.type == V_TEMP) {
-      // read the temperature
-      float temperature = SHT2x.GetTemperature();
-      // convert it
-      temperature = _node_manager->celsiusToFahrenheit(temperature);
-      #if DEBUG == 1
-        Serial.print(F("SHT I="));
-        Serial.print((*itr).child_id);
-        Serial.print(F(" T="));
-        Serial.println(temperature);
-      #endif
-      // store the value
-      if (! isnan(temperature)) _value_float = temperature;
-    }
-    // Humidity Sensor
-    else if ((*itr).type == V_HUM) {
-      // read humidity
-      float humidity = SHT2x.GetHumidity();
-      if (isnan(humidity)) return;
-      #if DEBUG == 1
-        Serial.print(F("SHT I="));
-        Serial.print((*itr).child_id);
-        Serial.print(F(" H="));
-        Serial.println(humidity);
-      #endif
-      // store the value
-      if (! isnan(humidity)) _value_float = humidity;
-    }
+void SensorSHT21::onLoop(Child child) {
+  // temperature sensor
+  if (child.type == V_TEMP) {
+    // read the temperature
+    float temperature = SHT2x.GetTemperature();
+    // convert it
+    temperature = _node_manager->celsiusToFahrenheit(temperature);
+    #if DEBUG == 1
+      Serial.print(F("SHT I="));
+      Serial.print(child.child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) _value_float = temperature;
+  }
+  // Humidity Sensor
+  else if (child.type == V_HUM) {
+    // read humidity
+    float humidity = SHT2x.GetHumidity();
+    if (isnan(humidity)) return;
+    #if DEBUG == 1
+      Serial.print(F("SHT I="));
+      Serial.print(child.child_id);
+      Serial.print(F(" H="));
+      Serial.println(humidity);
+    #endif
+    // store the value
+   if (! isnan(humidity)) _value_float = humidity;
   }
 }
 
 // what to do as the main task when receiving a message
 void SensorSHT21::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    Child child = (*itr);
+    if (message.getCommand() == C_REQ && child.child_id == message.sensor) onLoop(child);
+  }
 }
 
 // what to do when receiving a remote message
@@ -1415,7 +1402,7 @@ void SensorSwitch::onSetup() {
 }
 
 // what to do during loop
-void SensorSwitch::onLoop() {
+void SensorSwitch::onLoop(Child child) {
 }
 
 // what to do as the main task when receiving a message
@@ -1504,7 +1491,7 @@ void SensorDs18b20::onSetup() {
 }
 
 // what to do during loop
-void SensorDs18b20::onLoop() {
+void SensorDs18b20::onLoop(Child child) {
   // do not wait for conversion, will sleep manually during it
   if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
   // request the temperature
@@ -1530,7 +1517,7 @@ void SensorDs18b20::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorDs18b20::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -1595,7 +1582,7 @@ void SensorBH1750::onSetup() {
 }
 
 // what to do during loop
-void SensorBH1750::onLoop() {
+void SensorBH1750::onLoop(Child child) {
   // request the light level
   _value_int = _lightSensor->readLightLevel();
   #if DEBUG == 1
@@ -1608,7 +1595,7 @@ void SensorBH1750::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorBH1750::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -1652,7 +1639,7 @@ void SensorMLX90614::onSetup() {
 }
 
 // what to do during loop
-void SensorMLX90614::onLoop() {
+void SensorMLX90614::onLoop(Child child) {
   float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -1667,7 +1654,7 @@ void SensorMLX90614::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorMLX90614::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -1729,12 +1716,12 @@ void SensorBosch::onSetup() {
 }
 
 // what to do during loop
-void SensorBosch::onLoop() {
+void SensorBosch::onLoop(Child child) {
 }
 
 // what to do as the main task when receiving a message
 void SensorBosch::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -1868,7 +1855,7 @@ SensorBME280::SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME
   _bme = bme;
 }
 
-void SensorBME280::onLoop() {
+void SensorBME280::onLoop(Child child) {
   // temperature sensor
   if (_sensor_type == SensorBME280::TEMPERATURE) {
     // read the temperature
@@ -1932,7 +1919,7 @@ SensorBMP085::SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP
 }
 
 // what to do during loop
-void SensorBMP085::onLoop() {
+void SensorBMP085::onLoop(Child child) {
   // temperature sensor
   if (_sensor_type == SensorBMP085::TEMPERATURE) {
     // read the temperature
@@ -1979,7 +1966,7 @@ SensorBMP280::SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP
   _bmp = bmp;
 }
 
-void SensorBMP280::onLoop() {
+void SensorBMP280::onLoop(Child child) {
   // temperature sensor
   if (_sensor_type == SensorBMP280::TEMPERATURE) {
     // read the temperature
@@ -2054,7 +2041,7 @@ void SensorHCSR04::onSetup() {
 }
 
 // what to do during loop
-void SensorHCSR04::onLoop() {
+void SensorHCSR04::onLoop(Child child) {
   int distance = _node_manager->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
   #if DEBUG == 1
     Serial.print(F("HC I="));
@@ -2067,7 +2054,7 @@ void SensorHCSR04::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorHCSR04::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -2129,7 +2116,7 @@ void SensorSonoff::onSetup() {
 }
 
 // what to do during loop
-void SensorSonoff::onLoop() {
+void SensorSonoff::onLoop(Child child) {
   _debouncer.update();
   // Get the update value from the button
   int value = _debouncer.read();
@@ -2222,7 +2209,7 @@ void SensorMCP9808::onSetup() {
 }
 
 // what to do during loop
-void SensorMCP9808::onLoop() {
+void SensorMCP9808::onLoop(Child child) {
   float temperature = _mcp->readTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -2238,7 +2225,7 @@ void SensorMCP9808::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorMCP9808::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -2315,7 +2302,7 @@ void SensorMQ::onSetup() {
 }
 
 // what to do during loop
-void SensorMQ::onLoop() {
+void SensorMQ::onLoop(Child child) {
   if (_pin == -1) return;
   // calculate rs/ro
   float mq = _MQRead()/_ro;
@@ -2346,7 +2333,7 @@ void SensorMQ::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorMQ::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -2455,7 +2442,7 @@ void SensorMHZ19::onSetup() {
 }
 
 // what to do during loop
-void SensorMHZ19::onLoop() {
+void SensorMHZ19::onLoop(Child child) {
   // Read the ppm value
   int co2ppm = readCO2(); // This is there the function gets called that talks to the Co2 sensor.
   #if DEBUG == 1
@@ -2509,7 +2496,7 @@ int SensorMHZ19::readCO2() {
 
 // what to do as the main task when receiving a message
 void SensorMHZ19::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -2559,7 +2546,7 @@ void SensorAM2320::onSetup() {
 }
 
 // what do to during loop
-void SensorAM2320::onLoop() {
+void SensorAM2320::onLoop(Child child) {
   switch(_th->Read()) {
     case 0:
       // temperature sensor
@@ -2597,7 +2584,7 @@ void SensorAM2320::onLoop() {
 
 // what do to as the main task when receiving a message
 void SensorAM2320::onReceive(const MyMessage & message) {
-  onLoop();
+  onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -2677,7 +2664,7 @@ void SensorTSL2561::onSetup() {
 }
 
 // what do to during loop
-void SensorTSL2561::onLoop() {
+void SensorTSL2561::onLoop(Child child) {
   // request the light level
    switch (_tsl_spectrum) {
     case SensorTSL2561::VISIBLE:
@@ -2722,7 +2709,7 @@ void SensorTSL2561::onLoop() {
 
 // what do to as the main task when receiving a message
 void SensorTSL2561::onReceive(const MyMessage & message) {
-  onLoop();
+  onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -2772,7 +2759,7 @@ void SensorPT100::onSetup() {
 }
 
 // what to do during loop
-void SensorPT100::onLoop() {
+void SensorPT100::onLoop(Child child) {
   // read the PT100 sensor
   int temperature = _PT100->readTemperature(_pin);  
   #if DEBUG == 1
@@ -2787,7 +2774,7 @@ void SensorPT100::onLoop() {
 
 // what to do as the main task when receiving a message
 void SensorPT100::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop();
+  if (message.getCommand() == C_REQ) onLoop(NULL);
 }
 
 // what to do when receiving a remote message
@@ -2838,7 +2825,7 @@ void SensorDimmer::onSetup() {
 }
 
 // what to do during loop
-void SensorDimmer::onLoop() {
+void SensorDimmer::onLoop(Child child) {
 }
 
 // what to do as the main task when receiving a message
@@ -2938,7 +2925,7 @@ void SensorPulseMeter::onSetup() {
 }
 
 // what to do during loop
-void SensorPulseMeter::onLoop() {
+void SensorPulseMeter::onLoop(Child child) {
   // do not report anything if called by an interrupt
   if (_node_manager->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
@@ -3202,8 +3189,8 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
       // register temperature sensor
       registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
       // register humidity sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
+      //child_id = _getAvailableChildId();
+      //return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
     }
     else if (sensor_type == SENSOR_HTU21D) {
       // register temperature sensor
diff --git a/NodeManager.h b/NodeManager.h
index 771fa96..9c0b41f 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -645,7 +645,7 @@ class Sensor {
     // abstract functions, subclasses need to implement
     virtual void onBefore() = 0;
     virtual void onSetup() = 0;
-    virtual void onLoop() = 0;
+    virtual void onLoop(Child child) = 0;
     virtual void onReceive(const MyMessage & message) = 0;
     virtual void onProcess(Request & request) = 0;
     virtual void onInterrupt() = 0;
@@ -705,7 +705,7 @@ class SensorAnalogInput: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -746,7 +746,7 @@ class SensorThermistor: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -768,7 +768,7 @@ class SensorML8511: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -790,7 +790,7 @@ class SensorACS712: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -827,7 +827,7 @@ class SensorDigitalInput: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -858,7 +858,7 @@ class SensorDigitalOutput: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -916,7 +916,7 @@ class SensorDHT: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -941,7 +941,7 @@ class SensorSHT21: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -986,7 +986,7 @@ class SensorSwitch: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1031,7 +1031,7 @@ class SensorDs18b20: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1056,7 +1056,7 @@ class SensorBH1750: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1075,7 +1075,7 @@ class SensorMLX90614: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1102,7 +1102,7 @@ class SensorBosch: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1134,7 +1134,7 @@ class SensorBosch: public Sensor {
 class SensorBME280: public SensorBosch {
   public:
     SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME280* bme, int sensor_type);
-    void onLoop();
+    void onLoop(Child child);
   protected:
     Adafruit_BME280* _bme;
 };
@@ -1147,7 +1147,7 @@ class SensorBME280: public SensorBosch {
 class SensorBMP085: public SensorBosch {
   public:
     SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP085* bmp, int sensor_type);
-    void onLoop();
+    void onLoop(Child child);
   protected:
     Adafruit_BMP085* _bmp;
 };
@@ -1160,7 +1160,7 @@ class SensorBMP085: public SensorBosch {
 class SensorBMP280: public SensorBosch {
   public:
     SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP280* bmp, int sensor_type);
-    void onLoop();
+    void onLoop(Child child);
   protected:
     Adafruit_BMP280* _bmp;
 };
@@ -1182,7 +1182,7 @@ class SensorHCSR04: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1210,7 +1210,7 @@ class SensorSonoff: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1240,7 +1240,7 @@ class SensorMCP9808: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1281,7 +1281,7 @@ class SensorMQ: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1324,7 +1324,7 @@ class SensorMHZ19: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1345,7 +1345,7 @@ class SensorAM2320: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1376,7 +1376,7 @@ class SensorTSL2561: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1414,7 +1414,7 @@ class SensorPT100: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1448,7 +1448,7 @@ class SensorDimmer: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1477,7 +1477,7 @@ class SensorPulseMeter: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop();
+    void onLoop(Child child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();

From 7f29757b6a5befb9351a3c79d0a6ac934f9ce77d Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sun, 15 Oct 2017 11:31:11 +0200
Subject: [PATCH 06/51] First SHT21 working example

---
 NodeManager.cpp | 13 +++++++++----
 NodeManager.ino |  7 ++++++-
 config.h        | 23 ++++++++++++-----------
 3 files changed, 27 insertions(+), 16 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index a441481..1f39b92 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -221,6 +221,7 @@ Child::Child() {
 Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
   child_id = _child_id;
   presentation = _presentation;
+  type = _type;
   value_type = _value_type;
   description = _description;
 }
@@ -354,13 +355,17 @@ void Sensor::setInterrupt(int pin, int mode, int initial) {
 
 // present the sensor to the gateway and controller
 void Sensor::presentation() {
+  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
+    Child child = (*itr);
   #if DEBUG == 1
     Serial.print(F("PRES I="));
-    Serial.print(_child_id);
+    Serial.print(child.child_id);
     Serial.print(F(" T="));
-    Serial.println(_presentation);
+    Serial.println(child.presentation);
   #endif
-  present(_child_id, _presentation,_description,_node_manager->getAck());
+  present(child.child_id, child.presentation,child.description,_node_manager->getAck());
+  }
+
 }
 
 // call the sensor-specific implementation of before
@@ -377,7 +382,7 @@ void Sensor::setup() {
 
 // call the sensor-specific implementation of loop
 void Sensor::loop(const MyMessage & message) {
-  if (_pin == -1) return;
+//  if (_pin == -1) return;
   // update the timers if within a loop cycle
   if (! _isReceive(message)) {
     if (_report_timer->isRunning()) {
diff --git a/NodeManager.ino b/NodeManager.ino
index f8544f4..01a1394 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -33,8 +33,13 @@ void before() {
   /*
    * Register below your sensors
   */
-  
+      pinMode(4, OUTPUT);
+    digitalWrite(4, HIGH);
+    pinMode(5, OUTPUT);
+    digitalWrite(5, LOW);
+
   nodeManager.registerSensor(SENSOR_SHT21);
+  nodeManager.setReportIntervalSeconds(20);
   
   
   
diff --git a/config.h b/config.h
index 56b438c..3a97d4d 100755
--- a/config.h
+++ b/config.h
@@ -15,23 +15,24 @@
 // General settings
 #define MY_BAUD_RATE 9600
 //#define MY_DEBUG
-#define MY_NODE_ID 3
+#define MY_NODE_ID 100
 //#define MY_SMART_SLEEP_WAIT_DURATION_MS 500
+#define MY_SPLASH_SCREEN_DISABLED
 
 // NRF24 radio settings
-//#define MY_RADIO_NRF24
+#define MY_RADIO_NRF24
 //#define MY_RF24_ENABLE_ENCRYPTION
-//#define MY_RF24_CHANNEL 76
+#define MY_RF24_CHANNEL 125
 //#define MY_RF24_PA_LEVEL RF24_PA_HIGH
 //#define MY_DEBUG_VERBOSE_RF24
 //#define MY_RF24_DATARATE RF24_250KBPS
 
 // RFM69 radio settings
-#define MY_RADIO_RFM69
+//#define MY_RADIO_RFM69
 //#define MY_RFM69_FREQUENCY RF69_868MHZ
-#define MY_RFM69_FREQUENCY RFM69_868MHZ
-#define MY_IS_RFM69HW
-#define MY_RFM69_NEW_DRIVER
+//#define MY_RFM69_FREQUENCY RFM69_868MHZ
+//#define MY_IS_RFM69HW
+//#define MY_RFM69_NEW_DRIVER
 //#define MY_RFM69_ENABLE_ENCRYPTION
 //#define MY_RFM69_NETWORKID 100
 //#define MY_DEBUG_VERBOSE_RFM69
@@ -115,15 +116,15 @@
 // if enabled, enable the capability to power on sensors with the arduino's pins to save battery while sleeping
 #define POWER_MANAGER 0
 // if enabled, will load the battery manager library to allow the battery level to be reported automatically or on demand
-#define BATTERY_MANAGER 1
+#define BATTERY_MANAGER 0
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
-#define REMOTE_CONFIGURATION 1
+#define REMOTE_CONFIGURATION 0
 // if enabled, persist the remote configuration settings on EEPROM
 #define PERSIST 0
 // if enabled, a battery sensor will be created at BATTERY_CHILD_ID (201 by default) and will report vcc voltage together with the battery level percentage
-#define BATTERY_SENSOR 1
+#define BATTERY_SENSOR 0
 // if enabled, a signal sensor will be created at RSSI_CHILD_ID (202 by default) and will report the signal quality of the transport layer
-#define SIGNAL_SENSOR 1
+#define SIGNAL_SENSOR 0
 // if enabled, send a SLEEPING and AWAKE service messages just before entering and just after leaving a sleep cycle and STARTED when starting/rebooting
 #define SERVICE_MESSAGES 0
 

From 722e3b0b354e444fbf6c41b11c2cd3951651cdb1 Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sun, 15 Oct 2017 15:59:36 +0200
Subject: [PATCH 07/51] Moved _value into Child

---
 NodeManager.cpp | 107 +++++++++++++++++++++++++++++++++---------------
 NodeManager.h   |  29 +++++++------
 2 files changed, 92 insertions(+), 44 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 1f39b92..67edbe8 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -216,8 +216,10 @@ char* Request::getValueString() {
  */
 
 Child::Child() {
-  
+
 }
+
+// constructor
 Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
   child_id = _child_id;
   presentation = _presentation;
@@ -226,6 +228,57 @@ Child::Child(int _child_id, int _presentation, int _type, int _value_type, char*
   description = _description;
 }
 
+// setter/getter
+template<> void Child::setValue(int value) {
+  _value_int = value;
+}
+template<> void Child::setValue(float value) {
+  _value_float = value;
+}
+template<> void Child::setValue(double value) {
+  _value_double = value;
+}
+template<> void Child::setValue(char* value) {
+  _value_string = value;
+}
+template<> int Child::getValue() {
+    return _value_int;
+}
+template<> float Child::getValue() {
+    return _value_float;
+}
+template<> double Child::getValue() {
+    return _value_double;
+}
+template<> char* Child::getValue() {
+    return _value_string;
+}
+template<> void Child::setLastValue(int value) {
+  _last_value_int = value;
+}
+template<> void Child::setLastValue(float value) {
+  _last_value_float = value;
+}
+template<> void Child::setLastValue(double value) {
+  _last_value_double = value;
+}
+template<> void Child::setLastValue(char* value) {
+  _last_value_string = value;
+}
+template<> int Child::getLastValue() {
+    return _last_value_int;
+}
+template<> float Child::getLastValue() {
+    return _last_value_float;
+}
+template<> double Child::getLastValue() {
+    return _last_value_double;
+}
+template<> char* Child::getLastValue() {
+    return _last_value_string;
+}
+
+
 /*
    Sensor class
 */
@@ -311,15 +364,6 @@ void Sensor::setDoublePrecision(int value) {
 int Sensor::getInterruptPin() {
   return _interrupt_pin;
 }
-int Sensor::getValueInt() {
-  return _last_value_int;
-}
-float Sensor::getValueFloat() {
-  return _last_value_float;
-}
-char* Sensor::getValueString() {
-  return _last_value_string;
-}
 
 // After how many seconds the sensor will report back its measure
 void Sensor::setReportIntervalSeconds(int value) {
@@ -399,8 +443,7 @@ void Sensor::loop(const MyMessage & message) {
     // turn the sensor on
     if (_auto_power_pins) powerOn();
   #endif
-  
-  // FOR ALL CHILD
+  // iterates over all the children
   for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
     Child child = (*itr);
     // for numeric sensor requiring multiple samples, keep track of the total
@@ -417,32 +460,32 @@ void Sensor::loop(const MyMessage & message) {
         onLoop(child);
       }
       // for integers, floats and doubles, keep track of the total
-      if (_value_type == TYPE_INTEGER) total += (float)_value_int;
-      else if (_value_type == TYPE_FLOAT) total += _value_float;
-      else if (_value_type == TYPE_DOUBLE) total += _value_double;
+      if (child.value_type == TYPE_INTEGER) total += (float)child.getValue<int>();
+      else if (child.value_type == TYPE_FLOAT) total += child.getValue<float>();
+      else if (child.value_type == TYPE_DOUBLE) total += child.getValue<double>();
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
-    if (_value_type == TYPE_INTEGER && total > -1) {
+    if (child.value_type == TYPE_INTEGER && total > -255) {
       // if the value is an integer, calculate the average value of the samples
       int avg = (int) (total / _samples);
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(avg != _last_value_int))  {
-        _last_value_int = avg;
+      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<int>()))  {
+        child.setLastValue<int>(avg);
         _sendSensorMessage(_msg->set(avg));
-        _value_int = -1;
+        child.setValue<int>(-255);
       }
     }
     // process a float value
-    else if (_value_type == TYPE_FLOAT && total > -1) {
+    else if (_value_type == TYPE_FLOAT && total > -255) {
       // calculate the average value of the samples
       float avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != _last_value_float))  {
-        _last_value_float = avg;
+      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<float>()))  {
+        child.setLastValue<float>(avg);
         _sendSensorMessage(_msg->set(avg, _float_precision));
-        _value_float = -1;
+        child.setValue<float>(-255);
       }
     }
     // process a double value
@@ -450,19 +493,19 @@ void Sensor::loop(const MyMessage & message) {
       // calculate the average value of the samples
       double avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != _last_value_double))  {
-        _last_value_double = avg;
+      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<double>()))  {
+        child.setLastValue<double>(avg);
         _sendSensorMessage(_msg->set(avg, _double_precision));
-        _value_double = -1;
+        child.setValue<double>(-255);
       }
     }
     // process a string value
     else if (_value_type == TYPE_STRING) {
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(strcmp(_value_string, _last_value_string) != 0))  {
-        _last_value_string = _value_string;
-        _sendSensorMessage(_msg->set(_value_string));
-        _value_string = "";
+      if (_isReceive(message) || _isWorthSending(strcmp(child.getValue<char*>(), child.getLastValue<char*>()) != 0))  {
+        child.setLastValue<char*>(child.getValue<char*>());
+        _sendSensorMessage(_msg->set(child.getValue<char*>()));
+        child.setValue<char*>("");
       }
     }
   }
@@ -1328,7 +1371,7 @@ void SensorSHT21::onLoop(Child child) {
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) _value_float = temperature;
+    if (! isnan(temperature)) child.setValue<float>(temperature);
   }
   // Humidity Sensor
   else if (child.type == V_HUM) {
@@ -1342,7 +1385,7 @@ void SensorSHT21::onLoop(Child child) {
       Serial.println(humidity);
     #endif
     // store the value
-   if (! isnan(humidity)) _value_float = humidity;
+   if (! isnan(humidity)) child.setValue<float>(humidity);
   }
 }
 
diff --git a/NodeManager.h b/NodeManager.h
index 9c0b41f..edfd5b9 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -560,6 +560,8 @@ class Request {
    Sensor: generic sensor class
 */
 
+
+
 class Child {
   public:
     Child();
@@ -569,8 +571,23 @@ class Child {
     int type = V_CUSTOM;
     char* description = "";
     int value_type = TYPE_INTEGER;
+    template<typename T> void setValue(T value);
+    template<typename T> T getValue();
+    template<typename T> void setLastValue(T value);
+    template<typename T> T getLastValue();
+  private:
+    int _value_int = -255;
+    float _value_float = -255;
+    double _value_double = -255;
+    char * _value_string = "";
+    int _last_value_int = -255;
+    float _last_value_float = -255;
+    double _last_value_double = -255;
+    char * _last_value_string = "";
 };
 
+
+
 class Sensor {
   public:
     Sensor(NodeManager* node_manager, int child_id, int pin);
@@ -615,10 +632,6 @@ class Sensor {
       // [14] manually turn the power off
       void powerOff();
     #endif
-    // get the latest recorded value from the sensor
-    int getValueInt();
-    float getValueFloat();
-    char* getValueString();
     // [17] After how many minutes the sensor will report back its measure (default: 10 minutes)
     void setReportIntervalSeconds(int value);
     // [16] After how many minutes the sensor will report back its measure (default: 10 minutes)
@@ -658,14 +671,6 @@ class Sensor {
     bool _track_last_value = false;
     int _float_precision = 2;
     int _double_precision = 4;
-    int _value_int = -1;
-    float _value_float = -1;
-    double _value_double = -1;
-    double _last_value_double = -1;
-    char * _value_string = "";
-    int _last_value_int = -1;
-    float _last_value_float = -1;
-    char * _last_value_string = "";
     int _interrupt_pin = -1;
     #if POWER_MANAGER  == 1
       PowerManager _powerManager;

From 2823b05d2205ecdc38c670097eac70c140cc07ee Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sun, 15 Oct 2017 17:26:45 +0200
Subject: [PATCH 08/51] Introduced new way to register a sensor

---
 NodeManager.cpp | 266 +++++++++++++++++++++++-------------------------
 NodeManager.h   | 112 ++++++++++----------
 NodeManager.ino |   4 +-
 3 files changed, 182 insertions(+), 200 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 67edbe8..c174d61 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -283,13 +283,20 @@ template<> char* Child::getLastValue() {
    Sensor class
 */
 // constructor
-Sensor::Sensor(NodeManager* node_manager, int child_id, int pin) {
-  _node_manager = node_manager;
-  _child_id = child_id;
+Sensor::Sensor() {
+  
+}
+Sensor::Sensor(NodeManager& nodeManager, int pin) {
+  _node_manager = &nodeManager;
   _pin = pin;
   _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
+  _node_manager->registerSensor(this);
+}
+
+void Sensor::init(NodeManager* nodeManager) {
+  _node_manager = nodeManager;
 }
 
 // setter/getter
@@ -399,15 +406,15 @@ void Sensor::setInterrupt(int pin, int mode, int initial) {
 
 // present the sensor to the gateway and controller
 void Sensor::presentation() {
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    Child child = (*itr);
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
   #if DEBUG == 1
     Serial.print(F("PRES I="));
-    Serial.print(child.child_id);
+    Serial.print(child->child_id);
     Serial.print(F(" T="));
-    Serial.println(child.presentation);
+    Serial.println(child->presentation);
   #endif
-  present(child.child_id, child.presentation,child.description,_node_manager->getAck());
+  present(child->child_id, child->presentation,child->description,_node_manager->getAck());
   }
 
 }
@@ -444,8 +451,8 @@ void Sensor::loop(const MyMessage & message) {
     if (_auto_power_pins) powerOn();
   #endif
   // iterates over all the children
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    Child child = (*itr);
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
     // for numeric sensor requiring multiple samples, keep track of the total
     double total = 0;
     // collect multiple samples if needed
@@ -460,21 +467,21 @@ void Sensor::loop(const MyMessage & message) {
         onLoop(child);
       }
       // for integers, floats and doubles, keep track of the total
-      if (child.value_type == TYPE_INTEGER) total += (float)child.getValue<int>();
-      else if (child.value_type == TYPE_FLOAT) total += child.getValue<float>();
-      else if (child.value_type == TYPE_DOUBLE) total += child.getValue<double>();
+      if (child->value_type == TYPE_INTEGER) total += (float)child->getValue<int>();
+      else if (child->value_type == TYPE_FLOAT) total += child->getValue<float>();
+      else if (child->value_type == TYPE_DOUBLE) total += child->getValue<double>();
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
-    if (child.value_type == TYPE_INTEGER && total > -255) {
+    if (child->value_type == TYPE_INTEGER && total > -255) {
       // if the value is an integer, calculate the average value of the samples
       int avg = (int) (total / _samples);
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<int>()))  {
-        child.setLastValue<int>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<int>()))  {
+        child->setLastValue<int>(avg);
         _sendSensorMessage(_msg->set(avg));
-        child.setValue<int>(-255);
+        child->setValue<int>(-255);
       }
     }
     // process a float value
@@ -482,10 +489,10 @@ void Sensor::loop(const MyMessage & message) {
       // calculate the average value of the samples
       float avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<float>()))  {
-        child.setLastValue<float>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<float>()))  {
+        child->setLastValue<float>(avg);
         _sendSensorMessage(_msg->set(avg, _float_precision));
-        child.setValue<float>(-255);
+        child->setValue<float>(-255);
       }
     }
     // process a double value
@@ -493,19 +500,19 @@ void Sensor::loop(const MyMessage & message) {
       // calculate the average value of the samples
       double avg = total / _samples;
       // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child.getLastValue<double>()))  {
-        child.setLastValue<double>(avg);
+      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<double>()))  {
+        child->setLastValue<double>(avg);
         _sendSensorMessage(_msg->set(avg, _double_precision));
-        child.setValue<double>(-255);
+        child->setValue<double>(-255);
       }
     }
     // process a string value
     else if (_value_type == TYPE_STRING) {
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(strcmp(child.getValue<char*>(), child.getLastValue<char*>()) != 0))  {
-        child.setLastValue<char*>(child.getValue<char*>());
-        _sendSensorMessage(_msg->set(child.getValue<char*>()));
-        child.setValue<char*>("");
+      if (_isReceive(message) || _isWorthSending(strcmp(child->getValue<char*>(), child->getLastValue<char*>()) != 0))  {
+        child->setLastValue<char*>(child->getValue<char*>());
+        _sendSensorMessage(_msg->set(child->getValue<char*>()));
+        child->setValue<char*>("");
       }
     }
   }
@@ -573,6 +580,14 @@ void Sensor::process(Request & request) {
   _sendServiceMessage(_msg->set(function));
 }
 
+// virtual functions
+void Sensor::onBefore(){}
+void Sensor::onSetup(){}
+void Sensor::onLoop(Child* child){}
+void Sensor::onReceive(const MyMessage & message){}
+void Sensor::onProcess(Request & request){}
+void Sensor::onInterrupt(){}
+
 // send a message to the network
 void Sensor::_sendSensorMessage(MyMessage & message) {
 	// setup the message
@@ -647,7 +662,7 @@ void SensorAnalogInput::onSetup() {
 }
 
 // what to do during loop
-void SensorAnalogInput::onLoop(Child child) {
+void SensorAnalogInput::onLoop(Child* child) {
   // read the input
   int adc = _getAnalogRead();
   // calculate the percentage
@@ -768,7 +783,7 @@ void SensorThermistor::onSetup() {
 }
 
 // what to do during loop
-void SensorThermistor::onLoop(Child child) {
+void SensorThermistor::onLoop(Child* child) {
   // read the voltage across the thermistor
   float adc = analogRead(_pin);
   // calculate the temperature
@@ -840,7 +855,7 @@ void SensorML8511::onSetup() {
 }
 
 // what to do during loop
-void SensorML8511::onLoop(Child child) {
+void SensorML8511::onLoop(Child* child) {
   // read the voltage 
   int uvLevel = analogRead(_pin);
   int refLevel = _node_manager->getVcc()*1024/3.3;
@@ -909,7 +924,7 @@ void SensorACS712::onSetup() {
 }
 
 // what to do during loop
-void SensorACS712::onLoop(Child child) {
+void SensorACS712::onLoop(Child* child) {
   int value = analogRead(_pin);
   // convert the analog read in mV
   double voltage = (value / 1024.0) * 5000; 
@@ -995,7 +1010,7 @@ void SensorDigitalInput::onSetup() {
 }
 
 // what to do during loop
-void SensorDigitalInput::onLoop(Child child) {
+void SensorDigitalInput::onLoop(Child* child) {
   // read the value
   int value = digitalRead(_pin);
   #if DEBUG == 1
@@ -1065,7 +1080,7 @@ void SensorDigitalOutput::setWaitAfterSet(int value) {
 }
 
 // main task
-void SensorDigitalOutput::onLoop(Child child) {
+void SensorDigitalOutput::onLoop(Child* child) {
   // set the value to -1 so to avoid reporting to the gateway during loop
   _value_int = -1;
   _last_value_int = -1;
@@ -1290,7 +1305,7 @@ void SensorDHT::onSetup() {
 }
 
 // what to do during loop
-void SensorDHT::onLoop(Child child) {
+void SensorDHT::onLoop(Child* child) {
   _node_manager->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
@@ -1341,13 +1356,14 @@ void SensorDHT::onInterrupt() {
 */
 #if MODULE_SHT21 == 1
 // contructor
-SensorSHT21::SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager,child_id,A2) {
-  _children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  _children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
+
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
+  children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   // initialize the library
   Wire.begin();
 }
@@ -1357,43 +1373,43 @@ void SensorSHT21::onSetup() {
 }
 
 // what to do during loop
-void SensorSHT21::onLoop(Child child) {
+void SensorSHT21::onLoop(Child* child) {
   // temperature sensor
-  if (child.type == V_TEMP) {
+  if (child->type == V_TEMP) {
     // read the temperature
     float temperature = SHT2x.GetTemperature();
     // convert it
     temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("SHT I="));
-      Serial.print(child.child_id);
+      Serial.print(child->child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) child.setValue<float>(temperature);
+    if (! isnan(temperature)) child->setValue<float>(temperature);
   }
   // Humidity Sensor
-  else if (child.type == V_HUM) {
+  else if (child->type == V_HUM) {
     // read humidity
     float humidity = SHT2x.GetHumidity();
     if (isnan(humidity)) return;
     #if DEBUG == 1
       Serial.print(F("SHT I="));
-      Serial.print(child.child_id);
+      Serial.print(child->child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
     #endif
     // store the value
-   if (! isnan(humidity)) child.setValue<float>(humidity);
+   if (! isnan(humidity)) child->setValue<float>(humidity);
   }
 }
 
 // what to do as the main task when receiving a message
 void SensorSHT21::onReceive(const MyMessage & message) {
-  for (List<Child>::iterator itr = _children.begin(); itr != _children.end(); ++itr) {
-    Child child = (*itr);
-    if (message.getCommand() == C_REQ && child.child_id == message.sensor) onLoop(child);
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
+    if (message.getCommand() == C_REQ && child->child_id == message.sensor) onLoop(child);
   }
 }
 
@@ -1411,7 +1427,7 @@ void SensorSHT21::onInterrupt() {
  */
  #if MODULE_SHT21 == 1
 // constructor
-SensorHTU21D::SensorHTU21D(NodeManager* node_manager, int child_id, int pin): SensorSHT21(node_manager, child_id, pin) {
+SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
 }
 #endif 
 
@@ -1450,7 +1466,7 @@ void SensorSwitch::onSetup() {
 }
 
 // what to do during loop
-void SensorSwitch::onLoop(Child child) {
+void SensorSwitch::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
@@ -1539,7 +1555,7 @@ void SensorDs18b20::onSetup() {
 }
 
 // what to do during loop
-void SensorDs18b20::onLoop(Child child) {
+void SensorDs18b20::onLoop(Child* child) {
   // do not wait for conversion, will sleep manually during it
   if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
   // request the temperature
@@ -1630,7 +1646,7 @@ void SensorBH1750::onSetup() {
 }
 
 // what to do during loop
-void SensorBH1750::onLoop(Child child) {
+void SensorBH1750::onLoop(Child* child) {
   // request the light level
   _value_int = _lightSensor->readLightLevel();
   #if DEBUG == 1
@@ -1687,7 +1703,7 @@ void SensorMLX90614::onSetup() {
 }
 
 // what to do during loop
-void SensorMLX90614::onLoop(Child child) {
+void SensorMLX90614::onLoop(Child* child) {
   float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -1764,7 +1780,7 @@ void SensorBosch::onSetup() {
 }
 
 // what to do during loop
-void SensorBosch::onLoop(Child child) {
+void SensorBosch::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
@@ -1903,7 +1919,7 @@ SensorBME280::SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME
   _bme = bme;
 }
 
-void SensorBME280::onLoop(Child child) {
+void SensorBME280::onLoop(Child* child) {
   // temperature sensor
   if (_sensor_type == SensorBME280::TEMPERATURE) {
     // read the temperature
@@ -1967,7 +1983,7 @@ SensorBMP085::SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP
 }
 
 // what to do during loop
-void SensorBMP085::onLoop(Child child) {
+void SensorBMP085::onLoop(Child* child) {
   // temperature sensor
   if (_sensor_type == SensorBMP085::TEMPERATURE) {
     // read the temperature
@@ -2014,7 +2030,7 @@ SensorBMP280::SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP
   _bmp = bmp;
 }
 
-void SensorBMP280::onLoop(Child child) {
+void SensorBMP280::onLoop(Child* child) {
   // temperature sensor
   if (_sensor_type == SensorBMP280::TEMPERATURE) {
     // read the temperature
@@ -2089,7 +2105,7 @@ void SensorHCSR04::onSetup() {
 }
 
 // what to do during loop
-void SensorHCSR04::onLoop(Child child) {
+void SensorHCSR04::onLoop(Child* child) {
   int distance = _node_manager->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
   #if DEBUG == 1
     Serial.print(F("HC I="));
@@ -2164,7 +2180,7 @@ void SensorSonoff::onSetup() {
 }
 
 // what to do during loop
-void SensorSonoff::onLoop(Child child) {
+void SensorSonoff::onLoop(Child* child) {
   _debouncer.update();
   // Get the update value from the button
   int value = _debouncer.read();
@@ -2257,7 +2273,7 @@ void SensorMCP9808::onSetup() {
 }
 
 // what to do during loop
-void SensorMCP9808::onLoop(Child child) {
+void SensorMCP9808::onLoop(Child* child) {
   float temperature = _mcp->readTempC();
   // convert it
   temperature = _node_manager->celsiusToFahrenheit(temperature);
@@ -2350,7 +2366,7 @@ void SensorMQ::onSetup() {
 }
 
 // what to do during loop
-void SensorMQ::onLoop(Child child) {
+void SensorMQ::onLoop(Child* child) {
   if (_pin == -1) return;
   // calculate rs/ro
   float mq = _MQRead()/_ro;
@@ -2490,7 +2506,7 @@ void SensorMHZ19::onSetup() {
 }
 
 // what to do during loop
-void SensorMHZ19::onLoop(Child child) {
+void SensorMHZ19::onLoop(Child* child) {
   // Read the ppm value
   int co2ppm = readCO2(); // This is there the function gets called that talks to the Co2 sensor.
   #if DEBUG == 1
@@ -2594,7 +2610,7 @@ void SensorAM2320::onSetup() {
 }
 
 // what do to during loop
-void SensorAM2320::onLoop(Child child) {
+void SensorAM2320::onLoop(Child* child) {
   switch(_th->Read()) {
     case 0:
       // temperature sensor
@@ -2712,7 +2728,7 @@ void SensorTSL2561::onSetup() {
 }
 
 // what do to during loop
-void SensorTSL2561::onLoop(Child child) {
+void SensorTSL2561::onLoop(Child* child) {
   // request the light level
    switch (_tsl_spectrum) {
     case SensorTSL2561::VISIBLE:
@@ -2807,7 +2823,7 @@ void SensorPT100::onSetup() {
 }
 
 // what to do during loop
-void SensorPT100::onLoop(Child child) {
+void SensorPT100::onLoop(Child* child) {
   // read the PT100 sensor
   int temperature = _PT100->readTemperature(_pin);  
   #if DEBUG == 1
@@ -2873,7 +2889,7 @@ void SensorDimmer::onSetup() {
 }
 
 // what to do during loop
-void SensorDimmer::onLoop(Child child) {
+void SensorDimmer::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
@@ -2973,7 +2989,7 @@ void SensorPulseMeter::onSetup() {
 }
 
 // what to do during loop
-void SensorPulseMeter::onLoop(Child child) {
+void SensorPulseMeter::onLoop(Child* child) {
   // do not report anything if called by an interrupt
   if (_node_manager->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
@@ -3235,17 +3251,17 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
   #if MODULE_SHT21 == 1
     else if (sensor_type == SENSOR_SHT21) {
       // register temperature sensor
-      registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
+      //registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
       // register humidity sensor
       //child_id = _getAvailableChildId();
       //return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
     }
     else if (sensor_type == SENSOR_HTU21D) {
       // register temperature sensor
-      registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::TEMPERATURE));
+      //registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::TEMPERATURE));
       // register humidity sensor
       child_id = _getAvailableChildId();
-      return registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::HUMIDITY));
+//      return registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::HUMIDITY));
     }
   #endif
   #if MODULE_SWITCH == 1
@@ -3406,8 +3422,13 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
   };
 }
 
+void NodeManager::registerSensor(Sensor* sensor) {
+  sensors.push(*sensor);
+}
+
+/*
 // attach a built-in or custom sensor to this manager
-int NodeManager::registerSensor(Sensor* sensor) {
+int NodeManager::registerSensorOLD(Sensor* sensor) {
   if (sensor->getChildId() > MAX_SENSORS) return;
   #if DEBUG == 1
     Serial.print(F("REG I="));
@@ -3428,37 +3449,7 @@ int NodeManager::registerSensor(Sensor* sensor) {
   // return the child_id
   return sensor->getChildId();
 }
-
-// un-register a sensor to this manager
-void NodeManager::unRegisterSensor(int sensor_index) {
-  if (sensor_index > MAX_SENSORS) return;
-  // unlink the pointer to this sensor
-  _sensors[sensor_index] == 0;
-}
-
-// return a sensor given its index
-Sensor* NodeManager::get(int child_id) {
-  if (child_id > MAX_SENSORS) return 0;
-  // return a pointer to the sensor from the given child_id
-  return _sensors[child_id];
-}
-Sensor* NodeManager::getSensor(int child_id) {
-  return get(child_id);
-}
-
-// assign a different child id to a sensor'
-bool NodeManager::renameSensor(int old_child_id, int new_child_id) {
-  if (old_child_id > MAX_SENSORS || new_child_id > MAX_SENSORS) return;
-  // ensure the old id exists and the new is available
-  if (_sensors[old_child_id] == 0 || _sensors[new_child_id] != 0) return false;
-  // assign the sensor to new id
-  _sensors[new_child_id] = _sensors[old_child_id];
-  // set the new child id
-  _sensors[new_child_id]->setChildId(new_child_id);
-  // free up the old id
-  _sensors[old_child_id] = 0;
-  return true;
-}
+*/
 
 // setup NodeManager
 void NodeManager::before() {
@@ -3512,12 +3503,12 @@ void NodeManager::before() {
     _signal_report_timer.start();
   #endif
   // setup individual sensors
-  for (int i = 1; i <= MAX_SENSORS; i++) {
-    if (_sensors[i] == 0) continue;
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
     // configure reporting interval
-    if (! _sensors[i]->isReportIntervalConfigured()) _sensors[i]->setReportIntervalSeconds(_report_interval_seconds);
+    if (! sensor->isReportIntervalConfigured()) sensor->setReportIntervalSeconds(_report_interval_seconds);
     // call each sensor's before()
-    _sensors[i]->before();
+    sensor->before();
   }
   // setup the interrupt pins
   setupInterrupts();
@@ -3546,11 +3537,11 @@ void NodeManager::presentation() {
     signalReport();
   #endif
   // present each sensor
-  for (int i = 1; i <= MAX_SENSORS; i++) {
-    if (_sensors[i] == 0) continue;
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
     // call each sensor's presentation()
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
-    _sensors[i]->presentation();
+    sensor->presentation();
   }
   #if DEBUG == 1
     Serial.println(F("READY"));
@@ -3573,10 +3564,10 @@ void NodeManager::setup() {
 	_sendUsingConfigChild(_msg.set("STARTED"));
   #endif
   // run setup for all the registered sensors
-  for (int i = 1; i <= MAX_SENSORS; i++) {
-    if (_sensors[i] == 0) continue;
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
     // call each sensor's setup()
-    _sensors[i]->setup();
+    sensor->setup();
   }
 }
 
@@ -3609,21 +3600,20 @@ void NodeManager::loop() {
     if (_auto_power_pins) powerOn();
   #endif
   // run loop for all the registered sensors
-  for (int i = 1; i <= MAX_SENSORS; i++) {
-    // skip unconfigured sensors
-    if (_sensors[i] == 0) continue;
-    if (_last_interrupt_pin != -1 && _sensors[i]->getInterruptPin() == _last_interrupt_pin) {
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
+    if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
       _msg.clear();
-      _sensors[i]->interrupt();
-      _sensors[i]->loop(_msg);
+      sensor->interrupt();
+      sensor->loop(_msg);
         // reset the last interrupt pin
       _last_interrupt_pin = -1;
     }
     else if (_last_interrupt_pin == -1) {
       // if just at the end of a cycle, call the sensor's loop() 
       _msg.clear();
-      _sensors[i]->loop(_msg);
+      sensor->loop(_msg);
     }
   }
   #if POWER_MANAGER == 1
@@ -3658,17 +3648,23 @@ void NodeManager::receive(const MyMessage &message) {
     #endif
   }
   // dispatch the message to the registered sensor
-  else if (message.sensor <= MAX_SENSORS && _sensors[message.sensor] != 0) {
-    #if POWER_MANAGER == 1
-      // turn on the pin powering all the sensors
-      if (_auto_power_pins) powerOn();
-    #endif
-    // call the sensor's receive()
-     _sensors[message.sensor]->receive(message);
-    #if POWER_MANAGER == 1
-      // turn off the pin powering all the sensors
-      if (_auto_power_pins) powerOff();
-    #endif
+  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = itr;
+    for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
+      Child* child = itr1;
+      if (message.sensor == child->child_id) {
+        #if POWER_MANAGER == 1
+          // turn on the pin powering all the sensors
+          if (_auto_power_pins) powerOn();
+        #endif
+        // call the sensor's receive()
+        sensor->receive(message);
+        #if POWER_MANAGER == 1
+          // turn off the pin powering all the sensors
+          if (_auto_power_pins) powerOff();
+        #endif
+      }
+    }
   }
 }
 
@@ -3753,7 +3749,6 @@ void NodeManager::process(Request & request) {
       case 24: powerOn(); break;
       case 25: powerOff(); break;
     #endif
-    case 26: unRegisterSensor(request.getValueInt()); break;
     case 27: saveToMemory(0,request.getValueInt()); break;
     case 28: setInterruptMinDelta(request.getValueInt()); break;
     case 30: setSleepOrWait(request.getValueInt()); break;
@@ -4140,13 +4135,10 @@ void NodeManager::_present(int child_id, int type) {
 
 // return the next available child_id
 int NodeManager::_getAvailableChildId() {
-  for (int i = 1; i <= MAX_SENSORS; i++) {
-    if (i == CONFIGURATION_CHILD_ID) continue;
-    if (i == BATTERY_CHILD_ID) continue;
-    // empty place, return it
-    if (_sensors[i] == 0) return i;
-  }
-  return MAX_SENSORS;
+  _child_id_counter++;
+  if (_child_id_counter == CONFIGURATION_CHILD_ID) _child_id_counter++;
+  if (_child_id_counter == BATTERY_CHILD_ID) _child_id_counter++;
+  return _child_id_counter;
 }
 
 // guess the initial value of a digital output based on the configured interrupt mode
diff --git a/NodeManager.h b/NodeManager.h
index edfd5b9..e303107 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -102,11 +102,6 @@
 #ifndef SIGNAL_CHILD_ID
   #define SIGNAL_CHILD_ID 202
 #endif
-// define the maximum number of sensors that can be managed
-#ifndef MAX_SENSORS
-  #define MAX_SENSORS 10
-#endif
-// define the maximum number of children that a sensor can have
 // define default sketch name and version
 #ifndef SKETCH_NAME
   #define SKETCH_NAME "NodeManager"
@@ -444,6 +439,10 @@ template<typename T> class List {
     --_endPosition;
     if (_allocBlocks > _preAllocBlocks) _DeAllocOneBlock(false);
   }
+  T get(int position) {
+    if (position > _endPosition) position = _endPosition;
+    return _internalArray[position];
+  }
   inline iterator begin() { return _internalArray; }
   inline iterator end() { return _internalArray + _endPosition; }
   inline bool empty() { return (_endPosition == 0); }
@@ -557,11 +556,9 @@ class Request {
 };
 
 /***************************************
-   Sensor: generic sensor class
+   Child: child class
 */
 
-
-
 class Child {
   public:
     Child();
@@ -586,11 +583,15 @@ class Child {
     char * _last_value_string = "";
 };
 
-
+/***************************************
+   Sensor: generic sensor class
+*/
 
 class Sensor {
   public:
-    Sensor(NodeManager* node_manager, int child_id, int pin);
+    Sensor();
+    Sensor(NodeManager& nodeManager, int pin);
+    void init(NodeManager* nodeManager);
     // [1] where the sensor is attached to (default: not set)
     void setPin(int value);
     int getPin();
@@ -656,12 +657,13 @@ class Sensor {
     virtual void interrupt();
     virtual void receive(const MyMessage & message);
     // abstract functions, subclasses need to implement
-    virtual void onBefore() = 0;
-    virtual void onSetup() = 0;
-    virtual void onLoop(Child child) = 0;
-    virtual void onReceive(const MyMessage & message) = 0;
-    virtual void onProcess(Request & request) = 0;
-    virtual void onInterrupt() = 0;
+    virtual void onBefore();
+    virtual void onSetup();
+    virtual void onLoop(Child* child);
+    virtual void onReceive(const MyMessage & message);
+    virtual void onProcess(Request & request);
+    virtual void onInterrupt();
+    List<Child> children;
   protected:
     MyMessage* _msg;
     NodeManager* _node_manager;
@@ -687,7 +689,6 @@ class Sensor {
     int _type = V_CUSTOM;
     char* _description = "";
     int _value_type = TYPE_INTEGER;
-    List<Child> _children;
 };
 
 #if MODULE_ANALOG_INPUT == 1
@@ -710,7 +711,7 @@ class SensorAnalogInput: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -751,7 +752,7 @@ class SensorThermistor: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -773,7 +774,7 @@ class SensorML8511: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -795,7 +796,7 @@ class SensorACS712: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -832,7 +833,7 @@ class SensorDigitalInput: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -863,7 +864,7 @@ class SensorDigitalOutput: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -921,7 +922,7 @@ class SensorDHT: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -942,22 +943,17 @@ class SensorDHT: public Sensor {
 #if MODULE_SHT21 == 1
 class SensorSHT21: public Sensor {
   public:
-    SensorSHT21(NodeManager* node_manager, int child_id, int sensor_type);
+    SensorSHT21(NodeManager& nodeManager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
     // constants
     const static int TEMPERATURE = 0;
     const static int HUMIDITY = 1;
-    enum children
-    {
-        temperature,
-        humidity,
-    };
   protected:
     float _offset = 0;
     int _sensor_type = 0;
@@ -969,7 +965,7 @@ class SensorSHT21: public Sensor {
 
 class SensorHTU21D: public SensorSHT21 {
   public:
-    SensorHTU21D(NodeManager* node_manager, int child_id, int pin);
+    SensorHTU21D(NodeManager& nodeManager);
 };
 #endif
 
@@ -991,7 +987,7 @@ class SensorSwitch: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1036,7 +1032,7 @@ class SensorDs18b20: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1061,7 +1057,7 @@ class SensorBH1750: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1080,7 +1076,7 @@ class SensorMLX90614: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1107,7 +1103,7 @@ class SensorBosch: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1139,7 +1135,7 @@ class SensorBosch: public Sensor {
 class SensorBME280: public SensorBosch {
   public:
     SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME280* bme, int sensor_type);
-    void onLoop(Child child);
+    void onLoop(Child* child);
   protected:
     Adafruit_BME280* _bme;
 };
@@ -1152,7 +1148,7 @@ class SensorBME280: public SensorBosch {
 class SensorBMP085: public SensorBosch {
   public:
     SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP085* bmp, int sensor_type);
-    void onLoop(Child child);
+    void onLoop(Child* child);
   protected:
     Adafruit_BMP085* _bmp;
 };
@@ -1165,7 +1161,7 @@ class SensorBMP085: public SensorBosch {
 class SensorBMP280: public SensorBosch {
   public:
     SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP280* bmp, int sensor_type);
-    void onLoop(Child child);
+    void onLoop(Child* child);
   protected:
     Adafruit_BMP280* _bmp;
 };
@@ -1187,7 +1183,7 @@ class SensorHCSR04: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1215,7 +1211,7 @@ class SensorSonoff: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1245,7 +1241,7 @@ class SensorMCP9808: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1286,7 +1282,7 @@ class SensorMQ: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1329,7 +1325,7 @@ class SensorMHZ19: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1350,7 +1346,7 @@ class SensorAM2320: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1381,7 +1377,7 @@ class SensorTSL2561: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1419,7 +1415,7 @@ class SensorPT100: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1453,7 +1449,7 @@ class SensorDimmer: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1482,7 +1478,7 @@ class SensorPulseMeter: public Sensor {
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
-    void onLoop(Child child);
+    void onLoop(Child* child);
     void onReceive(const MyMessage & message);
     void onProcess(Request & request);
     void onInterrupt();
@@ -1573,14 +1569,7 @@ class NodeManager {
     // register a built-in sensor
     int registerSensor(int sensor_type, int pin = -1, int child_id = -1);
     // register a custom sensor
-    int registerSensor(Sensor* sensor);
-    // [26] un-register a sensor
-    void unRegisterSensor(int sensor_index);
-    // return a sensor by its index
-    Sensor* get(int sensor_index);
-    Sensor* getSensor(int sensor_index);
-    // assign a different child id to a sensor
-    bool renameSensor(int old_child_id, int new_child_id);
+    void registerSensor(Sensor* sensor);
     #if POWER_MANAGER == 1
       // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
       void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
@@ -1667,8 +1656,9 @@ class NodeManager {
     // handle interrupts
     static void _onInterrupt_1();
     static void _onInterrupt_2();
-	MyMessage* getMessage();
-	void sendMessage();
+	  MyMessage* getMessage();
+	  void sendMessage();
+    List<Sensor> sensors;
   private:
     #if BATTERY_MANAGER == 1
       float _battery_min = 2.6;
@@ -1706,7 +1696,6 @@ class NodeManager {
     static long _last_interrupt_1;
     static long _last_interrupt_2;
     long _timestamp = -1;
-    Sensor* _sensors[MAX_SENSORS+1] = {0};
     bool _ack = false;
     void _sleep();
     void _present(int child_id, int type);
@@ -1719,6 +1708,7 @@ class NodeManager {
     int _reboot_pin = -1;
     void _loadConfig();
     void _saveConfig();
+    int _child_id_counter = 0;
 };
 
 #endif
diff --git a/NodeManager.ino b/NodeManager.ino
index 01a1394..94d602b 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -24,6 +24,7 @@ Documentation available on: https://github.com/mysensors/NodeManager
 
 // create a NodeManager instance
 NodeManager nodeManager;
+SensorSHT21 sht(nodeManager);
 
 // before
 void before() {
@@ -37,8 +38,7 @@ void before() {
     digitalWrite(4, HIGH);
     pinMode(5, OUTPUT);
     digitalWrite(5, LOW);
-
-  nodeManager.registerSensor(SENSOR_SHT21);
+    
   nodeManager.setReportIntervalSeconds(20);
   
   

From dd75bf5b07f160bfb85336f03955bc4c9f7fe976 Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sun, 15 Oct 2017 19:17:45 +0200
Subject: [PATCH 09/51] Debugging onBefore() not working

---
 NodeManager.cpp | 38 +++++++++++++++++++++++++++-----------
 NodeManager.h   | 17 +++++++----------
 NodeManager.ino |  7 +++++--
 3 files changed, 39 insertions(+), 23 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index c174d61..80d8693 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -292,11 +292,7 @@ Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
-  _node_manager->registerSensor(this);
-}
-
-void Sensor::init(NodeManager* nodeManager) {
-  _node_manager = nodeManager;
+  //_node_manager->registerSensor(this);
 }
 
 // setter/getter
@@ -423,6 +419,17 @@ void Sensor::presentation() {
 void Sensor::before() {
   if (_pin == -1) return;
   onBefore();
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
+    #if DEBUG == 1
+      Serial.print(F("CHILD I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" P="));
+      Serial.print(child->presentation);
+      Serial.print(F(" T="));
+      Serial.println(child->type);
+    #endif
+  }
 }
 
 // call the sensor-specific implementation of setup
@@ -581,7 +588,9 @@ void Sensor::process(Request & request) {
 }
 
 // virtual functions
-void Sensor::onBefore(){}
+void Sensor::onBefore(){
+  Serial.println("NO");
+}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
 void Sensor::onReceive(const MyMessage & message){}
@@ -1357,11 +1366,14 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-
+     children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
+  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,"")); 
+  _node_manager->registerSensor(this);
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
+  Serial.println("SHT");
   children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
   children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   // initialize the library
@@ -3212,6 +3224,7 @@ bool NodeManager::isSleepingNode() {
   return false;
 }
 
+/*
 // register a sensor to this manager
 int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
   // get a child_id if not provided by the user
@@ -3421,10 +3434,9 @@ int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
     return -1;
   };
 }
+/*
+
 
-void NodeManager::registerSensor(Sensor* sensor) {
-  sensors.push(*sensor);
-}
 
 /*
 // attach a built-in or custom sensor to this manager
@@ -3451,6 +3463,10 @@ int NodeManager::registerSensorOLD(Sensor* sensor) {
 }
 */
 
+void NodeManager::registerSensor(Sensor* sensor) {
+  sensors.push(sensor);
+}
+
 // setup NodeManager
 void NodeManager::before() {
   // print out the version
@@ -3648,7 +3664,7 @@ void NodeManager::receive(const MyMessage &message) {
     #endif
   }
   // dispatch the message to the registered sensor
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = itr;
     for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
       Child* child = itr1;
diff --git a/NodeManager.h b/NodeManager.h
index e303107..c69cedd 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -591,7 +591,6 @@ class Sensor {
   public:
     Sensor();
     Sensor(NodeManager& nodeManager, int pin);
-    void init(NodeManager* nodeManager);
     // [1] where the sensor is attached to (default: not set)
     void setPin(int value);
     int getPin();
@@ -650,12 +649,12 @@ class Sensor {
     // listen for interrupts on the given pin so interrupt() will be called when occurring
     void setInterrupt(int pin, int mode, int initial);
     // define what to do at each stage of the sketch
-    virtual void before();
-    virtual void presentation();
-    virtual void setup();
-    virtual void loop(const MyMessage & message);
-    virtual void interrupt();
-    virtual void receive(const MyMessage & message);
+    void before();
+    void presentation();
+    void setup();
+    void loop(const MyMessage & message);
+    void interrupt();
+    void receive(const MyMessage & message);
     // abstract functions, subclasses need to implement
     virtual void onBefore();
     virtual void onSetup();
@@ -1566,8 +1565,6 @@ class NodeManager {
     // [20] optionally sleep interval in milliseconds before sending each message to the radio network (default: 0)
     void setSleepBetweenSend(int value);
     int getSleepBetweenSend();
-    // register a built-in sensor
-    int registerSensor(int sensor_type, int pin = -1, int child_id = -1);
     // register a custom sensor
     void registerSensor(Sensor* sensor);
     #if POWER_MANAGER == 1
@@ -1658,7 +1655,7 @@ class NodeManager {
     static void _onInterrupt_2();
 	  MyMessage* getMessage();
 	  void sendMessage();
-    List<Sensor> sensors;
+    List<Sensor*> sensors;
   private:
     #if BATTERY_MANAGER == 1
       float _battery_min = 2.6;
diff --git a/NodeManager.ino b/NodeManager.ino
index 94d602b..2c58104 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -1,4 +1,3 @@
-
 /*
 NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, speeding up the development cycle of your projects.
 NodeManager includes the following main components:
@@ -24,12 +23,16 @@ Documentation available on: https://github.com/mysensors/NodeManager
 
 // create a NodeManager instance
 NodeManager nodeManager;
-SensorSHT21 sht(nodeManager);
+
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);  
+SensorSHT21 sht(nodeManager);
+
+
+
 
   /*
    * Register below your sensors

From 627bcc33d3039926311c0a5bfb301d86c86d078e Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sun, 15 Oct 2017 19:31:41 +0200
Subject: [PATCH 10/51] SensorSHT21 fully working

---
 NodeManager.cpp | 31 +++++++++++++++----------------
 NodeManager.h   |  1 +
 NodeManager.ino |  4 ++--
 3 files changed, 18 insertions(+), 18 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 80d8693..47776dc 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -292,7 +292,7 @@ Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
-  //_node_manager->registerSensor(this);
+  _node_manager->registerSensor(this);
 }
 
 // setter/getter
@@ -422,7 +422,8 @@ void Sensor::before() {
   for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = itr;
     #if DEBUG == 1
-      Serial.print(F("CHILD I="));
+      Serial.print(_name);
+      Serial.print(F(" I="));
       Serial.print(child->child_id);
       Serial.print(F(" P="));
       Serial.print(child->presentation);
@@ -1366,14 +1367,11 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-     children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,"")); 
-  _node_manager->registerSensor(this);
+  _name = "SHT";
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  Serial.println("SHT");
   children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
   children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
   // initialize the library
@@ -1393,7 +1391,8 @@ void SensorSHT21::onLoop(Child* child) {
     // convert it
     temperature = _node_manager->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(F("SHT I="));
+      Serial.print(_name);
+      Serial.print(F(" I="));
       Serial.print(child->child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
@@ -3519,8 +3518,8 @@ void NodeManager::before() {
     _signal_report_timer.start();
   #endif
   // setup individual sensors
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
     // configure reporting interval
     if (! sensor->isReportIntervalConfigured()) sensor->setReportIntervalSeconds(_report_interval_seconds);
     // call each sensor's before()
@@ -3553,8 +3552,8 @@ void NodeManager::presentation() {
     signalReport();
   #endif
   // present each sensor
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
     // call each sensor's presentation()
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
     sensor->presentation();
@@ -3580,8 +3579,8 @@ void NodeManager::setup() {
 	_sendUsingConfigChild(_msg.set("STARTED"));
   #endif
   // run setup for all the registered sensors
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
     // call each sensor's setup()
     sensor->setup();
   }
@@ -3616,8 +3615,8 @@ void NodeManager::loop() {
     if (_auto_power_pins) powerOn();
   #endif
   // run loop for all the registered sensors
-  for (List<Sensor>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
     if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
       _msg.clear();
@@ -3665,7 +3664,7 @@ void NodeManager::receive(const MyMessage &message) {
   }
   // dispatch the message to the registered sensor
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = itr;
+    Sensor* sensor = *itr;
     for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
       Child* child = itr1;
       if (message.sensor == child->child_id) {
diff --git a/NodeManager.h b/NodeManager.h
index c69cedd..0350e6f 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -664,6 +664,7 @@ class Sensor {
     virtual void onInterrupt();
     List<Child> children;
   protected:
+    char* _name = "";
     MyMessage* _msg;
     NodeManager* _node_manager;
     int _pin = -1;
diff --git a/NodeManager.ino b/NodeManager.ino
index 2c58104..a0e08f6 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -23,13 +23,13 @@ Documentation available on: https://github.com/mysensors/NodeManager
 
 // create a NodeManager instance
 NodeManager nodeManager;
-
+SensorSHT21 sht(nodeManager);
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);  
-SensorSHT21 sht(nodeManager);
+
 
 
 

From c92e7b176d3dbf0cac82cd805bd23aa48f9b0e78 Mon Sep 17 00:00:00 2001
From: user2684 <user2684@users.noreply.github.com>
Date: Sat, 21 Oct 2017 19:25:05 +0200
Subject: [PATCH 11/51] Added helper functions

---
 NodeManager.cpp | 96 ++++++++++++++++++++++++++++++-------------------
 NodeManager.h   |  7 ++--
 NodeManager.ino |  3 +-
 3 files changed, 66 insertions(+), 40 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 47776dc..d0f3adb 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -220,7 +220,7 @@ Child::Child() {
 }
 
 // constructor
-Child::Child(int _child_id, int _presentation, int _type, int _value_type, char* _description) {
+Child::Child(int _child_id, int _presentation, int _type, int _value_type = TYPE_INTEGER, char* _description = "") {
   child_id = _child_id;
   presentation = _presentation;
   type = _type;
@@ -286,6 +286,7 @@ template<> char* Child::getLastValue() {
 Sensor::Sensor() {
   
 }
+
 Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _node_manager = &nodeManager;
   _pin = pin;
@@ -588,10 +589,17 @@ void Sensor::process(Request & request) {
   _sendServiceMessage(_msg->set(function));
 }
 
-// virtual functions
-void Sensor::onBefore(){
-  Serial.println("NO");
+// return the requested child 
+Child* Sensor::getChild(int child_id) {
+  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = itr;
+    if (child->child_id == child_id) return child;
+  }
+  return nullptr;
 }
+
+// virtual functions
+void Sensor::onBefore() {}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
 void Sensor::onReceive(const MyMessage & message){}
@@ -1367,13 +1375,13 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-  _name = "SHT";
+  _name = F("SHT");
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  children.push(Child(1,S_TEMP,V_TEMP,TYPE_FLOAT,""));
-  children.push(Child(2,S_HUM,V_HUM,TYPE_FLOAT,""));
+  children.push(Child(_node_manager->getAvailableChildId(),S_TEMP,V_TEMP,TYPE_FLOAT));
+  children.push(Child(_node_manager->getAvailableChildId(),S_HUM,V_HUM,TYPE_FLOAT));
   // initialize the library
   Wire.begin();
 }
@@ -1406,7 +1414,8 @@ void SensorSHT21::onLoop(Child* child) {
     float humidity = SHT2x.GetHumidity();
     if (isnan(humidity)) return;
     #if DEBUG == 1
-      Serial.print(F("SHT I="));
+      Serial.print(_name);
+      Serial.print(F(" I="));
       Serial.print(child->child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
@@ -1418,10 +1427,9 @@ void SensorSHT21::onLoop(Child* child) {
 
 // what to do as the main task when receiving a message
 void SensorSHT21::onReceive(const MyMessage & message) {
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
-    if (message.getCommand() == C_REQ && child->child_id == message.sensor) onLoop(child);
-  }
+  Child* child = getChild(message.sensor);
+  if (child == nullptr) return;
+  if (message.getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -3663,23 +3671,18 @@ void NodeManager::receive(const MyMessage &message) {
     #endif
   }
   // dispatch the message to the registered sensor
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
-    for (List<Child>::iterator itr1 = sensor->children.begin(); itr1 != sensor->children.end(); ++itr1) {
-      Child* child = itr1;
-      if (message.sensor == child->child_id) {
-        #if POWER_MANAGER == 1
-          // turn on the pin powering all the sensors
-          if (_auto_power_pins) powerOn();
-        #endif
-        // call the sensor's receive()
-        sensor->receive(message);
-        #if POWER_MANAGER == 1
-          // turn off the pin powering all the sensors
-          if (_auto_power_pins) powerOff();
-        #endif
-      }
-    }
+  Sensor* sensor = getSensorWithChild(message.sensor);
+  if (sensor != nullptr) {
+    #if POWER_MANAGER == 1
+      // turn on the pin powering all the sensors
+      if (_auto_power_pins) powerOn();
+    #endif
+    // call the sensor's receive()
+    sensor->receive(message);
+    #if POWER_MANAGER == 1
+      // turn off the pin powering all the sensors
+      if (_auto_power_pins) powerOff();
+    #endif
   }
 }
 
@@ -4006,6 +4009,16 @@ void NodeManager::sleepOrWait(long value) {
   }
 #endif
 
+// return the next available child_id
+int NodeManager::getAvailableChildId() {
+  for (int i = 1; i < 255; i++) {
+    if (i == CONFIGURATION_CHILD_ID || i == BATTERY_CHILD_ID || i == SIGNAL_CHILD_ID) continue;
+    Child* child = getChild(i);
+    if (child == nullptr) return i;
+  }
+  return 255;
+}
+
 // handle an interrupt
 void NodeManager::_onInterrupt_1() {
   long now = millis();
@@ -4081,6 +4094,23 @@ void NodeManager::sendMessage() {
   }
 }
 
+// return the requested child 
+Child* NodeManager::getChild(int child_id) {
+  Sensor* sensor = getSensorWithChild(child_id);
+  if (sensor == nullptr) return nullptr;
+  return sensor->getChild(child_id);
+}
+
+// return the sensor with the requested child 
+Sensor* NodeManager::getSensorWithChild(int child_id) {
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
+    Child* child = sensor->getChild(child_id);
+    if (child != nullptr) return sensor;
+  }
+  return nullptr;  
+}
+
 // wrapper of smart sleep
 void NodeManager::_sleep() {
   #if DEBUG == 1
@@ -4148,14 +4178,6 @@ void NodeManager::_present(int child_id, int type) {
   present(child_id,type,"",_ack);
 }
 
-// return the next available child_id
-int NodeManager::_getAvailableChildId() {
-  _child_id_counter++;
-  if (_child_id_counter == CONFIGURATION_CHILD_ID) _child_id_counter++;
-  if (_child_id_counter == BATTERY_CHILD_ID) _child_id_counter++;
-  return _child_id_counter;
-}
-
 // guess the initial value of a digital output based on the configured interrupt mode
 int NodeManager::_getInterruptInitialValue(int mode) {
   if (mode == RISING) return LOW; 
diff --git a/NodeManager.h b/NodeManager.h
index 0350e6f..8314227 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -663,8 +663,9 @@ class Sensor {
     virtual void onProcess(Request & request);
     virtual void onInterrupt();
     List<Child> children;
+    Child* getChild(int child_id);
   protected:
-    char* _name = "";
+    const __FlashStringHelper* _name;
     MyMessage* _msg;
     NodeManager* _node_manager;
     int _pin = -1;
@@ -1656,7 +1657,10 @@ class NodeManager {
     static void _onInterrupt_2();
 	  MyMessage* getMessage();
 	  void sendMessage();
+    int getAvailableChildId();
     List<Sensor*> sensors;
+    Child* getChild(int child_id);
+    Sensor* getSensorWithChild(int child_id);
   private:
     #if BATTERY_MANAGER == 1
       float _battery_min = 2.6;
@@ -1697,7 +1701,6 @@ class NodeManager {
     bool _ack = false;
     void _sleep();
     void _present(int child_id, int type);
-    int _getAvailableChildId();
     int _getInterruptInitialValue(int mode);
     bool _get_controller_config = true;
     int _is_metric = 1;
diff --git a/NodeManager.ino b/NodeManager.ino
index a0e08f6..2a0b955 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -30,7 +30,8 @@ void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);  
 
-
+nodeManager.sensors.get(0)->setPin(5);
+nodeManager.sensors.get(0)->children.get(0).child_id = 5;
 
 
 

From 20885ca94f87fb93b3380f67b16116d5e64d357f Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 11 Nov 2017 19:52:54 +0100
Subject: [PATCH 12/51] Added SensorBattery and SensorSignal

---
 NodeManager.cpp | 304 +++++++++++++++++++++-----------------------
 NodeManager.h   | 330 ++++++++----------------------------------------
 NodeManager.ino |  14 +-
 config.h        |  10 +-
 4 files changed, 211 insertions(+), 447 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index d0f3adb..0d9843f 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -494,7 +494,7 @@ void Sensor::loop(const MyMessage & message) {
       }
     }
     // process a float value
-    else if (_value_type == TYPE_FLOAT && total > -255) {
+    else if (child->value_type == TYPE_FLOAT && total > -255) {
       // calculate the average value of the samples
       float avg = total / _samples;
       // report the value back
@@ -505,7 +505,7 @@ void Sensor::loop(const MyMessage & message) {
       }
     }
     // process a double value
-    else if (_value_type == TYPE_DOUBLE && total > -1) {
+    else if (child->value_type == TYPE_DOUBLE && total > -1) {
       // calculate the average value of the samples
       double avg = total / _samples;
       // report the value back
@@ -516,7 +516,7 @@ void Sensor::loop(const MyMessage & message) {
       }
     }
     // process a string value
-    else if (_value_type == TYPE_STRING) {
+    else if (child->value_type == TYPE_STRING) {
       // if track last value is disabled or if enabled and the current value is different then the old value, send it back
       if (_isReceive(message) || _isWorthSending(strcmp(child->getValue<char*>(), child->getLastValue<char*>()) != 0))  {
         child->setLastValue<char*>(child->getValue<char*>());
@@ -643,6 +643,149 @@ bool Sensor::_isWorthSending(bool comparison) {
   return false;
 }
 
+/*
+   SensorBattery
+*/
+// contructor
+SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager,A2) {
+  _name = F("BAT");
+  // report battery level every 60 minutes by default
+  setReportIntervalMinutes(60);
+}
+void SensorBattery::setMinVoltage(float value) {
+  _battery_min = value;
+}
+void SensorBattery::setMaxVoltage(float value) {
+  _battery_max = value;
+}
+void SensorBattery::setBatteryInternalVcc(bool value) {
+  _battery_internal_vcc = value;
+}
+void SensorBattery::setBatteryPin(int value) {
+  _battery_pin = value;
+}
+void SensorBattery::setBatteryVoltsPerBit(float value) {
+  _battery_volts_per_bit = value;
+}
+void SensorBattery::setBatteryReportWithInterrupt(bool value) {
+  _battery_report_with_interrupt = value;
+}
+
+// what to do during before
+void SensorBattery::onBefore() {
+  children.push(Child(BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE,TYPE_FLOAT));
+}
+
+// what to do during setup
+void SensorBattery::onSetup() {
+  if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
+}
+
+// what to do during loop
+void SensorBattery::onLoop(Child* child) {
+  // measure the board vcc
+  float volt = 0;
+  if (_battery_internal_vcc || _battery_pin == -1) volt = _node_manager->getVcc();
+  else volt = analogRead(_battery_pin) * _battery_volts_per_bit;
+  // calculate the percentage
+  int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
+  if (percentage > 100) percentage = 100;
+  if (percentage < 0) percentage = 0;
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" V="));
+    Serial.print(volt);
+    Serial.print(F(" %="));
+    Serial.println(percentage);
+  #endif
+  child->setValue<float>(volt);
+  // report battery level percentage
+  sendBatteryLevel(percentage);
+}
+
+// what to do as the main task when receiving a message
+void SensorBattery::onReceive(const MyMessage & message) {
+  Child* child = getChild(message.sensor);
+  if (child == nullptr) return;
+  if (message.getCommand() == C_REQ) onLoop(child);
+}
+
+// what to do when receiving a remote message
+void SensorBattery::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 102: setMinVoltage(request.getValueFloat()); break;
+    case 103: setMaxVoltage(request.getValueFloat()); break;
+    case 104: setBatteryInternalVcc(request.getValueInt()); break;
+    case 105: setBatteryPin(request.getValueInt()); break;
+    case 106: setBatteryVoltsPerBit(request.getValueFloat()); break;
+    case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
+    default: return;
+  }
+  _sendServiceMessage(_msg->set(function));
+}
+
+// what to do when receiving an interrupt
+void SensorBattery::onInterrupt() {
+}
+
+/*
+   SensorSignal
+*/
+// contructor
+SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager,A2) {
+  _name = F("SIG");
+  // report signal level every 60 minutes by default
+  setReportIntervalMinutes(60);
+}
+// setter/getter
+void SensorSignal::setSignalCommand(int value) {
+  _signal_command = value;
+}
+
+// what to do during before
+void SensorSignal::onBefore() {
+  children.push(Child(SIGNAL_CHILD_ID,S_SOUND,V_LEVEL));
+}
+
+// what to do during setup
+void SensorSignal::onSetup() {
+
+}
+
+// what to do during loop
+void SensorSignal::onLoop(Child* child) {
+  int16_t value = transportGetSignalReport(_signal_command);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" V="));
+    Serial.println(value);
+  #endif
+  child->setValue<int>(value);
+}
+
+// what to do as the main task when receiving a message
+void SensorSignal::onReceive(const MyMessage & message) {
+  Child* child = getChild(message.sensor);
+  if (child == nullptr) return;
+  if (message.getCommand() == C_REQ) onLoop(child);
+}
+
+// what to do when receiving a remote message
+void SensorSignal::onProcess(Request & request) {
+  int function = request.getFunction();
+  switch(function) {
+    case 101: setSignalCommand(request.getValueInt()); break;
+    default: return;
+  }
+  _sendServiceMessage(_msg->set(function));
+}
+
+// what to do when receiving an interrupt
+void SensorSignal::onInterrupt() {
+}
+
+
 #if MODULE_ANALOG_INPUT == 1
 /*
    SensorAnalogInput
@@ -3114,38 +3257,7 @@ int NodeManager::getRetries() {
 MyMessage* NodeManager::getMessage() {
 	return &_msg;
 }
-#if BATTERY_MANAGER == 1
-  void NodeManager::setBatteryMin(float value) {
-    _battery_min = value;
-  }
-  void NodeManager::setBatteryMax(float value) {
-    _battery_max = value;
-  }
-  void NodeManager::setBatteryReportSeconds(int value) {
-    _battery_report_timer.set(value,SECONDS);
-  }
-  void NodeManager::setBatteryReportMinutes(int value) {
-    _battery_report_timer.set(value,MINUTES);
-  }
-  void NodeManager::setBatteryReportHours(int value) {
-    _battery_report_timer.set(value,HOURS);
-  }
-  void NodeManager::setBatteryReportDays(int value) {
-    _battery_report_timer.set(value,DAYS);
-  }
-  void NodeManager::setBatteryInternalVcc(bool value) {
-    _battery_internal_vcc = value;
-  }
-  void NodeManager::setBatteryPin(int value) {
-    _battery_pin = value;
-  }
-  void NodeManager::setBatteryVoltsPerBit(float value) {
-    _battery_volts_per_bit = value;
-  }
-  void NodeManager::setBatteryReportWithInterrupt(bool value) {
-    _battery_report_with_interrupt = value;
-  }
-#endif
+
 
 void NodeManager::setSleepSeconds(int value) {
   // set the status to AWAKE if the time provided is 0, SLEEP otherwise
@@ -3513,18 +3625,6 @@ void NodeManager::before() {
     // restore the configuration saved in the eeprom
     _loadConfig();
   #endif
-  #if BATTERY_MANAGER == 1 && !defined(MY_GATEWAY_ESP8266)
-    // set analogReference to internal if measuring the battery through a pin
-    if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
-    // if not already configured, report battery level every 60 minutes
-    if (! _battery_report_timer.isConfigured()) _battery_report_timer.set(60,MINUTES);
-    _battery_report_timer.start();
-  #endif
-  #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-    // if not already configured, report signal level every 60 minutes
-    if (! _signal_report_timer.isConfigured()) _signal_report_timer.set(60,MINUTES);
-    _signal_report_timer.start();
-  #endif
   // setup individual sensors
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3547,18 +3647,6 @@ void NodeManager::presentation() {
   sendSketchInfo(SKETCH_NAME,SKETCH_VERSION);
   // present the service as a custom sensor to the controller
   _present(CONFIGURATION_CHILD_ID, S_CUSTOM);
-  #if BATTERY_MANAGER == 1 && BATTERY_SENSOR == 1
-    // present the battery service
-    _present(BATTERY_CHILD_ID, S_MULTIMETER);
-    // report battery level
-    batteryReport();
-  #endif
-  #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-    // present the signal service
-    _present(SIGNAL_CHILD_ID, S_SOUND);
-    // report battery level
-    signalReport();
-  #endif
   // present each sensor
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3596,28 +3684,6 @@ void NodeManager::setup() {
 
 // run the main function for all the register sensors
 void NodeManager::loop() {
-  #if BATTERY_MANAGER == 1
-    // update the timer for battery report when not waking up from an interrupt
-    if (_battery_report_timer.isRunning() && _last_interrupt_pin == -1) _battery_report_timer.update();
-    // if it is time to report the battery level
-    if (_battery_report_timer.isOver()) {
-      // time to report the battery level again
-      batteryReport();
-      // restart the timer
-      _battery_report_timer.restart();
-    }
-  #endif
-  #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-    // update the timer for signal report when not waking up from an interrupt
-    if (_signal_report_timer.isRunning() && _last_interrupt_pin == -1) _signal_report_timer.update();
-    // if it is time to report the signal level
-    if (_signal_report_timer.isOver()) {
-      // time to report the signal level again
-      signalReport();
-      // restart the timer
-      _signal_report_timer.restart();
-    }
-  #endif
   #if POWER_MANAGER == 1
     // turn on the pin powering all the sensors
     if (_auto_power_pins) powerOn();
@@ -3717,16 +3783,6 @@ void NodeManager::process(Request & request) {
   int function = request.getFunction();
   switch(function) {
     case 1: hello(); break;
-    #if BATTERY_MANAGER == 1
-      case 2: batteryReport(); return;
-      case 11: setBatteryMin(request.getValueFloat()); break;
-      case 12: setBatteryMax(request.getValueFloat()); break;
-      case 14: setBatteryReportMinutes(request.getValueInt()); break;
-      case 15: setBatteryInternalVcc(request.getValueInt()); break;
-      case 16: setBatteryPin(request.getValueInt()); break;
-      case 17: setBatteryVoltsPerBit(request.getValueFloat()); break;
-      case 18: setBatteryReportWithInterrupt(request.getValueInt()); break;
-    #endif
     case 3:
       setSleepSeconds(request.getValueInt());
       #if PERSIST == 1
@@ -3772,23 +3828,10 @@ void NodeManager::process(Request & request) {
     case 30: setSleepOrWait(request.getValueInt()); break;
     case 31: setRebootPin(request.getValueInt()); break;
     case 32: setADCOff(); break;
-    #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-      case 33: setSignalReportMinutes(request.getValueInt()); break;
-      case 43: setSignalReportSeconds(request.getValueInt()); break;
-      case 44: setSignalReportHours(request.getValueInt()); break;
-      case 45: setSignalReportDays(request.getValueInt()); break;
-      case 34: setSignalCommand(request.getValueInt()); break;
-      case 35: signalReport(); break;
-    #endif
     case 36: setReportIntervalSeconds(request.getValueInt()); break;
     case 37: setReportIntervalMinutes(request.getValueInt()); break;
     case 38: setReportIntervalHours(request.getValueInt()); break;
     case 39: setReportIntervalDays(request.getValueInt()); break;
-    #if BATTERY_MANAGER == 1
-      case 40: setBatteryReportSeconds(request.getValueInt()); break;
-      case 41: setBatteryReportHours(request.getValueInt()); break;
-      case 42: setBatteryReportDays(request.getValueInt()); break;
-    #endif
     default: return; 
   }
   _sendUsingConfigChild(_msg.set(function));
@@ -3800,32 +3843,6 @@ void NodeManager::hello() {
   // do nothing, the request will be echoed back
 }
 
-#if BATTERY_MANAGER == 1
-// Send a battery level report to the controller
-void NodeManager::batteryReport() {
-  // measure the board vcc
-  float volt = 0;
-  if (_battery_internal_vcc || _battery_pin == -1) volt = getVcc();
-  else volt = analogRead(_battery_pin) * _battery_volts_per_bit;
-  // calculate the percentage
-  int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
-  if (percentage > 100) percentage = 100;
-  if (percentage < 0) percentage = 0;
-  #if DEBUG == 1
-    Serial.print(F("BATT V="));
-    Serial.print(volt);
-    Serial.print(F(" P="));
-    Serial.println(percentage);
-  #endif
-  #if BATTERY_SENSOR == 1
-    // report battery voltage
-	_sendUsingBatteryChild(_msg.set(volt, 2));
-  #endif
-  // report battery level percentage
-  sendBatteryLevel(percentage,_ack);
-}
-#endif
-
 // reboot the board
 void NodeManager::reboot() {
   #if DEBUG == 1
@@ -3982,33 +3999,6 @@ void NodeManager::sleepOrWait(long value) {
   else wait(value);
 }
 
-#if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-  void NodeManager::setSignalReportSeconds(int value) {
-    _signal_report_timer.set(value,SECONDS);
-  }
-  void NodeManager::setSignalReportMinutes(int value) {
-    _signal_report_timer.set(value,MINUTES);
-  }
-  void NodeManager::setSignalReportHours(int value) {
-    _signal_report_timer.set(value,HOURS);
-  }
-  void NodeManager::setSignalReportDays(int value) {
-    _signal_report_timer.set(value,DAYS);
-  }
-  void NodeManager::setSignalCommand(int value) {
-    _signal_command = value;
-  }
-  void NodeManager::signalReport() {
-    int16_t value = transportGetSignalReport(_signal_command);
-    #if DEBUG == 1
-      Serial.print(F("SIG V="));
-      Serial.println(value);
-    #endif
-    // report signal level
-	//_sendSignalChild(_msg.set(value));
-  }
-#endif
-
 // return the next available child_id
 int NodeManager::getAvailableChildId() {
   for (int i = 1; i < 255; i++) {
diff --git a/NodeManager.h b/NodeManager.h
index 8314227..4111fe6 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -64,10 +64,6 @@
 #ifndef POWER_MANAGER
   #define POWER_MANAGER 1
 #endif
-// if enabled, will load the battery manager library to allow the battery level to be reported automatically or on demand
-#ifndef BATTERY_MANAGER
-  #define BATTERY_MANAGER 1
-#endif
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
 #ifndef REMOTE_CONFIGURATION
   #define REMOTE_CONFIGURATION 1
@@ -81,14 +77,6 @@
 #ifndef SERVICE_MESSAGES
   #define SERVICE_MESSAGES 0
 #endif
-// if enabled, a battery sensor will be created at BATTERY_CHILD_ID (201 by default) and will report vcc voltage together with the battery level percentage
-#ifndef BATTERY_SENSOR
-  #define BATTERY_SENSOR 1
-#endif
-// if enabled, a RSSI sensor will be created at SIGNAL_CHILD_ID (202 by default) and will report the signal quality of the transport layer
-#ifndef SIGNAL_SENSOR
-  #define SIGNAL_SENSOR 1
-#endif
 
 // the child id used to allow remote configuration
 #ifndef CONFIGURATION_CHILD_ID
@@ -110,220 +98,6 @@
   #define SKETCH_VERSION "1.0"
 #endif
 
-
-/***********************************
-   Default module settings
-*/
-
-// Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
-#ifndef MODULE_ANALOG_INPUT
-  #define MODULE_ANALOG_INPUT 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT
-#ifndef MODULE_DIGITAL_INPUT
-  #define MODULE_DIGITAL_INPUT 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_DIGITAL_OUTPUT, SENSOR_RELAY, SENSOR_LATCHING_RELAY
-#ifndef MODULE_DIGITAL_OUTPUT
-  #define MODULE_DIGITAL_OUTPUT 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
-#ifndef MODULE_DHT
-  #define MODULE_DHT 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
-#ifndef MODULE_SHT21
-  #define MODULE_SHT21 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION
-#ifndef MODULE_SWITCH
-  #define MODULE_SWITCH 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_DS18B20
-#ifndef MODULE_DS18B20
-  #define MODULE_DS18B20 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_BH1750
-#ifndef MODULE_BH1750
-  #define MODULE_BH1750 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_MLX90614
-#ifndef MODULE_MLX90614
-  #define MODULE_MLX90614 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_BME280
-#ifndef MODULE_BME280
-  #define MODULE_BME280 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_SONOFF
-#ifndef MODULE_SONOFF
-  #define MODULE_SONOFF 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_BMP085
-#ifndef MODULE_BMP085
-  #define MODULE_BMP085 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_HCSR04
-#ifndef MODULE_HCSR04
-  #define MODULE_HCSR04 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_MCP9808
-#ifndef MODULE_MCP9808
-  #define MODULE_MCP9808 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_MQ
-#ifndef MODULE_MQ
-  #define MODULE_MQ 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_MHZ19
-#ifndef MODULE_MHZ19
-  #define MODULE_MHZ19 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_AM2320
-#ifndef MODULE_AM2320
-  #define MODULE_AM2320 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_TSL2561
-#ifndef MODULE_TSL2561
-  #define MODULE_TSL2561 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_PT100
-#ifndef MODULE_PT100
-  #define SENSOR_PT100 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_BMP280
-#ifndef MODULE_BMP280
-  #define MODULE_BMP280 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_DIMMER
-#ifndef MODULE_DIMMER
-  #define MODULE_DIMMER 0
-#endif
-// Enable this module to use one of the following sensors: SENSOR_RAIN_GAUGE, SENSOR_POWER_METER, SENSOR_WATER_METER
-#ifndef MODULE_PULSE_METER
-  #define MODULE_PULSE_METER 0
-#endif
-
-/***********************************
-   Supported Sensors
-*/
-enum supported_sensors {
-  #if MODULE_ANALOG_INPUT == 1
-    // Generic analog sensor, return a pin's analog value or its percentage
-    SENSOR_ANALOG_INPUT,
-    // LDR sensor, return the light level of an attached light resistor in percentage
-    SENSOR_LDR,
-    // Thermistor sensor, return the temperature based on the attached thermistor
-    SENSOR_THERMISTOR,
-    // ML8511 UV sensor
-    SENSOR_ML8511,
-    // Current sensor
-    SENSOR_ACS712,
-    // Rain sensor, return the percentage of rain from an attached analog sensor
-    SENSOR_RAIN,
-    // Soil moisture sensor, return the percentage of moisture from an attached analog sensor
-    SENSOR_SOIL_MOISTURE,
-  #endif
-  #if MODULE_DIGITAL_INPUT == 1
-    // Generic digital sensor, return a pin's digital value
-    SENSOR_DIGITAL_INPUT,
-  #endif
-  #if MODULE_DIGITAL_OUTPUT == 1
-    // Generic digital output sensor, allows setting the digital output of a pin to the requested value
-    SENSOR_DIGITAL_OUTPUT,
-    // Relay sensor, allows activating the relay
-    SENSOR_RELAY,
-    // Latching Relay sensor, allows activating the relay with a pulse
-    SENSOR_LATCHING_RELAY,
-  #endif
-  #if MODULE_DHT == 1
-    // DHT11/DHT22 sensors, return temperature/humidity based on the attached DHT sensor
-    SENSOR_DHT11,
-    SENSOR_DHT22,
-  #endif
-  #if MODULE_SHT21 == 1
-    // SHT21 sensor, return temperature/humidity based on the attached SHT21 sensor
-    SENSOR_SHT21,
-    SENSOR_HTU21D,
-  #endif
-  #if MODULE_SWITCH == 1
-    // Generic switch, wake up the board when a pin changes status
-    SENSOR_SWITCH,
-    // Door sensor, wake up the board and report when an attached magnetic sensor has been opened/closed
-    SENSOR_DOOR,
-    // Motion sensor, wake up the board and report when an attached PIR has triggered
-    SENSOR_MOTION,
-  #endif
-  #if MODULE_DS18B20 == 1
-    // DS18B20 sensor, return the temperature based on the attached sensor
-    SENSOR_DS18B20,
-  #endif
-  #if MODULE_BH1750 == 1
-    // BH1750 sensor, return light in lux
-    SENSOR_BH1750,
-  #endif
-  #if MODULE_MLX90614 == 1
-    // MLX90614 sensor, contactless temperature sensor
-    SENSOR_MLX90614,
-  #endif
-  #if MODULE_BME280 == 1
-    // BME280 sensor, return temperature, humidity and pressure
-    SENSOR_BME280,
-  #endif
-  #if MODULE_SONOFF == 1
-    // Sonoff wireless smart switch
-    SENSOR_SONOFF,
-  #endif
-  #if MODULE_BMP085 == 1
-    // BMP085/BMP180 sensor, return temperature and pressure
-    SENSOR_BMP085,
-  #endif
-  #if MODULE_HCSR04 == 1
-    // HC-SR04 sensor, return the distance between the sensor and an object
-    SENSOR_HCSR04,
-  #endif
-  #if MODULE_MCP9808 == 1
-    // MCP9808 sensor, precision temperature sensor
-    SENSOR_MCP9808,
-  #endif
-  #if MODULE_MQ == 1
-    // MQ2 air quality sensor
-    SENSOR_MQ,
-  #endif
-  #if MODULE_MHZ19 == 1
-    // MH-Z19 CO2 sensor
-    SENSOR_MHZ19,
-  #endif
-  #if MODULE_TSL2561 == 1
-    // TSL2561 sensor, return light in lux
-    SENSOR_TSL2561,
-  #endif
-  #if MODULE_AM2320 == 1
-    // AM2320 sensors, return temperature/humidity based on the attached AM2320 sensor
-    SENSOR_AM2320,
-  #endif
-   #if MODULE_PT100 == 1
-    // High temperature sensor associated with DFRobot Driver, return the temperature in C from the attached PT100 sensor
-    SENSOR_PT100,
-  #endif
-  #if MODULE_BMP280 == 1
-    // BMP280 sensor, return temperature and pressure
-    SENSOR_BMP280,
-  #endif
-  #if MODULE_DIMMER == 1
-    // Generic dimmer sensor used to drive a pwm output
-    SENSOR_DIMMER,
-  #endif
-  #if MODULE_PULSE_METER == 1
-    // rain gauge sensor
-    SENSOR_RAIN_GAUGE,
-    // power meter pulse sensor
-    SENSOR_POWER_METER, 
-    // water meter pulse sensor
-    SENSOR_WATER_METER,
-  #endif
-};
- 
 /***********************************
   Libraries
 */
@@ -692,6 +466,59 @@ class Sensor {
     int _value_type = TYPE_INTEGER;
 };
 
+/*
+   SensorBattery: report battery level
+*/
+class SensorBattery: public Sensor {
+  public:
+    SensorBattery(NodeManager& nodeManager);
+      // [11] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
+      void setMinVoltage(float value);
+      // [12] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
+      void setMaxVoltage(float value);
+      // [15] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
+      void setBatteryInternalVcc(bool value);
+      // [16] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
+      void setBatteryPin(int value);
+      // [17] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
+      void setBatteryVoltsPerBit(float value);
+      // [18] If true, wake up by an interrupt counts as a valid cycle for battery reports otherwise only uninterrupted sleep cycles would contribute (default: true)
+      void setBatteryReportWithInterrupt(bool value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(const MyMessage & message);
+    void onProcess(Request & request);
+    void onInterrupt();
+  protected:
+      float _battery_min = 2.6;
+      float _battery_max = 3.3;
+      bool _battery_report_with_interrupt = true;
+      bool _battery_internal_vcc = true;
+      int _battery_pin = -1;
+      float _battery_volts_per_bit = 0.003363075;
+};
+
+/*
+   SensorSignal: report RSSI signal strength from the radio
+*/
+class SensorSignal: public Sensor {
+  public:
+    SensorSignal(NodeManager& nodeManager);
+    // [101] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
+    void setSignalCommand(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(const MyMessage & message);
+    void onProcess(Request & request);
+    void onInterrupt();
+  protected:
+    int _signal_command = SR_RX_RSSI;
+};
+
 #if MODULE_ANALOG_INPUT == 1
 /*
    SensorAnalogInput: read the analog input of a configured pin
@@ -1525,30 +1352,6 @@ class NodeManager {
     // [10] send the same service message multiple times (default: 1)
     void setRetries(int value);
     int getRetries();
-    #if BATTERY_MANAGER == 1
-      // [11] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
-      void setBatteryMin(float value);
-      // [12] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
-      void setBatteryMax(float value);
-      // [14] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportMinutes(int value);
-      // [40] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportSeconds(int value);
-      // [41] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportHours(int value);
-      // [42] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportDays(int value);
-      // [15] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
-      void setBatteryInternalVcc(bool value);
-      // [16] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
-      void setBatteryPin(int value);
-      // [17] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
-      void setBatteryVoltsPerBit(float value);
-      // [18] If true, wake up by an interrupt counts as a valid cycle for battery reports otherwise only uninterrupted sleep cycles would contribute (default: true)
-      void setBatteryReportWithInterrupt(bool value);
-      // [2] Send a battery level report to the controller
-      void batteryReport();
-    #endif
     // [3] set the duration (in seconds) of a sleep cycle
     void setSleepSeconds(int value);
     long getSleepSeconds();
@@ -1631,20 +1434,6 @@ class NodeManager {
     void setRebootPin(int value);
     // [32] turn the ADC off so to save 0.2 mA
     void setADCOff();
-    #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-      // [33] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportMinutes(int value);
-      // [43] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportSeconds(int value);
-      // [44] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportHours(int value);
-      // [45] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportDays(int value);
-      // [34] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
-      void setSignalCommand(int value);
-      // [35] report the signal level to the controller
-      void signalReport();
-    #endif
     // hook into the main sketch functions
     void before();
     void presentation();
@@ -1662,24 +1451,11 @@ class NodeManager {
     Child* getChild(int child_id);
     Sensor* getSensorWithChild(int child_id);
   private:
-    #if BATTERY_MANAGER == 1
-      float _battery_min = 2.6;
-      float _battery_max = 3.3;
-      Timer _battery_report_timer = Timer(this);
-      bool _battery_report_with_interrupt = true;
-      bool _battery_internal_vcc = true;
-      int _battery_pin = -1;
-      float _battery_volts_per_bit = 0.003363075;
-    #endif
     #if POWER_MANAGER == 1
       // to optionally controller power pins
       PowerManager _powerManager;
       bool _auto_power_pins = true;
     #endif
-    #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-      Timer _signal_report_timer = Timer(this);
-      int _signal_command = SR_RX_RSSI;
-    #endif
     MyMessage _msg;
     void _sendUsingConfigChild(MyMessage & msg);
     void _sendUsingBatteryChild(MyMessage & msg);
diff --git a/NodeManager.ino b/NodeManager.ino
index 2a0b955..2e0a111 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -23,27 +23,31 @@ Documentation available on: https://github.com/mysensors/NodeManager
 
 // create a NodeManager instance
 NodeManager nodeManager;
-SensorSHT21 sht(nodeManager);
+//SensorSHT21 sht(nodeManager);
+//SensorBattery battery(nodeManager);
+//SensorSignal signal(nodeManager);
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);  
+//  battery.setReportIntervalSeconds(20);
 
-nodeManager.sensors.get(0)->setPin(5);
-nodeManager.sensors.get(0)->children.get(0).child_id = 5;
+//nodeManager.sensors.get(0)->setPin(5);
+//nodeManager.sensors.get(0)->children.get(0).child_id = 5;
 
 
 
   /*
    * Register below your sensors
   */
+  /*
       pinMode(4, OUTPUT);
     digitalWrite(4, HIGH);
     pinMode(5, OUTPUT);
     digitalWrite(5, LOW);
-    
-  nodeManager.setReportIntervalSeconds(20);
+    */
+  //nodeManager.setReportIntervalSeconds(20);
   
   
   
diff --git a/config.h b/config.h
index 3a97d4d..8f6a3e0 100755
--- a/config.h
+++ b/config.h
@@ -15,14 +15,14 @@
 // General settings
 #define MY_BAUD_RATE 9600
 //#define MY_DEBUG
-#define MY_NODE_ID 100
+#define MY_NODE_ID 99
 //#define MY_SMART_SLEEP_WAIT_DURATION_MS 500
 #define MY_SPLASH_SCREEN_DISABLED
 
 // NRF24 radio settings
 #define MY_RADIO_NRF24
 //#define MY_RF24_ENABLE_ENCRYPTION
-#define MY_RF24_CHANNEL 125
+//#define MY_RF24_CHANNEL 125
 //#define MY_RF24_PA_LEVEL RF24_PA_HIGH
 //#define MY_DEBUG_VERBOSE_RF24
 //#define MY_RF24_DATARATE RF24_250KBPS
@@ -115,16 +115,10 @@
 
 // if enabled, enable the capability to power on sensors with the arduino's pins to save battery while sleeping
 #define POWER_MANAGER 0
-// if enabled, will load the battery manager library to allow the battery level to be reported automatically or on demand
-#define BATTERY_MANAGER 0
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
 #define REMOTE_CONFIGURATION 0
 // if enabled, persist the remote configuration settings on EEPROM
 #define PERSIST 0
-// if enabled, a battery sensor will be created at BATTERY_CHILD_ID (201 by default) and will report vcc voltage together with the battery level percentage
-#define BATTERY_SENSOR 0
-// if enabled, a signal sensor will be created at RSSI_CHILD_ID (202 by default) and will report the signal quality of the transport layer
-#define SIGNAL_SENSOR 0
 // if enabled, send a SLEEPING and AWAKE service messages just before entering and just after leaving a sleep cycle and STARTED when starting/rebooting
 #define SERVICE_MESSAGES 0
 

From b11cff53e73429fedae40a512d4307744ad526fe Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 19 Nov 2017 17:56:03 +0100
Subject: [PATCH 13/51] Deprecated SERVICE_MESSAGE

---
 NodeManager.cpp | 11 -----------
 NodeManager.h   |  5 -----
 config.h        |  2 --
 3 files changed, 18 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 0d9843f..c28b95b 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -3671,9 +3671,6 @@ void NodeManager::setup() {
     Serial.print(F(" M="));
     Serial.println(_is_metric);
   #endif
-  #if SERVICE_MESSAGES == 1
-	_sendUsingConfigChild(_msg.set("STARTED"));
-  #endif
   // run setup for all the registered sensors
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -4108,10 +4105,6 @@ void NodeManager::_sleep() {
     Serial.print(_sleep_time);
     Serial.println(F("s"));
   #endif
-  #if SERVICE_MESSAGES == 1
-    // notify the controller I'm going to sleep
-	_sendUsingConfigChild(_msg.set("SLEEPING"));
-  #endif
   #if DEBUG == 1
     // print a new line to separate the different cycles
     Serial.println("");
@@ -4150,10 +4143,6 @@ void NodeManager::_sleep() {
   #if DEBUG == 1
     Serial.println(F("AWAKE"));
   #endif
-  #if SERVICE_MESSAGES == 1
-    // notify the controller I am awake
-	_sendUsingConfigChild(_msg.set("AWAKE"));
-  #endif
 }
 
 // present the service
diff --git a/NodeManager.h b/NodeManager.h
index 4111fe6..76595a8 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -73,11 +73,6 @@
   #define PERSIST 0
 #endif
 
-// if enabled, send a SLEEPING and AWAKE service messages just before entering and just after leaving a sleep cycle
-#ifndef SERVICE_MESSAGES
-  #define SERVICE_MESSAGES 0
-#endif
-
 // the child id used to allow remote configuration
 #ifndef CONFIGURATION_CHILD_ID
   #define CONFIGURATION_CHILD_ID 200
diff --git a/config.h b/config.h
index 8f6a3e0..dabb0e3 100755
--- a/config.h
+++ b/config.h
@@ -119,8 +119,6 @@
 #define REMOTE_CONFIGURATION 0
 // if enabled, persist the remote configuration settings on EEPROM
 #define PERSIST 0
-// if enabled, send a SLEEPING and AWAKE service messages just before entering and just after leaving a sleep cycle and STARTED when starting/rebooting
-#define SERVICE_MESSAGES 0
 
 // Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
 #define MODULE_ANALOG_INPUT 0

From ec2a8c06117c9d121f7b1922b464d690b44a1aef Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 25 Nov 2017 15:20:28 +0100
Subject: [PATCH 14/51] Implemented Child subclasses

---
 NodeManager.cpp | 254 +++++++++++++++++++++++++-----------------------
 NodeManager.h   | 129 +++++++++++++++---------
 NodeManager.ino |   4 +-
 3 files changed, 220 insertions(+), 167 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index c28b95b..724b1e4 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -220,65 +220,113 @@ Child::Child() {
 }
 
 // constructor
-Child::Child(int _child_id, int _presentation, int _type, int _value_type = TYPE_INTEGER, char* _description = "") {
+Child::Child(Sensor* __sensor, int _child_id, int _presentation, int _type, char* _description = "") {
   child_id = _child_id;
   presentation = _presentation;
   type = _type;
-  value_type = _value_type;
   description = _description;
+  _sensor = __sensor;
+  _sensor->registerChild(this);
 }
-
-// setter/getter
-template<> void Child::setValue(int value) {
-  _value_int = value;
-}
-template<> void Child::setValue(float value) {
-  _value_float = value;
-}
-template<> void Child::setValue(double value) {
-  _value_double = value;
+// set a value, implemented by the subclasses
+void Child::sendValue() {
 }
-template<> void Child::setValue(char* value) {
-  _value_string = value;
-}
-template<> int Child::getValue() {
-    return _value_int;
+
+// ChildInt class
+ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
-template<> float Child::getValue() {
-    return _value_float;
+
+// store a new value and update the total
+void ChildInt::setValueInt(int value) {
+  _samples++;
+  _total = _total + value;
+  _value = value;
 }
-template<> double Child::getValue() {
-    return _value_double;
+
+// send the value back to the controller
+void ChildInt::sendValue() {
+  if (_total == -255) return;
+  int avg = (int) (_total / _samples);
+  _last_value = avg;
+  MyMessage* msg = _sensor->_node_manager->getMessage();
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(avg);
+  _sensor->_node_manager->sendMessage();
+  _value = -255;
 }
-template<> char* Child::getValue() {
-    return _value_string;
+
+// ChildFloat class
+ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
-template<> void Child::setLastValue(int value) {
-  _last_value_int = value;
+
+// store a new value and update the total
+void ChildFloat::setValueFloat(float value) {
+  _samples++;
+  _total = _total + value;
+  _value = value;
 }
-template<> void Child::setLastValue(float value) {
-  _last_value_float = value;
+
+// send the value back to the controller
+void ChildFloat::sendValue() {
+  if (_total == -255) return;
+  float avg = _total / _samples;
+  _last_value = avg;
+  MyMessage* msg = _sensor->_node_manager->getMessage();
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(avg,_sensor->getFloatPrecision());
+  _sensor->_node_manager->sendMessage();
+  _value = -255;
 }
-template<> void Child::setLastValue(double value) {
-  _last_value_double = value;
+
+// ChildDouble class
+ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
-template<> void Child::setLastValue(char* value) {
-  _last_value_string = value;
+
+// store a new value and update the total
+void ChildDouble::setValueDouble(double value) {
+  _samples++;
+  _total = _total + value;
+  _value = value;
 }
-template<> int Child::getLastValue() {
-    return _last_value_int;
+
+// send the value back to the controller
+void ChildDouble::sendValue() {
+  if (_total == -255) return;
+  double avg = _total / _samples;
+  _last_value = avg;
+  MyMessage* msg = _sensor->_node_manager->getMessage();
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(avg,_sensor->getDoublePrecision());
+  _sensor->_node_manager->sendMessage();
+  _value = -255;
 }
-template<> float Child::getLastValue() {
-    return _last_value_float;
+
+// ChildString class
+ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
-template<> double Child::getLastValue() {
-    return _last_value_double;
+
+// store a new value and update the total
+void ChildString::setValueString(char* value) {
+  _value = value;
 }
-template<> char* Child::getLastValue() {
-    return _last_value_string;
+
+// send the value back to the controller
+void ChildString::sendValue() {
+  MyMessage* msg = _sensor->_node_manager->getMessage();
+  _last_value = _value;
+  msg->setSensor(child_id);
+  msg->setType(type);
+  msg->set(_value);
+  _sensor->_node_manager->sendMessage();
+  _value = "";
 }
 
 
+
+
 /*
    Sensor class
 */
@@ -348,9 +396,16 @@ int Sensor::getValueType() {
 void Sensor::setFloatPrecision(int value) {
   _float_precision = value;
 }
+int Sensor::getFloatPrecision() {
+  return _float_precision;
+}
 void Sensor::setDoublePrecision(int value) {
   _double_precision = value;
 }
+int Sensor::getDoublePrecision() {
+  return _double_precision;
+}
+
 #if POWER_MANAGER == 1
     void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
       _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
@@ -401,10 +456,15 @@ void Sensor::setInterrupt(int pin, int mode, int initial) {
   _node_manager->setInterrupt(pin,mode,initial);
 }
 
+// register a child
+void Sensor::registerChild(Child* child) {
+  children.push(child);
+}
+
 // present the sensor to the gateway and controller
 void Sensor::presentation() {
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
   #if DEBUG == 1
     Serial.print(F("PRES I="));
     Serial.print(child->child_id);
@@ -420,8 +480,8 @@ void Sensor::presentation() {
 void Sensor::before() {
   if (_pin == -1) return;
   onBefore();
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -441,16 +501,14 @@ void Sensor::setup() {
 }
 
 // call the sensor-specific implementation of loop
-void Sensor::loop(const MyMessage & message) {
-//  if (_pin == -1) return;
+void Sensor::loop(MyMessage* message) {
   // update the timers if within a loop cycle
-  if (! _isReceive(message)) {
+  if (message == nullptr) {
     if (_report_timer->isRunning()) {
-      // store the elapsed time before updating it
       bool first_run = _report_timer->isFirstRun();
       // update the timer
       _report_timer->update();
-      // if it is not the time yet to report a new measure, just return (unless the first time)
+      // if it is not the time yet to report a new measure, just return (unless it is the first time)
       if (! _report_timer->isOver() && ! first_run) return;
     }
     if (_force_update_timer->isRunning()) _force_update_timer->update();
@@ -460,14 +518,14 @@ void Sensor::loop(const MyMessage & message) {
     if (_auto_power_pins) powerOn();
   #endif
   // iterates over all the children
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
     // for numeric sensor requiring multiple samples, keep track of the total
     double total = 0;
     // collect multiple samples if needed
     for (int i = 0; i < _samples; i++) {
       // call the sensor-specific implementation of the main task which will store the result in the _value variable
-      if (_isReceive(message)) {
+      if (message != nullptr) {
         // we've been called from receive(), pass the message along
         onReceive(message);
       }
@@ -475,62 +533,18 @@ void Sensor::loop(const MyMessage & message) {
         // we'be been called from loop()
         onLoop(child);
       }
-      // for integers, floats and doubles, keep track of the total
-      if (child->value_type == TYPE_INTEGER) total += (float)child->getValue<int>();
-      else if (child->value_type == TYPE_FLOAT) total += child->getValue<float>();
-      else if (child->value_type == TYPE_DOUBLE) total += child->getValue<double>();
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
-    if (child->value_type == TYPE_INTEGER && total > -255) {
-      // if the value is an integer, calculate the average value of the samples
-      int avg = (int) (total / _samples);
-      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<int>()))  {
-        child->setLastValue<int>(avg);
-        _sendSensorMessage(_msg->set(avg));
-        child->setValue<int>(-255);
-      }
-    }
-    // process a float value
-    else if (child->value_type == TYPE_FLOAT && total > -255) {
-      // calculate the average value of the samples
-      float avg = total / _samples;
-      // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<float>()))  {
-        child->setLastValue<float>(avg);
-        _sendSensorMessage(_msg->set(avg, _float_precision));
-        child->setValue<float>(-255);
-      }
-    }
-    // process a double value
-    else if (child->value_type == TYPE_DOUBLE && total > -1) {
-      // calculate the average value of the samples
-      double avg = total / _samples;
-      // report the value back
-      if (_isReceive(message) || _isWorthSending(avg != child->getLastValue<double>()))  {
-        child->setLastValue<double>(avg);
-        _sendSensorMessage(_msg->set(avg, _double_precision));
-        child->setValue<double>(-255);
-      }
-    }
-    // process a string value
-    else if (child->value_type == TYPE_STRING) {
-      // if track last value is disabled or if enabled and the current value is different then the old value, send it back
-      if (_isReceive(message) || _isWorthSending(strcmp(child->getValue<char*>(), child->getLastValue<char*>()) != 0))  {
-        child->setLastValue<char*>(child->getValue<char*>());
-        _sendSensorMessage(_msg->set(child->getValue<char*>()));
-        child->setValue<char*>("");
-      }
-    }
+    child->sendValue();
   }
   // turn the sensor off
   #if POWER_MANAGER == 1
     if (_auto_power_pins) powerOff();
   #endif
   // restart the report timer if over
-  if (! _isReceive(message) && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
+  if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
 }
 
 // receive and handle an interrupt
@@ -556,7 +570,7 @@ void Sensor::receive(const MyMessage &message) {
   // return if the type is not correct
   if (message.type != _type) return;
   // a request would make the sensor executing its main task passing along the message
-  loop(message);
+  loop(&message);
 }
 
 // process a remote configuration request message
@@ -591,8 +605,8 @@ void Sensor::process(Request & request) {
 
 // return the requested child 
 Child* Sensor::getChild(int child_id) {
-  for (List<Child>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = itr;
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
     if (child->child_id == child_id) return child;
   }
   return nullptr;
@@ -602,7 +616,7 @@ Child* Sensor::getChild(int child_id) {
 void Sensor::onBefore() {}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
-void Sensor::onReceive(const MyMessage & message){}
+void Sensor::onReceive(MyMessage* message){}
 void Sensor::onProcess(Request & request){}
 void Sensor::onInterrupt(){}
 
@@ -673,7 +687,7 @@ void SensorBattery::setBatteryReportWithInterrupt(bool value) {
 
 // what to do during before
 void SensorBattery::onBefore() {
-  children.push(Child(BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE,TYPE_FLOAT));
+  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);  
 }
 
 // what to do during setup
@@ -698,16 +712,16 @@ void SensorBattery::onLoop(Child* child) {
     Serial.print(F(" %="));
     Serial.println(percentage);
   #endif
-  child->setValue<float>(volt);
+  ((ChildFloat*)child)->setValueFloat(volt);
   // report battery level percentage
   sendBatteryLevel(percentage);
 }
 
 // what to do as the main task when receiving a message
-void SensorBattery::onReceive(const MyMessage & message) {
-  Child* child = getChild(message.sensor);
+void SensorBattery::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message.getCommand() == C_REQ) onLoop(child);
+  if (message->getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -745,7 +759,7 @@ void SensorSignal::setSignalCommand(int value) {
 
 // what to do during before
 void SensorSignal::onBefore() {
-  children.push(Child(SIGNAL_CHILD_ID,S_SOUND,V_LEVEL));
+  new ChildInt(this,SIGNAL_CHILD_ID,S_SOUND,V_LEVEL);
 }
 
 // what to do during setup
@@ -761,14 +775,14 @@ void SensorSignal::onLoop(Child* child) {
     Serial.print(F(" V="));
     Serial.println(value);
   #endif
-  child->setValue<int>(value);
+  ((ChildInt*)child)->setValueInt(value);
 }
 
 // what to do as the main task when receiving a message
-void SensorSignal::onReceive(const MyMessage & message) {
-  Child* child = getChild(message.sensor);
+void SensorSignal::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message.getCommand() == C_REQ) onLoop(child);
+  if (message->getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -1523,8 +1537,8 @@ SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  children.push(Child(_node_manager->getAvailableChildId(),S_TEMP,V_TEMP,TYPE_FLOAT));
-  children.push(Child(_node_manager->getAvailableChildId(),S_HUM,V_HUM,TYPE_FLOAT));
+  new ChildFloat(this,_node_manager->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node_manager->getAvailableChildId(),S_HUM,V_HUM);
   // initialize the library
   Wire.begin();
 }
@@ -1549,7 +1563,7 @@ void SensorSHT21::onLoop(Child* child) {
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) child->setValue<float>(temperature);
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
   }
   // Humidity Sensor
   else if (child->type == V_HUM) {
@@ -1564,15 +1578,15 @@ void SensorSHT21::onLoop(Child* child) {
       Serial.println(humidity);
     #endif
     // store the value
-   if (! isnan(humidity)) child->setValue<float>(humidity);
+   if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
   }
 }
 
 // what to do as the main task when receiving a message
-void SensorSHT21::onReceive(const MyMessage & message) {
-  Child* child = getChild(message.sensor);
+void SensorSHT21::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message.getCommand() == C_REQ) onLoop(child);
+  if (message->getCommand() == C_REQ) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -3692,14 +3706,14 @@ void NodeManager::loop() {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
       _msg.clear();
       sensor->interrupt();
-      sensor->loop(_msg);
+      sensor->loop(nullptr);
         // reset the last interrupt pin
       _last_interrupt_pin = -1;
     }
     else if (_last_interrupt_pin == -1) {
       // if just at the end of a cycle, call the sensor's loop() 
       _msg.clear();
-      sensor->loop(_msg);
+      sensor->loop(nullptr);
     }
   }
   #if POWER_MANAGER == 1
diff --git a/NodeManager.h b/NodeManager.h
index 76595a8..f212ec2 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -178,6 +178,7 @@
    Classes
 */
 class NodeManager;
+class Sensor;
 
 /*
  * List
@@ -331,25 +332,59 @@ class Request {
 class Child {
   public:
     Child();
-    Child(int child_id, int presentation, int type, int value_type, char* description);
+    Child(Sensor* sensor, int child_id, int presentation, int type, char* description);
     int child_id;
     int presentation = S_CUSTOM;
     int type = V_CUSTOM;
     char* description = "";
-    int value_type = TYPE_INTEGER;
-    template<typename T> void setValue(T value);
-    template<typename T> T getValue();
-    template<typename T> void setLastValue(T value);
-    template<typename T> T getLastValue();
+    virtual void sendValue();
+  protected:
+    int _samples = 0;
+    Sensor* _sensor;
+  private:
+};
+
+class ChildInt: public Child {
+  public:
+    ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueInt(int value);
+    void sendValue();
   private:
-    int _value_int = -255;
-    float _value_float = -255;
-    double _value_double = -255;
-    char * _value_string = "";
-    int _last_value_int = -255;
-    float _last_value_float = -255;
-    double _last_value_double = -255;
-    char * _last_value_string = "";
+    int _value = -255;
+    int _last_value = -255;
+    int _total = 0;
+};
+
+class ChildFloat: public Child {
+  public:
+    ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueFloat(float value);
+    void sendValue();
+  private:
+    float _value = -255;
+    float _last_value = -255;
+    float _total = 0;
+};
+
+class ChildString: public Child {
+  public:
+    ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueString(char* value);
+    void sendValue();
+  private:
+    char* _value = "";
+    char* _last_value = "";
+};
+
+class ChildDouble: public Child {
+  public:
+    ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueDouble(double value);
+    void sendValue();
+  private:
+    double _value = -255;
+    double _last_value = -255;
+    double _total = 0;
 };
 
 /***************************************
@@ -389,8 +424,10 @@ class Sensor {
     int getValueType();
     // [11] for float values, set the float precision (default: 2)
     void  setFloatPrecision(int value);
+    int getFloatPrecision();
     // [21] for double values, set the double precision (default: 4)
     void  setDoublePrecision(int value);
+    int getDoublePrecision();
     #if POWER_MANAGER == 1
       // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
       void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
@@ -421,27 +458,29 @@ class Sensor {
     void before();
     void presentation();
     void setup();
-    void loop(const MyMessage & message);
+    void loop(MyMessage* message);
     void interrupt();
     void receive(const MyMessage & message);
     // abstract functions, subclasses need to implement
     virtual void onBefore();
     virtual void onSetup();
     virtual void onLoop(Child* child);
-    virtual void onReceive(const MyMessage & message);
+    virtual void onReceive(MyMessage* message);
     virtual void onProcess(Request & request);
     virtual void onInterrupt();
-    List<Child> children;
+    List<Child*> children;
     Child* getChild(int child_id);
+    // register a child
+    void registerChild(Child* child);
+    NodeManager* _node_manager;
   protected:
     const __FlashStringHelper* _name;
     MyMessage* _msg;
-    NodeManager* _node_manager;
     int _pin = -1;
     int _samples = 1;
     int _samples_interval = 0;
-    bool _track_last_value = false;
     int _float_precision = 2;
+    bool _track_last_value = false;
     int _double_precision = 4;
     int _interrupt_pin = -1;
     #if POWER_MANAGER  == 1
@@ -483,7 +522,7 @@ class SensorBattery: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -507,7 +546,7 @@ class SensorSignal: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -535,7 +574,7 @@ class SensorAnalogInput: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -576,7 +615,7 @@ class SensorThermistor: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -598,7 +637,7 @@ class SensorML8511: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -620,7 +659,7 @@ class SensorACS712: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -657,7 +696,7 @@ class SensorDigitalInput: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
 };
@@ -688,7 +727,7 @@ class SensorDigitalOutput: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -746,7 +785,7 @@ class SensorDHT: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
     // constants
@@ -771,7 +810,7 @@ class SensorSHT21: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
     // constants
@@ -811,7 +850,7 @@ class SensorSwitch: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -856,7 +895,7 @@ class SensorDs18b20: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -881,7 +920,7 @@ class SensorBH1750: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -900,7 +939,7 @@ class SensorMLX90614: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
     // constants
@@ -927,7 +966,7 @@ class SensorBosch: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
     // constants
@@ -1007,7 +1046,7 @@ class SensorHCSR04: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1035,7 +1074,7 @@ class SensorSonoff: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1065,7 +1104,7 @@ class SensorMCP9808: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1106,7 +1145,7 @@ class SensorMQ: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1149,7 +1188,7 @@ class SensorMHZ19: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1170,7 +1209,7 @@ class SensorAM2320: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
     // constants
@@ -1201,7 +1240,7 @@ class SensorTSL2561: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
     // constants
@@ -1239,7 +1278,7 @@ class SensorPT100: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1273,7 +1312,7 @@ class SensorDimmer: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1302,7 +1341,7 @@ class SensorPulseMeter: public Sensor {
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
-    void onReceive(const MyMessage & message);
+    void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
   protected:
@@ -1365,7 +1404,7 @@ class NodeManager {
     // [20] optionally sleep interval in milliseconds before sending each message to the radio network (default: 0)
     void setSleepBetweenSend(int value);
     int getSleepBetweenSend();
-    // register a custom sensor
+    // register a sensor
     void registerSensor(Sensor* sensor);
     #if POWER_MANAGER == 1
       // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
diff --git a/NodeManager.ino b/NodeManager.ino
index 2e0a111..4d14e9c 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -24,14 +24,14 @@ Documentation available on: https://github.com/mysensors/NodeManager
 // create a NodeManager instance
 NodeManager nodeManager;
 //SensorSHT21 sht(nodeManager);
-//SensorBattery battery(nodeManager);
+SensorBattery battery(nodeManager);
 //SensorSignal signal(nodeManager);
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);  
-//  battery.setReportIntervalSeconds(20);
+  battery.setReportIntervalSeconds(10);
 
 //nodeManager.sensors.get(0)->setPin(5);
 //nodeManager.sensors.get(0)->children.get(0).child_id = 5;

From a182af64ff3f5c1ee83b05e393fdbe592fcf7615 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 12:28:24 +0100
Subject: [PATCH 15/51] New architecture for sendMessage()

---
 NodeManager.cpp | 248 +++++++++++++++---------------------------------
 NodeManager.h   |  48 +++-------
 2 files changed, 91 insertions(+), 205 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 724b1e4..85e547d 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -163,7 +163,8 @@ float Timer::getElapsed() {
     Request
 */
 
-Request::Request(const char* string) {
+Request::Request(int child_id, const char* string) {
+  _child_id = child_id;
   char* ptr;
   // copy to working area
   strcpy((char*)&_value, string);
@@ -185,6 +186,11 @@ Request::Request(const char* string) {
   #endif
 }
 
+// return the child id
+int Request::getChildId() {
+  return _child_id;
+}
+
 // return the parsed function
 int Request::getFunction() {
   return _function;
@@ -248,11 +254,7 @@ void ChildInt::sendValue() {
   if (_total == -255) return;
   int avg = (int) (_total / _samples);
   _last_value = avg;
-  MyMessage* msg = _sensor->_node_manager->getMessage();
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(avg);
-  _sensor->_node_manager->sendMessage();
+  _sensor->_node_manager->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -272,11 +274,7 @@ void ChildFloat::sendValue() {
   if (_total == -255) return;
   float avg = _total / _samples;
   _last_value = avg;
-  MyMessage* msg = _sensor->_node_manager->getMessage();
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(avg,_sensor->getFloatPrecision());
-  _sensor->_node_manager->sendMessage();
+  _sensor->_node_manager->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -296,11 +294,7 @@ void ChildDouble::sendValue() {
   if (_total == -255) return;
   double avg = _total / _samples;
   _last_value = avg;
-  MyMessage* msg = _sensor->_node_manager->getMessage();
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(avg,_sensor->getDoublePrecision());
-  _sensor->_node_manager->sendMessage();
+  _sensor->_node_manager->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -315,12 +309,8 @@ void ChildString::setValueString(char* value) {
 
 // send the value back to the controller
 void ChildString::sendValue() {
-  MyMessage* msg = _sensor->_node_manager->getMessage();
   _last_value = _value;
-  msg->setSensor(child_id);
-  msg->setType(type);
-  msg->set(_value);
-  _sensor->_node_manager->sendMessage();
+  _sensor->_node_manager->sendMessage(child_id,type,_value);
   _value = "";
 }
 
@@ -351,27 +341,6 @@ void Sensor::setPin(int value) {
 int Sensor::getPin() {
   return _pin;
 }
-void Sensor::setChildId(int value) {
-  _child_id = value;
-}
-int Sensor::getChildId() {
-  return _child_id;
-}
-void Sensor::setPresentation(int value) {
-  _presentation = value;
-}
-int Sensor::getPresentation() {
-  return _presentation;
-}
-void Sensor::setType(int value) {
-  _type = value;
-}
-int Sensor::getType() {
-  return _type;
-}
-void Sensor::setDescription(char* value) {
-  _description = value;
-}
 void Sensor::setSamples(int value) {
   _samples = value;
 }
@@ -387,25 +356,6 @@ void Sensor::setForceUpdateMinutes(int value) {
 void Sensor::setForceUpdateHours(int value) {
   _force_update_timer->start(value,HOURS);
 }
-void Sensor::setValueType(int value) {
-  _value_type = value;
-}
-int Sensor::getValueType() {
-  return _value_type;
-}
-void Sensor::setFloatPrecision(int value) {
-  _float_precision = value;
-}
-int Sensor::getFloatPrecision() {
-  return _float_precision;
-}
-void Sensor::setDoublePrecision(int value) {
-  _double_precision = value;
-}
-int Sensor::getDoublePrecision() {
-  return _double_precision;
-}
-
 #if POWER_MANAGER == 1
     void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
       _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
@@ -520,19 +470,14 @@ void Sensor::loop(MyMessage* message) {
   // iterates over all the children
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
-    // for numeric sensor requiring multiple samples, keep track of the total
-    double total = 0;
+    // if a specific child is requested, skip all the others
+    if (message != nullptr && message->sensor != child->child_id) continue;
     // collect multiple samples if needed
     for (int i = 0; i < _samples; i++) {
-      // call the sensor-specific implementation of the main task which will store the result in the _value variable
-      if (message != nullptr) {
-        // we've been called from receive(), pass the message along
-        onReceive(message);
-      }
-      else {
-        // we'be been called from loop()
-        onLoop(child);
-      }
+      // we've been called from receive(), pass the message along
+      if (message != nullptr) onReceive(message);
+      // we'be been called from loop()
+      else onLoop(child);
       // wait between samples
       if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
     }
@@ -555,22 +500,19 @@ void Sensor::interrupt() {
 
 // receive a message from the radio network
 void Sensor::receive(const MyMessage &message) {
-  // return if not for this sensor
-  if (message.sensor != _child_id) return;
   // check if it is a request for the API
   if (message.getCommand() == C_REQ && message.type == V_CUSTOM) {
     #if REMOTE_CONFIGURATION == 1
       // parse the request
-      Request request = Request(message.getString());
+      Request request = Request(message.sensor,message.getString());
       // if it is for a sensor-generic function, call process(), otherwise the sensor-specific onProcess();
       if (request.getFunction() < 100) process(request);
       else onProcess(request);
     #endif
+  } else {
+    // a request would make the sensor executing its main task passing along the message
+    loop(&message);
   }
-  // return if the type is not correct
-  if (message.type != _type) return;
-  // a request would make the sensor executing its main task passing along the message
-  loop(&message);
 }
 
 // process a remote configuration request message
@@ -578,15 +520,11 @@ void Sensor::process(Request & request) {
   int function = request.getFunction();
   switch(function) {
     case 1: setPin(request.getValueInt()); break;
-    case 2: setChildId(request.getValueInt()); break;
-    case 3: setType(request.getValueInt()); break;
-    case 4: setDescription(request.getValueString()); break;
     case 5: setSamples(request.getValueInt()); break;
     case 6: setSamplesInterval(request.getValueInt()); break;
     case 7: setTrackLastValue(request.getValueInt()); break;
     case 9: setForceUpdateMinutes(request.getValueInt()); break;
     case 10: setValueType(request.getValueInt()); break;
-    case 11: setFloatPrecision(request.getValueInt()); break;
     #if POWER_MANAGER == 1
       case 12: setAutoPowerPins(request.getValueInt()); break;
       case 13: powerOn(); break;
@@ -597,10 +535,9 @@ void Sensor::process(Request & request) {
     case 19: setReportIntervalHours(request.getValueInt()); break;
     case 20: setReportIntervalDays(request.getValueInt()); break;
     case 18: setForceUpdateHours(request.getValueInt()); break;
-    case 21: setDoublePrecision(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // return the requested child 
@@ -620,28 +557,6 @@ void Sensor::onReceive(MyMessage* message){}
 void Sensor::onProcess(Request & request){}
 void Sensor::onInterrupt(){}
 
-// send a message to the network
-void Sensor::_sendSensorMessage(MyMessage & message) {
-	// setup the message
-	message.setSensor(_child_id);
-	message.setType(_type);
-	_node_manager->sendMessage();
-  }
-
-// send a message to the network
-void Sensor::_sendServiceMessage(MyMessage & message) {
-	// setup the message
-	message.setSensor(_child_id);
-	message.setType(V_CUSTOM);
-	_node_manager->sendMessage();
-}
-
-// return true if the message is coming from the radio network
-bool Sensor::_isReceive(const MyMessage & message) {
-  if (message.sender == 0 && message.sensor == 0 && message.getCommand() == 0 && message.type == 0) return false;
-  return true;
-}
-
 // determine if a value is worth sending back to the controller
 bool Sensor::_isWorthSending(bool comparison) {
   // track last value is disabled
@@ -687,7 +602,7 @@ void SensorBattery::setBatteryReportWithInterrupt(bool value) {
 
 // what to do during before
 void SensorBattery::onBefore() {
-  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);  
+  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);
 }
 
 // what to do during setup
@@ -736,7 +651,7 @@ void SensorBattery::onProcess(Request & request) {
     case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -792,7 +707,7 @@ void SensorSignal::onProcess(Request & request) {
     case 101: setSignalCommand(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -871,7 +786,7 @@ void SensorAnalogInput::onProcess(Request & request) {
     case 105: setRangeMax(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1000,7 +915,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1126,7 +1041,7 @@ void SensorACS712::onProcess(Request & request) {
     case 102: setOffset(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1292,7 +1207,7 @@ void SensorDigitalOutput::onProcess(Request & request) {
     case 107: setWaitAfterSet(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1418,7 +1333,7 @@ void SensorLatchingRelay::onProcess(Request & request) {
     case 203: setPinOn(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // switch to the requested status
@@ -1662,7 +1577,7 @@ void SensorSwitch::onProcess(Request & request) {
     case 104: setInitial(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1768,7 +1683,7 @@ void SensorDs18b20::onProcess(Request & request) {
     case 102: setSleepDuringConversion(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1845,7 +1760,7 @@ void SensorBH1750::onProcess(Request & request) {
     case 101: setMode(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 
@@ -1971,7 +1886,7 @@ void SensorBosch::onProcess(Request & request) {
     case 101: setForecastSamplesCount(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2306,7 +2221,7 @@ void SensorHCSR04::onProcess(Request & request) {
     case 103: setMaxDistance(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2391,7 +2306,7 @@ void SensorSonoff::onProcess(Request & request) {
     case 103: setLedPin(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2590,7 +2505,7 @@ void SensorMQ::onProcess(Request & request) {
     case 8: setReadSampleInterval(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2745,7 +2660,7 @@ void SensorMHZ19::onProcess(Request & request) {
   switch(function) {
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2962,7 +2877,7 @@ void SensorTSL2561::onProcess(Request & request) {
     case 104: setAddress(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3024,7 +2939,7 @@ void SensorPT100::onProcess(Request & request) {
     case 101: setVoltageRef(request.getValueFloat()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3093,7 +3008,7 @@ void SensorDimmer::onProcess(Request & request) {
     case 103: setStepDuration(request.getValueInt()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3195,7 +3110,7 @@ void SensorPulseMeter::onProcess(Request & request) {
     case 102: setPulseFactor(request.getValueFloat()); break;
     default: return;
   }
-  _sendServiceMessage(_msg->set(function));
+  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3253,7 +3168,7 @@ SensorWaterMeter::SensorWaterMeter(NodeManager* node_manager, int child_id, int
 // initialize the node manager
 NodeManager::NodeManager() {
   // setup the message container
-  _msg = MyMessage();
+  _message = MyMessage();
 }
 
 int NodeManager::_last_interrupt_pin = -1;
@@ -3269,7 +3184,7 @@ int NodeManager::getRetries() {
   return _retries;
 }
 MyMessage* NodeManager::getMessage() {
-	return &_msg;
+	return &_message;
 }
 
 
@@ -3704,7 +3619,7 @@ void NodeManager::loop() {
     Sensor* sensor = *itr;
     if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
       // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
-      _msg.clear();
+      _message.clear();
       sensor->interrupt();
       sensor->loop(nullptr);
         // reset the last interrupt pin
@@ -3712,7 +3627,7 @@ void NodeManager::loop() {
     }
     else if (_last_interrupt_pin == -1) {
       // if just at the end of a cycle, call the sensor's loop() 
-      _msg.clear();
+      _message.clear();
       sensor->loop(nullptr);
     }
   }
@@ -3742,7 +3657,7 @@ void NodeManager::receive(const MyMessage &message) {
   if (message.sensor == CONFIGURATION_CHILD_ID && message.getCommand() == C_REQ && message.type == V_CUSTOM) {
     #if REMOTE_CONFIGURATION == 1
       // parse the request
-      Request request = Request(message.getString());
+      Request request = Request(message.sensor,message.getString());
       // process the request
       process(request);
     #endif
@@ -3822,7 +3737,7 @@ void NodeManager::process(Request & request) {
       case 6: reboot(); return;
     #endif
     case 7: clearEeprom(); break;
-    case 8: version(); return;
+    case 8: sendMessage(request.getChildId(),V_CUSTOM,VERSION); return;
     case 9: wakeup(); break;
     case 10: setRetries(request.getValueInt()); break;
     case 19: setSleepInterruptPin(request.getValueInt()); break;
@@ -3845,7 +3760,7 @@ void NodeManager::process(Request & request) {
     case 39: setReportIntervalDays(request.getValueInt()); break;
     default: return; 
   }
-  _sendUsingConfigChild(_msg.set(function));
+  sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 
@@ -3872,11 +3787,6 @@ void NodeManager::reboot() {
   }
 }
 
-// send NodeManager's the version back to the controller
-void NodeManager::version() {
-	_sendUsingConfigChild(_msg.set(VERSION));
-}
-
 // clear the EEPROM
 void NodeManager::clearEeprom() {
   #if DEBUG == 1
@@ -4044,54 +3954,54 @@ void NodeManager::_onInterrupt_2() {
   }
 }
 
-// send a message to the network using CONFIGURATION_CHILD_ID, V_CUSTOM
-void NodeManager::_sendUsingConfigChild(MyMessage & message) {
-	// setup the message
-	message.setSensor(CONFIGURATION_CHILD_ID);
-	message.setType(V_CUSTOM);
-	sendMessage();
+// send a message by providing the source child, type of the message and value
+void NodeManager::sendMessage(int child_id, int type, int value) {
+  _message.clear();
+  _message.set(value);
+  _sendMessage(child_id,type);
 }
-
-// send a message to the network using BATTERY_CHILD_ID, V_VOLTAGE
-void NodeManager::_sendUsingBatteryChild(MyMessage & message) {
-	// setup the message
-	message.setSensor(BATTERY_CHILD_ID);
-	message.setType(V_VOLTAGE);
-	sendMessage();
+void NodeManager::sendMessage(int child_id, int type, float value) {
+  _message.clear();
+  _message.set(value,2);
+  _sendMessage(child_id,type);
 }
-
-// send a message to the network using SIGNAL_CHILD_ID, V_LEVEL
-void NodeManager::_sendUsingSignalChild(MyMessage & message) {
-	// setup the message
-	message.setSensor(SIGNAL_CHILD_ID);
-	message.setType(V_LEVEL);
-	sendMessage();
+void NodeManager::sendMessage(int child_id, int type, double value) {
+  _message.clear();
+  _message.set(value,4);
+  _sendMessage(child_id,type);
+}
+void NodeManager::sendMessage(int child_id, int type, const char* value) {
+  _message.clear();
+  _message.set(value);
+  _sendMessage(child_id,type);
 }
-
 
 // send a message to the network
-void NodeManager::sendMessage() {
+void NodeManager::_sendMessage(int child_id, int type) {
+  // prepare the message
+  _message.setSensor(child_id);
+  _message.setType(type);
   // send the message, multiple times if requested
   for (int i = 0; i < _retries; i++) {
     // if configured, sleep beetween each send
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
     #if DEBUG == 1
       Serial.print(F("SEND D="));
-		Serial.print(_msg.destination);
+		  Serial.print(_message.destination);
       Serial.print(F(" I="));
-		Serial.print(_msg.sensor);
+		  Serial.print(_message.sensor);
       Serial.print(F(" C="));
-		Serial.print(_msg.getCommand());
+		  Serial.print(_message.getCommand());
       Serial.print(F(" T="));
-		Serial.print(_msg.type);
+		  Serial.print(_message.type);
       Serial.print(F(" S="));
-		Serial.print(_msg.getString());
+		  Serial.print(_message.getString());
       Serial.print(F(" I="));
-		Serial.print(_msg.getInt());
+		  Serial.print(_message.getInt());
       Serial.print(F(" F="));
-		Serial.println(_msg.getFloat());
+		  Serial.println(_message.getFloat());
     #endif
-		send(_msg, _ack);
+		send(_message, _ack);
   }
 }
 
diff --git a/NodeManager.h b/NodeManager.h
index f212ec2..c453e35 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -309,7 +309,9 @@ class Timer {
 
 class Request {
   public:
-    Request(const char* string);
+    Request(int child_id, const char* string);
+    // return the child id
+    int getChildId();
     // return the parsed function
     int getFunction();
     // return the value as an int
@@ -321,7 +323,8 @@ class Request {
    private:
     NodeManager* _node_manager;
     int _function;
-	// Size of buffer to prevent overrun 
+    int _child_id;
+	  // Size of buffer to prevent overrun 
     char _value[MAX_PAYLOAD+1];
 };
 
@@ -398,17 +401,6 @@ class Sensor {
     // [1] where the sensor is attached to (default: not set)
     void setPin(int value);
     int getPin();
-    // [2] child_id of this sensor (default: not set)
-    void setChildId(int value);
-    int getChildId();
-    // presentation of this sensor (default: S_CUSTOM)
-    void setPresentation(int value);
-    int getPresentation();
-    // [3] type of this sensor (default: V_CUSTOM)
-    void setType(int value);
-    int getType();
-    // [4] description of the sensor (default: '')
-    void setDescription(char *value);
     // [5] For some sensors, the measurement can be queried multiple times and an average is returned (default: 1)
     void setSamples(int value);
     // [6] If more then one sample has to be taken, set the interval in milliseconds between measurements (default: 0)
@@ -422,12 +414,6 @@ class Sensor {
     // [10] the value type of this sensor (default: TYPE_INTEGER)
     void setValueType(int value);
     int getValueType();
-    // [11] for float values, set the float precision (default: 2)
-    void  setFloatPrecision(int value);
-    int getFloatPrecision();
-    // [21] for double values, set the double precision (default: 4)
-    void  setDoublePrecision(int value);
-    int getDoublePrecision();
     #if POWER_MANAGER == 1
       // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
       void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
@@ -479,9 +465,7 @@ class Sensor {
     int _pin = -1;
     int _samples = 1;
     int _samples_interval = 0;
-    int _float_precision = 2;
     bool _track_last_value = false;
-    int _double_precision = 4;
     int _interrupt_pin = -1;
     #if POWER_MANAGER  == 1
       PowerManager _powerManager;
@@ -489,15 +473,7 @@ class Sensor {
     #endif
     Timer* _report_timer;
     Timer* _force_update_timer;
-    void _sendSensorMessage(MyMessage & msg);
-    void _sendServiceMessage(MyMessage & msg);
-    bool _isReceive(const MyMessage & message);
     bool _isWorthSending(bool comparison);
-    int _child_id;
-    int _presentation = S_CUSTOM;
-    int _type = V_CUSTOM;
-    char* _description = "";
-    int _value_type = TYPE_INTEGER;
 };
 
 /*
@@ -1434,8 +1410,6 @@ class NodeManager {
     void hello();
     // [6] reboot the board
     void reboot();
-    // [8] send NodeManager's the version back to the controller
-    void version();
     // [7] clear the EEPROM
     void clearEeprom();
     // [9] wake up the board
@@ -1479,7 +1453,11 @@ class NodeManager {
     static void _onInterrupt_1();
     static void _onInterrupt_2();
 	  MyMessage* getMessage();
-	  void sendMessage();
+    // send a message by providing the source child, type of the message and value
+	  void sendMessage(int child_id, int type, int value);
+    void sendMessage(int child_id, int type, float value);
+    void sendMessage(int child_id, int type, double value);
+    void sendMessage(int child_id, int type, const char* value);
     int getAvailableChildId();
     List<Sensor*> sensors;
     Child* getChild(int child_id);
@@ -1490,10 +1468,8 @@ class NodeManager {
       PowerManager _powerManager;
       bool _auto_power_pins = true;
     #endif
-    MyMessage _msg;
-    void _sendUsingConfigChild(MyMessage & msg);
-    void _sendUsingBatteryChild(MyMessage & msg);
-    void _sendUsingSignalChild(MyMessage & msg);
+    MyMessage _message;
+    void _sendMessage(int child_id, int type);
     int _status = AWAKE;
     long _sleep_time = 0;
     int _sleep_interrupt_pin = -1;

From e098a3e13cbe9cd47062c0d3ef5038cda979b86f Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 16:20:29 +0100
Subject: [PATCH 16/51] Deprecated PERSIST (adding 122 bytes)

---
 NodeManager.cpp | 51 ++++++++++++++++++++-----------------------------
 NodeManager.h   | 19 ++++++------------
 NodeManager.ino |  4 ++--
 config.h        |  6 ++----
 4 files changed, 31 insertions(+), 49 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 85e547d..6cb50ba 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -314,9 +314,6 @@ void ChildString::sendValue() {
   _value = "";
 }
 
-
-
-
 /*
    Sensor class
 */
@@ -415,13 +412,13 @@ void Sensor::registerChild(Child* child) {
 void Sensor::presentation() {
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
-  #if DEBUG == 1
-    Serial.print(F("PRES I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" T="));
-    Serial.println(child->presentation);
-  #endif
-  present(child->child_id, child->presentation,child->description,_node_manager->getAck());
+    #if DEBUG == 1
+      Serial.print(F("PRES I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(child->presentation);
+    #endif
+    present(child->child_id, child->presentation,child->description,_node_manager->getAck());
   }
 
 }
@@ -516,7 +513,7 @@ void Sensor::receive(const MyMessage &message) {
 }
 
 // process a remote configuration request message
-void Sensor::process(Request & request) {
+void Sensor::process(const Request & request) {
   int function = request.getFunction();
   switch(function) {
     case 1: setPin(request.getValueInt()); break;
@@ -524,7 +521,6 @@ void Sensor::process(Request & request) {
     case 6: setSamplesInterval(request.getValueInt()); break;
     case 7: setTrackLastValue(request.getValueInt()); break;
     case 9: setForceUpdateMinutes(request.getValueInt()); break;
-    case 10: setValueType(request.getValueInt()); break;
     #if POWER_MANAGER == 1
       case 12: setAutoPowerPins(request.getValueInt()); break;
       case 13: powerOn(); break;
@@ -641,6 +637,7 @@ void SensorBattery::onReceive(MyMessage* message) {
 
 // what to do when receiving a remote message
 void SensorBattery::onProcess(Request & request) {
+#if REMOTE_CONFIGURATION == 1
   int function = request.getFunction();
   switch(function) {
     case 102: setMinVoltage(request.getValueFloat()); break;
@@ -652,6 +649,7 @@ void SensorBattery::onProcess(Request & request) {
     default: return;
   }
   _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+#endif
 }
 
 // what to do when receiving an interrupt
@@ -702,12 +700,14 @@ void SensorSignal::onReceive(MyMessage* message) {
 
 // what to do when receiving a remote message
 void SensorSignal::onProcess(Request & request) {
+#if REMOTE_CONFIGURATION == 1
   int function = request.getFunction();
   switch(function) {
     case 101: setSignalCommand(request.getValueInt()); break;
     default: return;
   }
   _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+#endif
 }
 
 // what to do when receiving an interrupt
@@ -3194,6 +3194,8 @@ void NodeManager::setSleepSeconds(int value) {
   else _status = SLEEP;
   // store the time
   _sleep_time = value;
+  // save sleep settings to eeprom
+  if (_save_sleep_settings) _saveSleepSettings();
 }
 void NodeManager::setSleepMinutes(int value) {
   setSleepSeconds(value*60);
@@ -3258,6 +3260,9 @@ void NodeManager::setIsMetric(bool value) {
 bool NodeManager::getIsMetric() {
   return _is_metric;
 }
+void NodeManager::setSaveSleepSettings(bool value) {
+  _save_sleep_settings = value;
+}
 
 // Convert a temperature from celsius to fahrenheit depending on how isMetric is set
 float NodeManager::celsiusToFahrenheit(float temperature) {
@@ -3550,10 +3555,8 @@ void NodeManager::before() {
     Serial.print(F(" B="));
     Serial.println(MY_CAP_RXBUF);
   #endif
-  #if PERSIST == 1
-    // restore the configuration saved in the eeprom
-    _loadConfig();
-  #endif
+  // restore the sleep settings saved in the eeprom
+  if (_save_sleep_settings) _loadSleepSettings();
   // setup individual sensors
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3711,27 +3714,15 @@ void NodeManager::process(Request & request) {
     case 1: hello(); break;
     case 3:
       setSleepSeconds(request.getValueInt());
-      #if PERSIST == 1
-        _saveConfig();
-      #endif
       break;
     case 4:
       setSleepMinutes(request.getValueInt());
-      #if PERSIST == 1
-        _saveConfig();
-      #endif
       break;
     case 5:
       setSleepHours(request.getValueInt());
-      #if PERSIST == 1
-        _saveConfig();
-      #endif
       break;
     case 29:
       setSleepDays(request.getValueInt());
-      #if PERSIST == 1
-        _saveConfig();
-      #endif
       break;
     #ifndef MY_GATEWAY_ESP8266
       case 6: reboot(); return;
@@ -4089,7 +4080,7 @@ int NodeManager::_getInterruptInitialValue(int mode) {
 }
 
 // load the configuration stored in the eeprom
-void NodeManager::_loadConfig() {
+void NodeManager::_loadSleepSettings() {
   if (loadState(EEPROM_SLEEP_SAVED) == 1) {
     // load sleep settings
     int bit_1 = loadState(EEPROM_SLEEP_1);
@@ -4104,7 +4095,7 @@ void NodeManager::_loadConfig() {
 }
 
 // save the configuration in the eeprom
-void NodeManager::_saveConfig() {
+void NodeManager::_saveSleepSettings() {
   if (_sleep_time == 0) return;
   // encode the sleep time in 3 bits
   int bit_1, bit_2, bit_3 = 0;
diff --git a/NodeManager.h b/NodeManager.h
index c453e35..60d3bc6 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -68,11 +68,6 @@
 #ifndef REMOTE_CONFIGURATION
   #define REMOTE_CONFIGURATION 1
 #endif
-// if enabled, persist the configuration settings on EEPROM
-#ifndef PERSIST
-  #define PERSIST 0
-#endif
-
 // the child id used to allow remote configuration
 #ifndef CONFIGURATION_CHILD_ID
   #define CONFIGURATION_CHILD_ID 200
@@ -435,7 +430,7 @@ class Sensor {
     // return true if the report interval has been already configured
     bool isReportIntervalConfigured();
     // process a remote request
-    void process(Request & request);
+    void process(const Request & request);
     // return the pin the interrupt is attached to
     int getInterruptPin();
     // listen for interrupts on the given pin so interrupt() will be called when occurring
@@ -789,12 +784,7 @@ class SensorSHT21: public Sensor {
     void onReceive(MyMessage* message);
     void onProcess(Request & request);
     void onInterrupt();
-    // constants
-    const static int TEMPERATURE = 0;
-    const static int HUMIDITY = 1;
   protected:
-    float _offset = 0;
-    int _sensor_type = 0;
 };
 
 /*
@@ -1442,6 +1432,8 @@ class NodeManager {
     void setRebootPin(int value);
     // [32] turn the ADC off so to save 0.2 mA
     void setADCOff();
+    // [30] if set save the sleep settings in memory, also when changed remotely (default: false)
+    void setSaveSleepSettings(bool value);
     // hook into the main sketch functions
     void before();
     void presentation();
@@ -1493,8 +1485,9 @@ class NodeManager {
     int _report_interval_seconds = 10*60;
     bool _sleep_or_wait = true;
     int _reboot_pin = -1;
-    void _loadConfig();
-    void _saveConfig();
+    bool _save_sleep_settings = false;
+    void _loadSleepSettings();
+    void _saveSleepSettings();
     int _child_id_counter = 0;
 };
 
diff --git a/NodeManager.ino b/NodeManager.ino
index 4d14e9c..cdb2292 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -24,14 +24,14 @@ Documentation available on: https://github.com/mysensors/NodeManager
 // create a NodeManager instance
 NodeManager nodeManager;
 //SensorSHT21 sht(nodeManager);
-SensorBattery battery(nodeManager);
+//SensorBattery battery(nodeManager);
 //SensorSignal signal(nodeManager);
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);  
-  battery.setReportIntervalSeconds(10);
+  //battery.setReportIntervalSeconds(10);
 
 //nodeManager.sensors.get(0)->setPin(5);
 //nodeManager.sensors.get(0)->children.get(0).child_id = 5;
diff --git a/config.h b/config.h
index dabb0e3..8961a3c 100755
--- a/config.h
+++ b/config.h
@@ -111,14 +111,12 @@
  */
 
 // if enabled, enable debug messages on serial port
-#define DEBUG 1
+#define DEBUG 0
 
 // if enabled, enable the capability to power on sensors with the arduino's pins to save battery while sleeping
 #define POWER_MANAGER 0
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
 #define REMOTE_CONFIGURATION 0
-// if enabled, persist the remote configuration settings on EEPROM
-#define PERSIST 0
 
 // Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
 #define MODULE_ANALOG_INPUT 0
@@ -129,7 +127,7 @@
 // Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
 #define MODULE_DHT 0
 // Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
-#define MODULE_SHT21 1
+#define MODULE_SHT21 0
 // Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION
 #define MODULE_SWITCH 0
 // Enable this module to use one of the following sensors: SENSOR_DS18B20

From c100a3cc70cf0e70e42fbb2dfbfa04ba55e22740 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 16:30:13 +0100
Subject: [PATCH 17/51] Removed _msg instance from Sensor

---
 NodeManager.cpp | 9 +--------
 NodeManager.h   | 2 --
 2 files changed, 1 insertion(+), 10 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 6cb50ba..a871cc0 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -318,14 +318,11 @@ void ChildString::sendValue() {
    Sensor class
 */
 // constructor
-Sensor::Sensor() {
-  
+Sensor::Sensor() {  
 }
-
 Sensor::Sensor(NodeManager& nodeManager, int pin) {
   _node_manager = &nodeManager;
   _pin = pin;
-  _msg = _node_manager->getMessage();
   _report_timer = new Timer(_node_manager);
   _force_update_timer = new Timer(_node_manager);
   _node_manager->registerSensor(this);
@@ -3183,10 +3180,6 @@ void NodeManager::setRetries(int value) {
 int NodeManager::getRetries() {
   return _retries;
 }
-MyMessage* NodeManager::getMessage() {
-	return &_message;
-}
-
 
 void NodeManager::setSleepSeconds(int value) {
   // set the status to AWAKE if the time provided is 0, SLEEP otherwise
diff --git a/NodeManager.h b/NodeManager.h
index 60d3bc6..36468fe 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -456,7 +456,6 @@ class Sensor {
     NodeManager* _node_manager;
   protected:
     const __FlashStringHelper* _name;
-    MyMessage* _msg;
     int _pin = -1;
     int _samples = 1;
     int _samples_interval = 0;
@@ -1444,7 +1443,6 @@ class NodeManager {
     // handle interrupts
     static void _onInterrupt_1();
     static void _onInterrupt_2();
-	  MyMessage* getMessage();
     // send a message by providing the source child, type of the message and value
 	  void sendMessage(int child_id, int type, int value);
     void sendMessage(int child_id, int type, float value);

From 4a6f41df53aa6fadd07f65bdab106f1826a8e132 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 17:13:55 +0100
Subject: [PATCH 18/51] Sensor no more requiring a pin

---
 NodeManager.cpp | 126 ++++++++++++++++++++++--------------------------
 NodeManager.h   |   9 ++--
 NodeManager.ino |  28 +++++------
 config.h        |   2 +-
 4 files changed, 77 insertions(+), 88 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index a871cc0..f3501d2 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -62,7 +62,7 @@ void PowerManager::powerOff() {
 */
 
 Timer::Timer(NodeManager* node_manager) {
-  _node_manager = node_manager;
+  _node = node_manager;
 }
 
 // start the timer
@@ -92,7 +92,7 @@ void Timer::restart() {
   stop();
   reset();
   // if using millis(), keep track of the current timestamp for calculating the difference
-  if (! _node_manager->isSleepingNode()) _last_millis = millis();
+  if (! _node->isSleepingNode()) _last_millis = millis();
   start();
 }
 
@@ -117,9 +117,9 @@ void Timer::unset() {
 // update the timer at every cycle
 void Timer::update() {
   if (! isRunning()) return;
-  if (_node_manager->isSleepingNode()) {
+  if (_node->isSleepingNode()) {
     // millis() is not reliable while sleeping so calculate how long a sleep cycle would last in seconds and update the elapsed time
-    _elapsed += _node_manager->getSleepSeconds();
+    _elapsed += _node->getSleepSeconds();
   } else {
     // use millis() to calculate the elapsed time in seconds
     _elapsed = (long)((millis() - _last_millis)/1000);
@@ -254,7 +254,7 @@ void ChildInt::sendValue() {
   if (_total == -255) return;
   int avg = (int) (_total / _samples);
   _last_value = avg;
-  _sensor->_node_manager->sendMessage(child_id,type,avg);
+  _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -274,7 +274,7 @@ void ChildFloat::sendValue() {
   if (_total == -255) return;
   float avg = _total / _samples;
   _last_value = avg;
-  _sensor->_node_manager->sendMessage(child_id,type,avg);
+  _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -294,7 +294,7 @@ void ChildDouble::sendValue() {
   if (_total == -255) return;
   double avg = _total / _samples;
   _last_value = avg;
-  _sensor->_node_manager->sendMessage(child_id,type,avg);
+  _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
 }
 
@@ -310,7 +310,7 @@ void ChildString::setValueString(char* value) {
 // send the value back to the controller
 void ChildString::sendValue() {
   _last_value = _value;
-  _sensor->_node_manager->sendMessage(child_id,type,_value);
+  _sensor->_node->sendMessage(child_id,type,_value);
   _value = "";
 }
 
@@ -320,12 +320,12 @@ void ChildString::sendValue() {
 // constructor
 Sensor::Sensor() {  
 }
-Sensor::Sensor(NodeManager& nodeManager, int pin) {
-  _node_manager = &nodeManager;
+Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
+  _node = &nodeManager;
   _pin = pin;
-  _report_timer = new Timer(_node_manager);
-  _force_update_timer = new Timer(_node_manager);
-  _node_manager->registerSensor(this);
+  _report_timer = new Timer(_node);
+  _force_update_timer = new Timer(_node);
+  _node->registerSensor(this);
 }
 
 // setter/getter
@@ -397,7 +397,7 @@ bool Sensor::isReportIntervalConfigured() {
 // listen for interrupts on the given pin so interrupt() will be called when occurring
 void Sensor::setInterrupt(int pin, int mode, int initial) {
   _interrupt_pin = pin;
-  _node_manager->setInterrupt(pin,mode,initial);
+  _node->setInterrupt(pin,mode,initial);
 }
 
 // register a child
@@ -415,14 +415,13 @@ void Sensor::presentation() {
       Serial.print(F(" T="));
       Serial.println(child->presentation);
     #endif
-    present(child->child_id, child->presentation,child->description,_node_manager->getAck());
+    present(child->child_id, child->presentation,child->description,_node->getAck());
   }
 
 }
 
 // call the sensor-specific implementation of before
 void Sensor::before() {
-  if (_pin == -1) return;
   onBefore();
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
@@ -440,7 +439,6 @@ void Sensor::before() {
 
 // call the sensor-specific implementation of setup
 void Sensor::setup() {
-  if (_pin == -1) return;
   onSetup();
 }
 
@@ -473,7 +471,7 @@ void Sensor::loop(MyMessage* message) {
       // we'be been called from loop()
       else onLoop(child);
       // wait between samples
-      if (_samples_interval > 0) _node_manager->sleepOrWait(_samples_interval);
+      if (_samples_interval > 0) _node->sleepOrWait(_samples_interval);
     }
     // process the result and send a response back
     child->sendValue();
@@ -530,7 +528,7 @@ void Sensor::process(const Request & request) {
     case 18: setForceUpdateHours(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // return the requested child 
@@ -607,7 +605,7 @@ void SensorBattery::onSetup() {
 void SensorBattery::onLoop(Child* child) {
   // measure the board vcc
   float volt = 0;
-  if (_battery_internal_vcc || _battery_pin == -1) volt = _node_manager->getVcc();
+  if (_battery_internal_vcc || _battery_pin == -1) volt = _node->getVcc();
   else volt = analogRead(_battery_pin) * _battery_volts_per_bit;
   // calculate the percentage
   int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
@@ -645,7 +643,7 @@ void SensorBattery::onProcess(Request & request) {
     case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 #endif
 }
 
@@ -703,7 +701,7 @@ void SensorSignal::onProcess(Request & request) {
     case 101: setSignalCommand(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 #endif
 }
 
@@ -783,7 +781,7 @@ void SensorAnalogInput::onProcess(Request & request) {
     case 105: setRangeMax(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -883,7 +881,7 @@ void SensorThermistor::onLoop(Child* child) {
   temperature += 1.0 / (_nominal_temperature + 273.15); // + (1/To)
   temperature = 1.0 / temperature;                 // Invert
   temperature -= 273.15;                         // convert to C
-  temperature = _node_manager->celsiusToFahrenheit(temperature);
+  temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("THER I="));
     Serial.print(_child_id);
@@ -912,7 +910,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -945,7 +943,7 @@ void SensorML8511::onSetup() {
 void SensorML8511::onLoop(Child* child) {
   // read the voltage 
   int uvLevel = analogRead(_pin);
-  int refLevel = _node_manager->getVcc()*1024/3.3;
+  int refLevel = _node->getVcc()*1024/3.3;
   //Use the 3.3V power pin as a reference to get a very accurate output value from sensor
   float outputVoltage = 3.3 / refLevel * uvLevel;
   //Convert the voltage to a UV intensity level
@@ -1038,7 +1036,7 @@ void SensorACS712::onProcess(Request & request) {
     case 102: setOffset(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1204,7 +1202,7 @@ void SensorDigitalOutput::onProcess(Request & request) {
     case 107: setWaitAfterSet(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1232,7 +1230,7 @@ void SensorDigitalOutput::setStatus(int value) {
   }
   _setStatus(value);
   // wait if needed for relay drawing a lot of current
-  if (_wait_after_set > 0) _node_manager->sleepOrWait(_wait_after_set);
+  if (_wait_after_set > 0) _node->sleepOrWait(_wait_after_set);
   // store the new status so it will be sent to the controller
   _status = value;
   _value_int = value;
@@ -1330,7 +1328,7 @@ void SensorLatchingRelay::onProcess(Request & request) {
     case 203: setPinOn(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // switch to the requested status
@@ -1340,7 +1338,7 @@ void SensorLatchingRelay::_setStatus(int value) {
   // set the value
   digitalWrite(pin, _on_value);
   // wait for the given time before restoring the value to the original value after the pulse
-  _node_manager->sleepOrWait(_pulse_width);
+  _node->sleepOrWait(_pulse_width);
   digitalWrite(pin, ! _on_value);
   #if DEBUG == 1
     Serial.print(F("LAT I="));
@@ -1393,13 +1391,13 @@ void SensorDHT::onSetup() {
 
 // what to do during loop
 void SensorDHT::onLoop(Child* child) {
-  _node_manager->sleepOrWait(_dht->getMinimumSamplingPeriod());
+  _node->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
   if (_sensor_type == SensorDHT::TEMPERATURE) {
     // read the temperature
     float temperature = _dht->getTemperature();
-    if (! _node_manager->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
+    if (! _node->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("DHT I="));
       Serial.print(_child_id);
@@ -1443,14 +1441,14 @@ void SensorDHT::onInterrupt() {
 */
 #if MODULE_SHT21 == 1
 // contructor
-SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager,A2) {
+SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
   _name = F("SHT");
 }
 
 // what to do during before
 void SensorSHT21::onBefore() {
-  new ChildFloat(this,_node_manager->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node_manager->getAvailableChildId(),S_HUM,V_HUM);
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
   // initialize the library
   Wire.begin();
 }
@@ -1466,7 +1464,7 @@ void SensorSHT21::onLoop(Child* child) {
     // read the temperature
     float temperature = SHT2x.GetTemperature();
     // convert it
-    temperature = _node_manager->celsiusToFahrenheit(temperature);
+    temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -1574,13 +1572,13 @@ void SensorSwitch::onProcess(Request & request) {
     case 104: setInitial(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
 void SensorSwitch::onInterrupt() {
   // wait to ensure the the input is not floating
-  if (_debounce > 0) _node_manager->sleepOrWait(_debounce);
+  if (_debounce > 0) _node->sleepOrWait(_debounce);
   // read the value of the pin
   int value = digitalRead(_pin);
   // process the value
@@ -1595,7 +1593,7 @@ void SensorSwitch::onInterrupt() {
     #endif
     _value_int = value;
     // allow the signal to be restored to its normal value
-    if (_trigger_time > 0) _node_manager->sleepOrWait(_trigger_time);
+    if (_trigger_time > 0) _node->sleepOrWait(_trigger_time);
   } else {
     // invalid
     _value_int = -1;
@@ -1656,7 +1654,7 @@ void SensorDs18b20::onLoop(Child* child) {
   // read the temperature
   float temperature = _sensors->getTempCByIndex(_index);
   // convert it
-  temperature = _node_manager->celsiusToFahrenheit(temperature);
+  temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("DS18B20 I="));
     Serial.print(_child_id);
@@ -1680,7 +1678,7 @@ void SensorDs18b20::onProcess(Request & request) {
     case 102: setSleepDuringConversion(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1757,7 +1755,7 @@ void SensorBH1750::onProcess(Request & request) {
     case 101: setMode(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 
@@ -1794,7 +1792,7 @@ void SensorMLX90614::onSetup() {
 void SensorMLX90614::onLoop(Child* child) {
   float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
   // convert it
-  temperature = _node_manager->celsiusToFahrenheit(temperature);
+  temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("MLX I="));
     Serial.print(_child_id);
@@ -1883,7 +1881,7 @@ void SensorBosch::onProcess(Request & request) {
     case 101: setForecastSamplesCount(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2013,7 +2011,7 @@ void SensorBME280::onLoop(Child* child) {
     // read the temperature
     float temperature = _bme->readTemperature();
     // convert it
-    temperature = _node_manager->celsiusToFahrenheit(temperature);
+    temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("BME I="));
       Serial.print(_child_id);
@@ -2077,7 +2075,7 @@ void SensorBMP085::onLoop(Child* child) {
     // read the temperature
     float temperature = _bmp->readTemperature();
     // convert it
-    temperature = _node_manager->celsiusToFahrenheit(temperature);
+    temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("BMP I="));
       Serial.print(_child_id);
@@ -2124,7 +2122,7 @@ void SensorBMP280::onLoop(Child* child) {
     // read the temperature
     float temperature = _bmp->readTemperature();
     // convert it
-    temperature = _node_manager->celsiusToFahrenheit(temperature);
+    temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
       Serial.print(F("BMP I="));
       Serial.print(_child_id);
@@ -2194,7 +2192,7 @@ void SensorHCSR04::onSetup() {
 
 // what to do during loop
 void SensorHCSR04::onLoop(Child* child) {
-  int distance = _node_manager->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
+  int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
   #if DEBUG == 1
     Serial.print(F("HC I="));
     Serial.print(_child_id);
@@ -2218,7 +2216,7 @@ void SensorHCSR04::onProcess(Request & request) {
     case 103: setMaxDistance(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2303,7 +2301,7 @@ void SensorSonoff::onProcess(Request & request) {
     case 103: setLedPin(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2364,7 +2362,7 @@ void SensorMCP9808::onSetup() {
 void SensorMCP9808::onLoop(Child* child) {
   float temperature = _mcp->readTempC();
   // convert it
-  temperature = _node_manager->celsiusToFahrenheit(temperature);
+  temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("MCP I="));
     Serial.print(_child_id);
@@ -2455,7 +2453,6 @@ void SensorMQ::onSetup() {
 
 // what to do during loop
 void SensorMQ::onLoop(Child* child) {
-  if (_pin == -1) return;
   // calculate rs/ro
   float mq = _MQRead()/_ro;
   // calculate the ppm
@@ -2502,7 +2499,7 @@ void SensorMQ::onProcess(Request & request) {
     case 8: setReadSampleInterval(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2657,7 +2654,7 @@ void SensorMHZ19::onProcess(Request & request) {
   switch(function) {
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2874,7 +2871,7 @@ void SensorTSL2561::onProcess(Request & request) {
     case 104: setAddress(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2936,7 +2933,7 @@ void SensorPT100::onProcess(Request & request) {
     case 101: setVoltageRef(request.getValueFloat()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3005,7 +3002,7 @@ void SensorDimmer::onProcess(Request & request) {
     case 103: setStepDuration(request.getValueInt()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3079,7 +3076,7 @@ void SensorPulseMeter::onSetup() {
 // what to do during loop
 void SensorPulseMeter::onLoop(Child* child) {
   // do not report anything if called by an interrupt
-  if (_node_manager->getLastInterruptPin() == _interrupt_pin) return;
+  if (_node->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
   _reportTotal();
   #if DEBUG == 1
@@ -3107,7 +3104,7 @@ void SensorPulseMeter::onProcess(Request & request) {
     case 102: setPulseFactor(request.getValueFloat()); break;
     default: return;
   }
-  _node_manager->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3911,7 +3908,7 @@ int NodeManager::getAvailableChildId() {
     Child* child = getChild(i);
     if (child == nullptr) return i;
   }
-  return 255;
+  return 254;
 }
 
 // handle an interrupt
@@ -4065,13 +4062,6 @@ void NodeManager::_present(int child_id, int type) {
   present(child_id,type,"",_ack);
 }
 
-// guess the initial value of a digital output based on the configured interrupt mode
-int NodeManager::_getInterruptInitialValue(int mode) {
-  if (mode == RISING) return LOW; 
-  if (mode == FALLING) return HIGH; 
-  return -1;
-}
-
 // load the configuration stored in the eeprom
 void NodeManager::_loadSleepSettings() {
   if (loadState(EEPROM_SLEEP_SAVED) == 1) {
diff --git a/NodeManager.h b/NodeManager.h
index 36468fe..50d5caf 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -205,6 +205,7 @@ template<typename T> class List {
     if (_allocBlocks > _preAllocBlocks) _DeAllocOneBlock(false);
   }
   T get(int position) {
+    position = position -1;
     if (position > _endPosition) position = _endPosition;
     return _internalArray[position];
   }
@@ -289,7 +290,7 @@ class Timer {
     // return the current elapsed time
     float getElapsed();
    private:
-    NodeManager* _node_manager;
+    NodeManager* _node;
     int _target = 0;
     long _elapsed = 0;
     long _last_millis = 0;
@@ -316,7 +317,7 @@ class Request {
     // return the value as a string
     char* getValueString();
    private:
-    NodeManager* _node_manager;
+    NodeManager* _node;
     int _function;
     int _child_id;
 	  // Size of buffer to prevent overrun 
@@ -453,7 +454,7 @@ class Sensor {
     Child* getChild(int child_id);
     // register a child
     void registerChild(Child* child);
-    NodeManager* _node_manager;
+    NodeManager* _node;
   protected:
     const __FlashStringHelper* _name;
     int _pin = -1;
@@ -1477,7 +1478,6 @@ class NodeManager {
     bool _ack = false;
     void _sleep();
     void _present(int child_id, int type);
-    int _getInterruptInitialValue(int mode);
     bool _get_controller_config = true;
     int _is_metric = 1;
     int _report_interval_seconds = 10*60;
@@ -1486,7 +1486,6 @@ class NodeManager {
     bool _save_sleep_settings = false;
     void _loadSleepSettings();
     void _saveSleepSettings();
-    int _child_id_counter = 0;
 };
 
 #endif
diff --git a/NodeManager.ino b/NodeManager.ino
index cdb2292..24870db 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -22,19 +22,19 @@ Documentation available on: https://github.com/mysensors/NodeManager
 #include "NodeManager.h"
 
 // create a NodeManager instance
-NodeManager nodeManager;
-//SensorSHT21 sht(nodeManager);
-//SensorBattery battery(nodeManager);
-//SensorSignal signal(nodeManager);
+NodeManager node;
+SensorSHT21 sht(node);
+//SensorBattery battery(node);
+//SensorSignal signal(node);
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);  
   //battery.setReportIntervalSeconds(10);
-
-//nodeManager.sensors.get(0)->setPin(5);
-//nodeManager.sensors.get(0)->children.get(0).child_id = 5;
+//sht.children.get(1)->child_id = 5;
+//node.sensors.get(0)->setPin(5);
+//node.sensors.get(0)->children.get(0).child_id = 5;
 
 
 
@@ -47,42 +47,42 @@ void before() {
     pinMode(5, OUTPUT);
     digitalWrite(5, LOW);
     */
-  //nodeManager.setReportIntervalSeconds(20);
+  //node.setReportIntervalSeconds(20);
   
   
   
   /*
    * Register above your sensors
   */
-  nodeManager.before();
+  node.before();
 }
 
 // presentation
 void presentation() {
   // call NodeManager presentation routine
-  nodeManager.presentation();
+  node.presentation();
 }
 
 // setup
 void setup() {
   // call NodeManager setup routine
-  nodeManager.setup();
+  node.setup();
 }
 
 // loop
 void loop() {
   // call NodeManager loop routine
-  nodeManager.loop();
+  node.loop();
 }
 
 // receive
 void receive(const MyMessage &message) {
   // call NodeManager receive routine
-  nodeManager.receive(message);
+  node.receive(message);
 }
 
 // receiveTime
 void receiveTime(unsigned long ts) {
   // call NodeManager receiveTime routine
-  nodeManager.receiveTime(ts);
+  node.receiveTime(ts);
 }
diff --git a/config.h b/config.h
index 8961a3c..bc1aef7 100755
--- a/config.h
+++ b/config.h
@@ -127,7 +127,7 @@
 // Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
 #define MODULE_DHT 0
 // Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
-#define MODULE_SHT21 0
+#define MODULE_SHT21 1
 // Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION
 #define MODULE_SWITCH 0
 // Enable this module to use one of the following sensors: SENSOR_DS18B20

From 08fa8886827ede830b8478901967e8d2d045e219 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 17:36:04 +0100
Subject: [PATCH 19/51] Fixed child not resetting samples and total

---
 NodeManager.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index f3501d2..0fb3b6f 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -256,6 +256,8 @@ void ChildInt::sendValue() {
   _last_value = avg;
   _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
+  _total = -255;
+  _samples = 0;
 }
 
 // ChildFloat class
@@ -276,6 +278,8 @@ void ChildFloat::sendValue() {
   _last_value = avg;
   _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
+  _total = -255;
+  _samples = 0;
 }
 
 // ChildDouble class
@@ -296,6 +300,8 @@ void ChildDouble::sendValue() {
   _last_value = avg;
   _sensor->_node->sendMessage(child_id,type,avg);
   _value = -255;
+  _total = -255;
+  _samples = 0;
 }
 
 // ChildString class
@@ -447,6 +453,7 @@ void Sensor::loop(MyMessage* message) {
   // update the timers if within a loop cycle
   if (message == nullptr) {
     if (_report_timer->isRunning()) {
+      // keep track if it is the first time
       bool first_run = _report_timer->isFirstRun();
       // update the timer
       _report_timer->update();
@@ -480,7 +487,7 @@ void Sensor::loop(MyMessage* message) {
   #if POWER_MANAGER == 1
     if (_auto_power_pins) powerOff();
   #endif
-  // restart the report timer if over
+  // if called from loop(), restart the report timer if over
   if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
 }
 

From 52bbc2e4e5a1a558aafa0d76bf118866873bf43b Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 18:15:00 +0100
Subject: [PATCH 20/51] Added back track last value (176 bytes)

---
 NodeManager.cpp | 95 ++++++++++++++++++++++++++++---------------------
 NodeManager.h   |  9 +++--
 2 files changed, 61 insertions(+), 43 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 0fb3b6f..50c1bd2 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -233,77 +233,94 @@ Child::Child(Sensor* __sensor, int _child_id, int _presentation, int _type, char
   description = _description;
   _sensor = __sensor;
   _sensor->registerChild(this);
+  force_update_timer = new Timer(_sensor->_node);
 }
 // set a value, implemented by the subclasses
 void Child::sendValue() {
 }
 
+// check if it is an updated value, implemented by the subclasses
+bool Child::isNewValue() {
+}
+
 // ChildInt class
 ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
 
 // store a new value and update the total
 void ChildInt::setValueInt(int value) {
-  _samples++;
   _total = _total + value;
-  _value = value;
+  _samples++;
+  _value = (int) (_total / _samples);
 }
 
 // send the value back to the controller
 void ChildInt::sendValue() {
-  if (_total == -255) return;
-  int avg = (int) (_total / _samples);
-  _last_value = avg;
-  _sensor->_node->sendMessage(child_id,type,avg);
+  if (_value == -255) return;
+  _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
   _value = -255;
   _total = -255;
   _samples = 0;
 }
 
+// check if it is an updated value
+bool ChildInt::isNewValue() {
+  return _last_value != _value;
+}
+
 // ChildFloat class
 ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
 
 // store a new value and update the total
 void ChildFloat::setValueFloat(float value) {
-  _samples++;
   _total = _total + value;
-  _value = value;
+  _samples++;
+  _value = _total / _samples;
 }
 
 // send the value back to the controller
 void ChildFloat::sendValue() {
-  if (_total == -255) return;
-  float avg = _total / _samples;
-  _last_value = avg;
-  _sensor->_node->sendMessage(child_id,type,avg);
+  if (_value == -255) return;
+  _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
   _value = -255;
   _total = -255;
   _samples = 0;
 }
 
+// check if it is an updated value
+bool ChildFloat::isNewValue() {
+  return _last_value != _value;
+}
+
 // ChildDouble class
 ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
 
 // store a new value and update the total
 void ChildDouble::setValueDouble(double value) {
-  _samples++;
   _total = _total + value;
-  _value = value;
+  _samples++;
+  _value = _total / _samples;
 }
 
 // send the value back to the controller
 void ChildDouble::sendValue() {
-  if (_total == -255) return;
-  double avg = _total / _samples;
-  _last_value = avg;
-  _sensor->_node->sendMessage(child_id,type,avg);
+  if (_value == -255) return;
+  _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
   _value = -255;
   _total = -255;
   _samples = 0;
 }
 
+// check if it is an updated value
+bool ChildDouble::isNewValue() {
+  return _last_value != _value;
+}
+
 // ChildString class
 ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -315,11 +332,16 @@ void ChildString::setValueString(char* value) {
 
 // send the value back to the controller
 void ChildString::sendValue() {
-  _last_value = _value;
   _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
   _value = "";
 }
 
+// check if it is an updated value
+bool ChildString::isNewValue() {
+  return strcmp(_value, _last_value) != 0;
+}
+
 /*
    Sensor class
 */
@@ -330,7 +352,6 @@ Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
   _node = &nodeManager;
   _pin = pin;
   _report_timer = new Timer(_node);
-  _force_update_timer = new Timer(_node);
   _node->registerSensor(this);
 }
 
@@ -351,10 +372,13 @@ void Sensor::setTrackLastValue(bool value) {
   _track_last_value = value;
 }
 void Sensor::setForceUpdateMinutes(int value) {
-  _force_update_timer->start(value,MINUTES);
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
+    child->force_update_timer->start(value,MINUTES);
+  }
 }
 void Sensor::setForceUpdateHours(int value) {
-  _force_update_timer->start(value,HOURS);
+  setForceUpdateMinutes(value*60);
 }
 #if POWER_MANAGER == 1
     void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
@@ -460,7 +484,6 @@ void Sensor::loop(MyMessage* message) {
       // if it is not the time yet to report a new measure, just return (unless it is the first time)
       if (! _report_timer->isOver() && ! first_run) return;
     }
-    if (_force_update_timer->isRunning()) _force_update_timer->update();
   }
   #if POWER_MANAGER == 1
     // turn the sensor on
@@ -469,6 +492,8 @@ void Sensor::loop(MyMessage* message) {
   // iterates over all the children
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
+    // update the force update timer if running
+    if (child->force_update_timer->isRunning()) child->force_update_timer->update();
     // if a specific child is requested, skip all the others
     if (message != nullptr && message->sensor != child->child_id) continue;
     // collect multiple samples if needed
@@ -480,8 +505,13 @@ void Sensor::loop(MyMessage* message) {
       // wait between samples
       if (_samples_interval > 0) _node->sleepOrWait(_samples_interval);
     }
-    // process the result and send a response back
-    child->sendValue();
+    // process the result and send a response back if 1) is not a loop 2) not tracking last value 3) tracking last value and there is a new value 4) tracking last value and timer is over
+    if (
+      message != nullptr || 
+      ! _track_last_value || 
+      _track_last_value && child->isNewValue() || 
+      _track_last_value && child->force_update_timer->isRunning() && child->force_update_timer->isOver()) 
+        child->sendValue();
   }
   // turn the sensor off
   #if POWER_MANAGER == 1
@@ -555,21 +585,6 @@ void Sensor::onReceive(MyMessage* message){}
 void Sensor::onProcess(Request & request){}
 void Sensor::onInterrupt(){}
 
-// determine if a value is worth sending back to the controller
-bool Sensor::_isWorthSending(bool comparison) {
-  // track last value is disabled
-  if (! _track_last_value) return true;
-  // track value is enabled and the current value is different then the old value
-  if (_track_last_value && comparison) return true;
-  // track value is enabled and the timer is over
-  if (_track_last_value && _force_update_timer->isRunning() && _force_update_timer->isOver()) {
-    // restart the timer
-    _force_update_timer->restart();
-    return true;
-  }
-  return false;
-}
-
 /*
    SensorBattery
 */
diff --git a/NodeManager.h b/NodeManager.h
index 50d5caf..436c6f2 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -336,11 +336,12 @@ class Child {
     int presentation = S_CUSTOM;
     int type = V_CUSTOM;
     char* description = "";
+    Timer* force_update_timer;
     virtual void sendValue();
+    virtual bool isNewValue();
   protected:
     int _samples = 0;
     Sensor* _sensor;
-  private:
 };
 
 class ChildInt: public Child {
@@ -348,6 +349,7 @@ class ChildInt: public Child {
     ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueInt(int value);
     void sendValue();
+    bool isNewValue();
   private:
     int _value = -255;
     int _last_value = -255;
@@ -359,6 +361,7 @@ class ChildFloat: public Child {
     ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueFloat(float value);
     void sendValue();
+    bool isNewValue();
   private:
     float _value = -255;
     float _last_value = -255;
@@ -370,6 +373,7 @@ class ChildString: public Child {
     ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueString(char* value);
     void sendValue();
+    bool isNewValue();
   private:
     char* _value = "";
     char* _last_value = "";
@@ -380,6 +384,7 @@ class ChildDouble: public Child {
     ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueDouble(double value);
     void sendValue();
+    bool isNewValue();
   private:
     double _value = -255;
     double _last_value = -255;
@@ -467,8 +472,6 @@ class Sensor {
       bool _auto_power_pins = true;
     #endif
     Timer* _report_timer;
-    Timer* _force_update_timer;
-    bool _isWorthSending(bool comparison);
 };
 
 /*

From 391c3130a32c2b164a94a011d0ad534bedf70c4b Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 19:04:47 +0100
Subject: [PATCH 21/51] Deprecated POWER_MANAGER

---
 NodeManager.cpp | 114 ++++++++++++++++++++++--------------------------
 NodeManager.h   |  52 ++++++++--------------
 NodeManager.ino |   4 +-
 config.h        |   2 -
 4 files changed, 73 insertions(+), 99 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 50c1bd2..4c17718 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -8,6 +8,10 @@
    PowerManager
 */
 
+PowerManager::PowerManager(int ground_pin, int vcc_pin, int wait_time) {
+  setPowerPins(ground_pin, vcc_pin, wait_time);
+}
+
 // set the vcc and ground pin the sensor is connected to
 void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
   _ground_pin = ground_pin;
@@ -32,7 +36,6 @@ void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
   _wait = wait_time;
 }
 
-
 // turn on the sensor by activating its power pins
 void PowerManager::powerOn() {
   if (_vcc_pin == -1) return;
@@ -380,20 +383,18 @@ void Sensor::setForceUpdateMinutes(int value) {
 void Sensor::setForceUpdateHours(int value) {
   setForceUpdateMinutes(value*60);
 }
-#if POWER_MANAGER == 1
-    void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
-      _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
-    }
-    void Sensor::setAutoPowerPins(bool value) {
-      _auto_power_pins = value;
-    }
-    void Sensor::powerOn() {
-      _powerManager.powerOn();
-    }
-    void Sensor::powerOff() {
-      _powerManager.powerOff();
-    }
-#endif
+void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
+  if (_powerManager == nullptr) return;
+  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
+}
+void Sensor::powerOn() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOn();
+}
+void Sensor::powerOff() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOff();
+}
 int Sensor::getInterruptPin() {
   return _interrupt_pin;
 }
@@ -485,10 +486,8 @@ void Sensor::loop(MyMessage* message) {
       if (! _report_timer->isOver() && ! first_run) return;
     }
   }
-  #if POWER_MANAGER == 1
-    // turn the sensor on
-    if (_auto_power_pins) powerOn();
-  #endif
+  // turn the sensor on
+  powerOn();
   // iterates over all the children
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
@@ -514,9 +513,7 @@ void Sensor::loop(MyMessage* message) {
         child->sendValue();
   }
   // turn the sensor off
-  #if POWER_MANAGER == 1
-    if (_auto_power_pins) powerOff();
-  #endif
+  powerOff();
   // if called from loop(), restart the report timer if over
   if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
 }
@@ -553,11 +550,8 @@ void Sensor::process(const Request & request) {
     case 6: setSamplesInterval(request.getValueInt()); break;
     case 7: setTrackLastValue(request.getValueInt()); break;
     case 9: setForceUpdateMinutes(request.getValueInt()); break;
-    #if POWER_MANAGER == 1
-      case 12: setAutoPowerPins(request.getValueInt()); break;
-      case 13: powerOn(); break;
-      case 14: powerOff(); break;
-    #endif
+    case 13: powerOn(); break;
+    case 14: powerOff(); break;
     case 16: setReportIntervalMinutes(request.getValueInt()); break;
     case 17: setReportIntervalSeconds(request.getValueInt()); break;
     case 19: setReportIntervalHours(request.getValueInt()); break;
@@ -577,6 +571,11 @@ Child* Sensor::getChild(int child_id) {
   return nullptr;
 }
 
+void Sensor::setPowerManager(const PowerManager& powerManager) {
+  _powerManager = &powerManager;
+}
+
+
 // virtual functions
 void Sensor::onBefore() {}
 void Sensor::onSetup(){}
@@ -3237,20 +3236,18 @@ void NodeManager::setInterrupt(int pin, int mode, int initial) {
 void NodeManager::setInterruptMinDelta(long value) {
   _interrupt_min_delta = value;
 }
-#if POWER_MANAGER == 1
-  void NodeManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
-    _powerManager.setPowerPins(ground_pin, vcc_pin, wait_time);
-  }
-  void NodeManager::setAutoPowerPins(bool value) {
-    _auto_power_pins = value;  
-  }
-  void NodeManager::powerOn() {
-    _powerManager.powerOn();
-  }
-  void NodeManager::powerOff() {
-    _powerManager.powerOff();
-  }
-#endif
+void NodeManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
+  if (_powerManager == nullptr) return;
+  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
+}
+void NodeManager::powerOn() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOn();
+}
+void NodeManager::powerOff() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOff();
+}
 void NodeManager::setSleepBetweenSend(int value) {
   _sleep_between_send = value;
 }
@@ -3625,10 +3622,8 @@ void NodeManager::setup() {
 
 // run the main function for all the register sensors
 void NodeManager::loop() {
-  #if POWER_MANAGER == 1
-    // turn on the pin powering all the sensors
-    if (_auto_power_pins) powerOn();
-  #endif
+  // turn on the pin powering all the sensors
+  powerOn();
   // run loop for all the registered sensors
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3646,10 +3641,8 @@ void NodeManager::loop() {
       sensor->loop(nullptr);
     }
   }
-  #if POWER_MANAGER == 1
-    // turn off the pin powering all the sensors
-    if (_auto_power_pins) powerOff();
-  #endif
+  // turn off the pin powering all the sensors
+  powerOff();
   // continue/start sleeping as requested
   if (isSleepingNode()) _sleep();
 }
@@ -3680,16 +3673,12 @@ void NodeManager::receive(const MyMessage &message) {
   // dispatch the message to the registered sensor
   Sensor* sensor = getSensorWithChild(message.sensor);
   if (sensor != nullptr) {
-    #if POWER_MANAGER == 1
-      // turn on the pin powering all the sensors
-      if (_auto_power_pins) powerOn();
-    #endif
+    // turn on the pin powering all the sensors
+    powerOn();
     // call the sensor's receive()
     sensor->receive(message);
-    #if POWER_MANAGER == 1
-      // turn off the pin powering all the sensors
-      if (_auto_power_pins) powerOff();
-    #endif
+    // turn off the pin powering all the sensors
+    powerOff();
   }
 }
 
@@ -3747,11 +3736,8 @@ void NodeManager::process(Request & request) {
     case 20: setSleepBetweenSend(request.getValueInt()); break;
     case 21: setAck(request.getValueInt()); break;
     case 22: setIsMetric(request.getValueInt()); break;
-    #if POWER_MANAGER == 1
-      case 23: setAutoPowerPins(request.getValueInt()); break;
-      case 24: powerOn(); break;
-      case 25: powerOff(); break;
-    #endif
+    case 24: powerOn(); break;
+    case 25: powerOff(); break;
     case 27: saveToMemory(0,request.getValueInt()); break;
     case 28: setInterruptMinDelta(request.getValueInt()); break;
     case 30: setSleepOrWait(request.getValueInt()); break;
@@ -4008,6 +3994,10 @@ void NodeManager::_sendMessage(int child_id, int type) {
   }
 }
 
+void NodeManager::setPowerManager(const PowerManager& powerManager) {
+  _powerManager = &powerManager;
+}
+
 // return the requested child 
 Child* NodeManager::getChild(int child_id) {
   Sensor* sensor = getSensorWithChild(child_id);
diff --git a/NodeManager.h b/NodeManager.h
index 436c6f2..3a5e84e 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -60,10 +60,6 @@
   #define DEBUG 1
 #endif
 
-// if enabled, enable the capability to power on sensors with the arduino's pins to save battery while sleeping
-#ifndef POWER_MANAGER
-  #define POWER_MANAGER 1
-#endif
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
 #ifndef REMOTE_CONFIGURATION
   #define REMOTE_CONFIGURATION 1
@@ -245,9 +241,10 @@ template<typename T> class List {
 
 class PowerManager {
   public:
-    PowerManager() {};
+    PowerManager(int ground_pin, int vcc_pin, int wait_time = 50);
     // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
     void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // if enabled the pins will be automatically powered on while awake and off during sleeping
     // turns the power pins on
     void powerOn();
     // turns the power pins on
@@ -415,16 +412,12 @@ class Sensor {
     // [10] the value type of this sensor (default: TYPE_INTEGER)
     void setValueType(int value);
     int getValueType();
-    #if POWER_MANAGER == 1
-      // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
-      void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
-      // [12] if enabled the pins will be automatically powered on while awake and off during sleeping (default: true)
-      void setAutoPowerPins(bool value);
-      // [13] manually turn the power on
-      void powerOn();
-      // [14] manually turn the power off
-      void powerOff();
-    #endif
+    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
+    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // [13] manually turn the power on
+    void powerOn();
+    // [14] manually turn the power off
+    void powerOff();
     // [17] After how many minutes the sensor will report back its measure (default: 10 minutes)
     void setReportIntervalSeconds(int value);
     // [16] After how many minutes the sensor will report back its measure (default: 10 minutes)
@@ -459,6 +452,7 @@ class Sensor {
     Child* getChild(int child_id);
     // register a child
     void registerChild(Child* child);
+    void setPowerManager(const PowerManager& powerManager);
     NodeManager* _node;
   protected:
     const __FlashStringHelper* _name;
@@ -467,10 +461,7 @@ class Sensor {
     int _samples_interval = 0;
     bool _track_last_value = false;
     int _interrupt_pin = -1;
-    #if POWER_MANAGER  == 1
-      PowerManager _powerManager;
-      bool _auto_power_pins = true;
-    #endif
+    PowerManager* _powerManager = nullptr;
     Timer* _report_timer;
 };
 
@@ -1375,16 +1366,12 @@ class NodeManager {
     int getSleepBetweenSend();
     // register a sensor
     void registerSensor(Sensor* sensor);
-    #if POWER_MANAGER == 1
-      // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
-      void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
-      // [23] if enabled the pins will be automatically powered on while awake and off during sleeping (default: true)
-      void setAutoPowerPins(bool value);
-      // [24] manually turn the power on
-      void powerOn();
-      // [25] manually turn the power off
-      void powerOff();
-    #endif
+    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
+    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // [24] manually turn the power on
+    void powerOn();
+    // [25] manually turn the power off
+    void powerOff();
     // [21] set this to true if you want destination node to send ack back to this node (default: false)
     void setAck(bool value);
     bool getAck();
@@ -1452,16 +1439,13 @@ class NodeManager {
     void sendMessage(int child_id, int type, float value);
     void sendMessage(int child_id, int type, double value);
     void sendMessage(int child_id, int type, const char* value);
+    void setPowerManager(const PowerManager& powerManager);
     int getAvailableChildId();
     List<Sensor*> sensors;
     Child* getChild(int child_id);
     Sensor* getSensorWithChild(int child_id);
   private:
-    #if POWER_MANAGER == 1
-      // to optionally controller power pins
-      PowerManager _powerManager;
-      bool _auto_power_pins = true;
-    #endif
+    PowerManager* _powerManager = nullptr;
     MyMessage _message;
     void _sendMessage(int child_id, int type);
     int _status = AWAKE;
diff --git a/NodeManager.ino b/NodeManager.ino
index 24870db..f6b74cb 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -24,13 +24,15 @@ Documentation available on: https://github.com/mysensors/NodeManager
 // create a NodeManager instance
 NodeManager node;
 SensorSHT21 sht(node);
+PowerManager power(5,6);
 //SensorBattery battery(node);
 //SensorSignal signal(node);
 
 // before
 void before() {
   // setup the serial port baud rate
-  Serial.begin(MY_BAUD_RATE);  
+  Serial.begin(MY_BAUD_RATE);
+  node.setPowerManager(power);
   //battery.setReportIntervalSeconds(10);
 //sht.children.get(1)->child_id = 5;
 //node.sensors.get(0)->setPin(5);
diff --git a/config.h b/config.h
index bc1aef7..475e02f 100755
--- a/config.h
+++ b/config.h
@@ -113,8 +113,6 @@
 // if enabled, enable debug messages on serial port
 #define DEBUG 0
 
-// if enabled, enable the capability to power on sensors with the arduino's pins to save battery while sleeping
-#define POWER_MANAGER 0
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
 #define REMOTE_CONFIGURATION 0
 

From 24542a8f28b42a108be33d2501797576ff1a04b9 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Fri, 8 Dec 2017 19:41:10 +0100
Subject: [PATCH 22/51] Minor fixes

---
 NodeManager.cpp | 18 ++++++------------
 NodeManager.h   |  8 --------
 NodeManager.ino | 12 +++++++-----
 config.h        |  4 ++--
 4 files changed, 15 insertions(+), 27 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 4c17718..ed5b61c 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -380,9 +380,6 @@ void Sensor::setForceUpdateMinutes(int value) {
     child->force_update_timer->start(value,MINUTES);
   }
 }
-void Sensor::setForceUpdateHours(int value) {
-  setForceUpdateMinutes(value*60);
-}
 void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
   if (_powerManager == nullptr) return;
   _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
@@ -556,7 +553,6 @@ void Sensor::process(const Request & request) {
     case 17: setReportIntervalSeconds(request.getValueInt()); break;
     case 19: setReportIntervalHours(request.getValueInt()); break;
     case 20: setReportIntervalDays(request.getValueInt()); break;
-    case 18: setForceUpdateHours(request.getValueInt()); break;
     default: return;
   }
   _node->sendMessage(request.getChildId(),V_CUSTOM,function);
@@ -608,9 +604,6 @@ void SensorBattery::setBatteryPin(int value) {
 void SensorBattery::setBatteryVoltsPerBit(float value) {
   _battery_volts_per_bit = value;
 }
-void SensorBattery::setBatteryReportWithInterrupt(bool value) {
-  _battery_report_with_interrupt = value;
-}
 
 // what to do during before
 void SensorBattery::onBefore() {
@@ -619,6 +612,7 @@ void SensorBattery::onBefore() {
 
 // what to do during setup
 void SensorBattery::onSetup() {
+  // when measuring the battery from a pin, analog reference must be internal
   if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
 }
 
@@ -648,7 +642,7 @@ void SensorBattery::onLoop(Child* child) {
 void SensorBattery::onReceive(MyMessage* message) {
   Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ) onLoop(child);
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -661,7 +655,6 @@ void SensorBattery::onProcess(Request & request) {
     case 104: setBatteryInternalVcc(request.getValueInt()); break;
     case 105: setBatteryPin(request.getValueInt()); break;
     case 106: setBatteryVoltsPerBit(request.getValueFloat()); break;
-    case 107: setBatteryReportWithInterrupt(request.getValueInt()); break;
     default: return;
   }
   _node->sendMessage(request.getChildId(),V_CUSTOM,function);
@@ -711,7 +704,7 @@ void SensorSignal::onLoop(Child* child) {
 void SensorSignal::onReceive(MyMessage* message) {
   Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ) onLoop(child);
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -1468,6 +1461,7 @@ SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
 
 // what to do during before
 void SensorSHT21::onBefore() {
+  // register the child
   new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
   new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
   // initialize the library
@@ -1517,7 +1511,7 @@ void SensorSHT21::onLoop(Child* child) {
 void SensorSHT21::onReceive(MyMessage* message) {
   Child* child = getChild(message->sensor);
   if (child == nullptr) return;
-  if (message->getCommand() == C_REQ) onLoop(child);
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving a remote message
@@ -3661,7 +3655,7 @@ void NodeManager::receive(const MyMessage &message) {
     Serial.print(F(" P="));
     Serial.println(message.getString());
   #endif
-  // process incoming configuration message
+  // process incoming messages to the configuration child
   if (message.sensor == CONFIGURATION_CHILD_ID && message.getCommand() == C_REQ && message.type == V_CUSTOM) {
     #if REMOTE_CONFIGURATION == 1
       // parse the request
diff --git a/NodeManager.h b/NodeManager.h
index 3a5e84e..24c7cb6 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -407,11 +407,6 @@ class Sensor {
     void setTrackLastValue(bool value);
     // [9] if track last value is enabled, force to send an update after the configured number of minutes
     void setForceUpdateMinutes(int value);
-    // [19] if track last value is enabled, force to send an update after the configured number of hours
-    void setForceUpdateHours(int value);
-    // [10] the value type of this sensor (default: TYPE_INTEGER)
-    void setValueType(int value);
-    int getValueType();
     // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
     void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
     // [13] manually turn the power on
@@ -481,8 +476,6 @@ class SensorBattery: public Sensor {
       void setBatteryPin(int value);
       // [17] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
       void setBatteryVoltsPerBit(float value);
-      // [18] If true, wake up by an interrupt counts as a valid cycle for battery reports otherwise only uninterrupted sleep cycles would contribute (default: true)
-      void setBatteryReportWithInterrupt(bool value);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -493,7 +486,6 @@ class SensorBattery: public Sensor {
   protected:
       float _battery_min = 2.6;
       float _battery_max = 3.3;
-      bool _battery_report_with_interrupt = true;
       bool _battery_internal_vcc = true;
       int _battery_pin = -1;
       float _battery_volts_per_bit = 0.003363075;
diff --git a/NodeManager.ino b/NodeManager.ino
index f6b74cb..1c2dc57 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -8,7 +8,6 @@ NodeManager includes the following main components:
 - Built-in personalities: for the most common sensors, provide embedded code so to allow their configuration with a single line 
 Documentation available on: https://github.com/mysensors/NodeManager
 */
-
  
 // load user settings
 #include "config.h"
@@ -24,15 +23,18 @@ Documentation available on: https://github.com/mysensors/NodeManager
 // create a NodeManager instance
 NodeManager node;
 SensorSHT21 sht(node);
-PowerManager power(5,6);
-//SensorBattery battery(node);
-//SensorSignal signal(node);
+//PowerManager power(5,6);
+SensorBattery battery(node);
+SensorSignal signal(node);
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);
-  node.setPowerManager(power);
+  node.setReportIntervalSeconds(20);
+  node.setSleepSeconds(20);
+  
+  //node.setPowerManager(power);
   //battery.setReportIntervalSeconds(10);
 //sht.children.get(1)->child_id = 5;
 //node.sensors.get(0)->setPin(5);
diff --git a/config.h b/config.h
index 475e02f..d7ad974 100755
--- a/config.h
+++ b/config.h
@@ -111,10 +111,10 @@
  */
 
 // if enabled, enable debug messages on serial port
-#define DEBUG 0
+#define DEBUG 1
 
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
-#define REMOTE_CONFIGURATION 0
+#define REMOTE_CONFIGURATION 1
 
 // Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
 #define MODULE_ANALOG_INPUT 0

From 79ccdb74e520d73d0b6bc8216cac49a30fd17769 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 15:37:10 +0100
Subject: [PATCH 23/51] Deprecated REMOTE_CONFIGURATION (adding 160 bytes)

---
 NodeManager.cpp | 298 +++++++++++++++++++++++++-----------------------
 NodeManager.h   |  39 ++++---
 NodeManager.ino |   1 +
 config.h        |   3 -
 4 files changed, 183 insertions(+), 158 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index ed5b61c..5bd2a5a 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -166,20 +166,26 @@ float Timer::getElapsed() {
     Request
 */
 
-Request::Request(int child_id, const char* string) {
-  _child_id = child_id;
+// contructor, tokenize a request in the format "child_id,function,value"
+Request::Request(int recipient_child_id, const char* string) {
+  _recipient_child_id = recipient_child_id;
   char* ptr;
   // copy to working area
   strcpy((char*)&_value, string);
   // tokenize the string and split function from value
   strtok_r(_value, ",", &ptr);
-  // get function code
+  // get child id
+  _child_id = atoi(_value);
+  // get the function id
+  strtok_r(NULL, ",", &ptr);
   _function = atoi(_value);
   // move user data to working area
   strcpy(_value,ptr);
   #if DEBUG == 1
     Serial.print(F("REQ F="));
     Serial.print(getFunction());
+    Serial.print(F(" C="));
+    Serial.print(getChildId());
     Serial.print(F(" I="));
     Serial.print(getValueInt());
     Serial.print(F(" F="));
@@ -189,6 +195,11 @@ Request::Request(int child_id, const char* string) {
   #endif
 }
 
+// return the child id
+int Request::getRecipientChildId() {
+  return _recipient_child_id;
+}
+
 // return the child id
 int Request::getChildId() {
   return _child_id;
@@ -358,6 +369,11 @@ Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
   _node->registerSensor(this);
 }
 
+// return the name of the sensor
+char* Sensor::getName() {
+  return _name;
+}
+
 // setter/getter
 void Sensor::setPin(int value) {
   _pin = value;
@@ -523,39 +539,8 @@ void Sensor::interrupt() {
 
 // receive a message from the radio network
 void Sensor::receive(const MyMessage &message) {
-  // check if it is a request for the API
-  if (message.getCommand() == C_REQ && message.type == V_CUSTOM) {
-    #if REMOTE_CONFIGURATION == 1
-      // parse the request
-      Request request = Request(message.sensor,message.getString());
-      // if it is for a sensor-generic function, call process(), otherwise the sensor-specific onProcess();
-      if (request.getFunction() < 100) process(request);
-      else onProcess(request);
-    #endif
-  } else {
-    // a request would make the sensor executing its main task passing along the message
-    loop(&message);
-  }
-}
-
-// process a remote configuration request message
-void Sensor::process(const Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 1: setPin(request.getValueInt()); break;
-    case 5: setSamples(request.getValueInt()); break;
-    case 6: setSamplesInterval(request.getValueInt()); break;
-    case 7: setTrackLastValue(request.getValueInt()); break;
-    case 9: setForceUpdateMinutes(request.getValueInt()); break;
-    case 13: powerOn(); break;
-    case 14: powerOff(); break;
-    case 16: setReportIntervalMinutes(request.getValueInt()); break;
-    case 17: setReportIntervalSeconds(request.getValueInt()); break;
-    case 19: setReportIntervalHours(request.getValueInt()); break;
-    case 20: setReportIntervalDays(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  // a request would make the sensor executing its main task passing along the message
+  loop(&message);
 }
 
 // return the requested child 
@@ -577,15 +562,14 @@ void Sensor::onBefore() {}
 void Sensor::onSetup(){}
 void Sensor::onLoop(Child* child){}
 void Sensor::onReceive(MyMessage* message){}
-void Sensor::onProcess(Request & request){}
 void Sensor::onInterrupt(){}
 
 /*
    SensorBattery
 */
 // contructor
-SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-  _name = F("BAT");
+SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager) {
+  _name = "BAT";
   // report battery level every 60 minutes by default
   setReportIntervalMinutes(60);
 }
@@ -645,22 +629,6 @@ void SensorBattery::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving a remote message
-void SensorBattery::onProcess(Request & request) {
-#if REMOTE_CONFIGURATION == 1
-  int function = request.getFunction();
-  switch(function) {
-    case 102: setMinVoltage(request.getValueFloat()); break;
-    case 103: setMaxVoltage(request.getValueFloat()); break;
-    case 104: setBatteryInternalVcc(request.getValueInt()); break;
-    case 105: setBatteryPin(request.getValueInt()); break;
-    case 106: setBatteryVoltsPerBit(request.getValueFloat()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
-#endif
-}
-
 // what to do when receiving an interrupt
 void SensorBattery::onInterrupt() {
 }
@@ -669,8 +637,8 @@ void SensorBattery::onInterrupt() {
    SensorSignal
 */
 // contructor
-SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager,A2) {
-  _name = F("SIG");
+SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager) {
+  _name = "SIG";
   // report signal level every 60 minutes by default
   setReportIntervalMinutes(60);
 }
@@ -707,20 +675,126 @@ void SensorSignal::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving a remote message
-void SensorSignal::onProcess(Request & request) {
-#if REMOTE_CONFIGURATION == 1
+// what to do when receiving an interrupt
+void SensorSignal::onInterrupt() {
+}
+
+/*
+   SensorConfiguration
+*/
+// contructor
+SensorConfiguration::SensorConfiguration(NodeManager& nodeManager): Sensor(nodeManager) {
+  _name = "CONF";
+}
+
+// what to do during before
+void SensorConfiguration::onBefore() {
+  new ChildInt(this,CONFIGURATION_CHILD_ID,S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorConfiguration::onSetup() {
+
+}
+
+// what to do during loop
+void SensorConfiguration::onLoop(Child* child) {
+}
+
+// what to do as the main task when receiving a message
+void SensorConfiguration::onReceive(MyMessage* message) {
+  // parse the request
+  Request request = Request(message->sensor,message->getString());
   int function = request.getFunction();
-  switch(function) {
-    case 101: setSignalCommand(request.getValueInt()); break;
-    default: return;
+  int child_id = request.getChildId();
+  // if the message is for the board itself
+  if (child_id == 0) {
+    switch(function) {
+      case 1: _node->hello(); break;
+      case 3: _node->setSleepSeconds(request.getValueInt()); break;
+      case 4: _node->setSleepMinutes(request.getValueInt()); break;
+      case 5: _node->setSleepHours(request.getValueInt()); break;
+      case 29: _node->setSleepDays(request.getValueInt()); break;
+      #ifndef MY_GATEWAY_ESP8266
+        case 6: _node->reboot(); return;
+      #endif
+      case 7: _node->clearEeprom(); break;
+      case 8: _node->sendMessage(request.getChildId(),V_CUSTOM,VERSION); return;
+      case 9: _node->wakeup(); break;
+      case 10: _node->setRetries(request.getValueInt()); break;
+      case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
+      case 20: _node->setSleepBetweenSend(request.getValueInt()); break;
+      case 21: _node->setAck(request.getValueInt()); break;
+      case 22: _node->setIsMetric(request.getValueInt()); break;
+      case 24: _node->powerOn(); break;
+      case 25: _node->powerOff(); break;
+      case 27: _node->saveToMemory(0,request.getValueInt()); break;
+      case 28: _node->setInterruptMinDelta(request.getValueInt()); break;
+      case 30: _node->setSleepOrWait(request.getValueInt()); break;
+      case 31: _node->setRebootPin(request.getValueInt()); break;
+      case 32: _node->setADCOff(); break;
+      case 36: _node->setReportIntervalSeconds(request.getValueInt()); break;
+      case 37: _node->setReportIntervalMinutes(request.getValueInt()); break;
+      case 38: _node->setReportIntervalHours(request.getValueInt()); break;
+      case 39: _node->setReportIntervalDays(request.getValueInt()); break;
+      default: return; 
+    }
+  // the request is for a sensor
+  } else {
+    // retrieve the sensor the child is belonging to
+    Sensor* sensor = _node->getSensorWithChild(child_id);
+    if (sensor == nullptr) return;
+    // if the message is for a function common to all the sensors
+    if (request.getFunction() < 100) {
+      switch(function) {
+        case 1: sensor->setPin(request.getValueInt()); break;
+        case 5: sensor->setSamples(request.getValueInt()); break;
+        case 6: sensor->setSamplesInterval(request.getValueInt()); break;
+        case 7: sensor->setTrackLastValue(request.getValueInt()); break;
+        case 9: sensor->setForceUpdateMinutes(request.getValueInt()); break;
+        case 13: sensor->powerOn(); break;
+        case 14: sensor->powerOff(); break;
+        case 16: sensor->setReportIntervalMinutes(request.getValueInt()); break;
+        case 17: sensor->setReportIntervalSeconds(request.getValueInt()); break;
+        case 19: sensor->setReportIntervalHours(request.getValueInt()); break;
+        case 20: sensor->setReportIntervalDays(request.getValueInt()); break;
+        default: return;
+      }
+    } else {
+      // the message is for a function specific to a sensor
+      if (strcmp(sensor->getName(),"BAT") == 0) {
+        SensorBattery* custom_sensor = (SensorBattery*)sensor;
+        switch(function) {
+          case 102: custom_sensor->setMinVoltage(request.getValueFloat()); break;
+          case 103: custom_sensor->setMaxVoltage(request.getValueFloat()); break;
+          case 104: custom_sensor->setBatteryInternalVcc(request.getValueInt()); break;
+          case 105: custom_sensor->setBatteryPin(request.getValueInt()); break;
+          case 106: custom_sensor->setBatteryVoltsPerBit(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      if (strcmp(sensor->getName(),"SIG") == 0) {
+        SensorSignal* custom_sensor = (SensorSignal*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setSignalCommand(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #if MODULE_SHT21 == 1
+      if (strcmp(sensor->getName(),"SHT21") == 0) {
+        SensorSHT21* custom_sensor = (SensorSHT21*)sensor;
+        switch(function) {
+          default: return;
+        }
+      }
+      #endif
+    }
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
-#endif
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
-void SensorSignal::onInterrupt() {
+void SensorConfiguration::onInterrupt() {
 }
 
 
@@ -795,7 +869,7 @@ void SensorAnalogInput::onProcess(Request & request) {
     case 105: setRangeMax(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -924,7 +998,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1050,7 +1124,7 @@ void SensorACS712::onProcess(Request & request) {
     case 102: setOffset(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1216,7 +1290,7 @@ void SensorDigitalOutput::onProcess(Request & request) {
     case 107: setWaitAfterSet(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1342,7 +1416,7 @@ void SensorLatchingRelay::onProcess(Request & request) {
     case 203: setPinOn(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // switch to the requested status
@@ -1456,7 +1530,7 @@ void SensorDHT::onInterrupt() {
 #if MODULE_SHT21 == 1
 // contructor
 SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
-  _name = F("SHT");
+  _name = "SHT21";
 }
 
 // what to do during before
@@ -1587,7 +1661,7 @@ void SensorSwitch::onProcess(Request & request) {
     case 104: setInitial(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1693,7 +1767,7 @@ void SensorDs18b20::onProcess(Request & request) {
     case 102: setSleepDuringConversion(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -1770,7 +1844,7 @@ void SensorBH1750::onProcess(Request & request) {
     case 101: setMode(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 
@@ -1896,7 +1970,7 @@ void SensorBosch::onProcess(Request & request) {
     case 101: setForecastSamplesCount(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2231,7 +2305,7 @@ void SensorHCSR04::onProcess(Request & request) {
     case 103: setMaxDistance(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2316,7 +2390,7 @@ void SensorSonoff::onProcess(Request & request) {
     case 103: setLedPin(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2514,7 +2588,7 @@ void SensorMQ::onProcess(Request & request) {
     case 8: setReadSampleInterval(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2669,7 +2743,7 @@ void SensorMHZ19::onProcess(Request & request) {
   switch(function) {
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2886,7 +2960,7 @@ void SensorTSL2561::onProcess(Request & request) {
     case 104: setAddress(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -2948,7 +3022,7 @@ void SensorPT100::onProcess(Request & request) {
     case 101: setVoltageRef(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3017,7 +3091,7 @@ void SensorDimmer::onProcess(Request & request) {
     case 103: setStepDuration(request.getValueInt()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3119,7 +3193,7 @@ void SensorPulseMeter::onProcess(Request & request) {
     case 102: setPulseFactor(request.getValueFloat()); break;
     default: return;
   }
-  _node->sendMessage(request.getChildId(),V_CUSTOM,function);
+  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3580,8 +3654,6 @@ void NodeManager::presentation() {
   // Send the sketch version information to the gateway and Controller
   if (_sleep_between_send > 0) sleep(_sleep_between_send);
   sendSketchInfo(SKETCH_NAME,SKETCH_VERSION);
-  // present the service as a custom sensor to the controller
-  _present(CONFIGURATION_CHILD_ID, S_CUSTOM);
   // present each sensor
   for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
     Sensor* sensor = *itr;
@@ -3655,15 +3727,6 @@ void NodeManager::receive(const MyMessage &message) {
     Serial.print(F(" P="));
     Serial.println(message.getString());
   #endif
-  // process incoming messages to the configuration child
-  if (message.sensor == CONFIGURATION_CHILD_ID && message.getCommand() == C_REQ && message.type == V_CUSTOM) {
-    #if REMOTE_CONFIGURATION == 1
-      // parse the request
-      Request request = Request(message.sensor,message.getString());
-      // process the request
-      process(request);
-    #endif
-  }
   // dispatch the message to the registered sensor
   Sensor* sensor = getSensorWithChild(message.sensor);
   if (sensor != nullptr) {
@@ -3702,51 +3765,6 @@ void NodeManager::receiveTime(unsigned long ts) {
   #endif
 }
 
-// process a request message
-void NodeManager::process(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 1: hello(); break;
-    case 3:
-      setSleepSeconds(request.getValueInt());
-      break;
-    case 4:
-      setSleepMinutes(request.getValueInt());
-      break;
-    case 5:
-      setSleepHours(request.getValueInt());
-      break;
-    case 29:
-      setSleepDays(request.getValueInt());
-      break;
-    #ifndef MY_GATEWAY_ESP8266
-      case 6: reboot(); return;
-    #endif
-    case 7: clearEeprom(); break;
-    case 8: sendMessage(request.getChildId(),V_CUSTOM,VERSION); return;
-    case 9: wakeup(); break;
-    case 10: setRetries(request.getValueInt()); break;
-    case 19: setSleepInterruptPin(request.getValueInt()); break;
-    case 20: setSleepBetweenSend(request.getValueInt()); break;
-    case 21: setAck(request.getValueInt()); break;
-    case 22: setIsMetric(request.getValueInt()); break;
-    case 24: powerOn(); break;
-    case 25: powerOff(); break;
-    case 27: saveToMemory(0,request.getValueInt()); break;
-    case 28: setInterruptMinDelta(request.getValueInt()); break;
-    case 30: setSleepOrWait(request.getValueInt()); break;
-    case 31: setRebootPin(request.getValueInt()); break;
-    case 32: setADCOff(); break;
-    case 36: setReportIntervalSeconds(request.getValueInt()); break;
-    case 37: setReportIntervalMinutes(request.getValueInt()); break;
-    case 38: setReportIntervalHours(request.getValueInt()); break;
-    case 39: setReportIntervalDays(request.getValueInt()); break;
-    default: return; 
-  }
-  sendMessage(request.getChildId(),V_CUSTOM,function);
-}
-
-
 // Send a hello message back to the controller
 void NodeManager::hello() {
   // do nothing, the request will be echoed back
diff --git a/NodeManager.h b/NodeManager.h
index 24c7cb6..e81034e 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -61,9 +61,6 @@
 #endif
 
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
-#ifndef REMOTE_CONFIGURATION
-  #define REMOTE_CONFIGURATION 1
-#endif
 // the child id used to allow remote configuration
 #ifndef CONFIGURATION_CHILD_ID
   #define CONFIGURATION_CHILD_ID 200
@@ -303,7 +300,9 @@ class Timer {
 class Request {
   public:
     Request(int child_id, const char* string);
-    // return the child id
+    // return the child id the message has been requested to
+    int getRecipientChildId();
+    // return the child id the request is for
     int getChildId();
     // return the parsed function
     int getFunction();
@@ -314,9 +313,9 @@ class Request {
     // return the value as a string
     char* getValueString();
    private:
-    NodeManager* _node;
-    int _function;
-    int _child_id;
+    int _function = -1;
+    int _child_id = -1;
+    int _recipient_child_id = -1;
 	  // Size of buffer to prevent overrun 
     char _value[MAX_PAYLOAD+1];
 };
@@ -396,6 +395,8 @@ class Sensor {
   public:
     Sensor();
     Sensor(NodeManager& nodeManager, int pin);
+    // return the name of the sensor
+    char* getName();
     // [1] where the sensor is attached to (default: not set)
     void setPin(int value);
     int getPin();
@@ -423,8 +424,6 @@ class Sensor {
     void setReportIntervalDays(int value);
     // return true if the report interval has been already configured
     bool isReportIntervalConfigured();
-    // process a remote request
-    void process(const Request & request);
     // return the pin the interrupt is attached to
     int getInterruptPin();
     // listen for interrupts on the given pin so interrupt() will be called when occurring
@@ -441,7 +440,6 @@ class Sensor {
     virtual void onSetup();
     virtual void onLoop(Child* child);
     virtual void onReceive(MyMessage* message);
-    virtual void onProcess(Request & request);
     virtual void onInterrupt();
     List<Child*> children;
     Child* getChild(int child_id);
@@ -450,7 +448,7 @@ class Sensor {
     void setPowerManager(const PowerManager& powerManager);
     NodeManager* _node;
   protected:
-    const __FlashStringHelper* _name;
+    const char* _name = "";
     int _pin = -1;
     int _samples = 1;
     int _samples_interval = 0;
@@ -481,7 +479,6 @@ class SensorBattery: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
       float _battery_min = 2.6;
@@ -504,12 +501,26 @@ class SensorSignal: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     int _signal_command = SR_RX_RSSI;
 };
 
+/*
+   SensorConfiguration: allow remote configuration of the board and any configured sensor
+*/
+class SensorConfiguration: public Sensor {
+  public:
+    SensorConfiguration(NodeManager& nodeManager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+};
+
 #if MODULE_ANALOG_INPUT == 1
 /*
    SensorAnalogInput: read the analog input of a configured pin
@@ -1386,8 +1397,6 @@ class NodeManager {
     void clearEeprom();
     // [9] wake up the board
     void wakeup();
-    // process a remote request
-    void process(Request & request);
     // return the value stored at the requested index from the EEPROM
     int loadFromMemory(int index);
     // [27] save the given index of the EEPROM the provided value
diff --git a/NodeManager.ino b/NodeManager.ino
index 1c2dc57..63210ea 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -25,6 +25,7 @@ NodeManager node;
 SensorSHT21 sht(node);
 //PowerManager power(5,6);
 SensorBattery battery(node);
+SensorConfiguration configuration(node);
 SensorSignal signal(node);
 
 // before
diff --git a/config.h b/config.h
index d7ad974..247de88 100755
--- a/config.h
+++ b/config.h
@@ -113,9 +113,6 @@
 // if enabled, enable debug messages on serial port
 #define DEBUG 1
 
-// if enabled, allow modifying the configuration remotely by interacting with the configuration child id
-#define REMOTE_CONFIGURATION 1
-
 // Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
 #define MODULE_ANALOG_INPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT

From 326a7807289b6327eabd48143c5ee558ac9ba4b4 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 16:05:43 +0100
Subject: [PATCH 24/51] Request value can be only int and float (save 200
 bytes)

---
 NodeManager.cpp | 43 +++++++++++++++----------------------------
 NodeManager.h   |  5 +----
 NodeManager.ino |  6 +++---
 3 files changed, 19 insertions(+), 35 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 5bd2a5a..9e2ed35 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -170,28 +170,19 @@ float Timer::getElapsed() {
 Request::Request(int recipient_child_id, const char* string) {
   _recipient_child_id = recipient_child_id;
   char* ptr;
-  // copy to working area
-  strcpy((char*)&_value, string);
-  // tokenize the string and split function from value
-  strtok_r(_value, ",", &ptr);
-  // get child id
-  _child_id = atoi(_value);
-  // get the function id
-  strtok_r(NULL, ",", &ptr);
-  _function = atoi(_value);
-  // move user data to working area
-  strcpy(_value,ptr);
+  // tokenize the string and get child id
+  _child_id = atoi(strtok_r(string, ",", &ptr));
+  // tokenize the string and get function id
+  _function = atoi(strtok_r(NULL, ",", &ptr));
+  // tokenize the string and get the value
+  _value = atof(strtok_r(NULL, ",", &ptr));
   #if DEBUG == 1
-    Serial.print(F("REQ F="));
-    Serial.print(getFunction());
-    Serial.print(F(" C="));
+    Serial.print(F("REQ C="));
     Serial.print(getChildId());
-    Serial.print(F(" I="));
-    Serial.print(getValueInt());
     Serial.print(F(" F="));
+    Serial.print(getFunction());
+    Serial.print(F(" V="));
     Serial.print(getValueFloat());
-    Serial.print(F(" S="));
-    Serial.println(getValueString());
   #endif
 }
 
@@ -212,21 +203,15 @@ int Request::getFunction() {
 
 // return the value as an int
 int Request::getValueInt() {
-  return atoi(_value);
+  return _value;
   
 }
 
 // return the value as a float
 float Request::getValueFloat() {
-  return atof(_value);
-}
-
-// return the value as a string
-char* Request::getValueString() {
   return _value;
 }
 
-
 /******************************************
     Sensors
 */
@@ -703,6 +688,8 @@ void SensorConfiguration::onLoop(Child* child) {
 
 // what to do as the main task when receiving a message
 void SensorConfiguration::onReceive(MyMessage* message) {
+  // expect a REQ, V_CUSTOM message
+  if (message->getCommand() != C_REQ && message->type != V_CUSTOM) return;
   // parse the request
   Request request = Request(message->sensor,message->getString());
   int function = request.getFunction();
@@ -719,7 +706,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         case 6: _node->reboot(); return;
       #endif
       case 7: _node->clearEeprom(); break;
-      case 8: _node->sendMessage(request.getChildId(),V_CUSTOM,VERSION); return;
+      case 8: _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,VERSION); return;
       case 9: _node->wakeup(); break;
       case 10: _node->setRetries(request.getValueInt()); break;
       case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
@@ -790,7 +777,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
       #endif
     }
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+  _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -994,7 +981,7 @@ void SensorThermistor::onProcess(Request & request) {
     case 101: setNominalResistor((long)request.getValueInt()); break;
     case 102: setNominalTemperature(request.getValueInt()); break;
     case 103: setBCoefficient(request.getValueInt()); break;
-    case 104: setSeriesResistor((long)request.getValueString()); break;
+    case 104: setSeriesResistor((long)request.getValueInt()); break;
     case 105: setOffset(request.getValueFloat()); break;
     default: return;
   }
diff --git a/NodeManager.h b/NodeManager.h
index e81034e..50a6bdc 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -310,14 +310,11 @@ class Request {
     int getValueInt();
     // return the value as a float
     float getValueFloat();
-    // return the value as a string
-    char* getValueString();
    private:
     int _function = -1;
     int _child_id = -1;
     int _recipient_child_id = -1;
-	  // Size of buffer to prevent overrun 
-    char _value[MAX_PAYLOAD+1];
+    float _value;
 };
 
 /***************************************
diff --git a/NodeManager.ino b/NodeManager.ino
index 63210ea..5537e90 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -22,18 +22,18 @@ Documentation available on: https://github.com/mysensors/NodeManager
 
 // create a NodeManager instance
 NodeManager node;
-SensorSHT21 sht(node);
+//SensorSHT21 sht(node);
 //PowerManager power(5,6);
 SensorBattery battery(node);
 SensorConfiguration configuration(node);
-SensorSignal signal(node);
+//SensorSignal signal(node);
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);
   node.setReportIntervalSeconds(20);
-  node.setSleepSeconds(20);
+  //node.setSleepSeconds(20);
   
   //node.setPowerManager(power);
   //battery.setReportIntervalSeconds(10);

From ef7e4fee8bcf16d5b7e1874479d9774b27fc21ef Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 16:27:33 +0100
Subject: [PATCH 25/51] Fixed logic error in Child class

---
 NodeManager.cpp | 23 ++++++++++-------------
 NodeManager.h   | 31 +++++++++++++++----------------
 NodeManager.ino |  1 +
 3 files changed, 26 insertions(+), 29 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 9e2ed35..ba3b944 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -178,11 +178,11 @@ Request::Request(int recipient_child_id, const char* string) {
   _value = atof(strtok_r(NULL, ",", &ptr));
   #if DEBUG == 1
     Serial.print(F("REQ C="));
-    Serial.print(getChildId());
+    Serial.print(_child_id);
     Serial.print(F(" F="));
-    Serial.print(getFunction());
+    Serial.print(_function);
     Serial.print(F(" V="));
-    Serial.print(getValueFloat());
+    Serial.println(_value);
   #endif
 }
 
@@ -203,7 +203,7 @@ int Request::getFunction() {
 
 // return the value as an int
 int Request::getValueInt() {
-  return _value;
+  return (int)_value;
   
 }
 
@@ -255,11 +255,10 @@ void ChildInt::setValueInt(int value) {
 
 // send the value back to the controller
 void ChildInt::sendValue() {
-  if (_value == -255) return;
+  if (_samples == 0) return;
   _sensor->_node->sendMessage(child_id,type,_value);
   _last_value = _value;
-  _value = -255;
-  _total = -255;
+  _total = 0;
   _samples = 0;
 }
 
@@ -281,11 +280,10 @@ void ChildFloat::setValueFloat(float value) {
 
 // send the value back to the controller
 void ChildFloat::sendValue() {
-  if (_value == -255) return;
+  if (_samples == 0) return;
   _sensor->_node->sendMessage(child_id,type,_value);
   _last_value = _value;
-  _value = -255;
-  _total = -255;
+  _total = 0;
   _samples = 0;
 }
 
@@ -307,11 +305,10 @@ void ChildDouble::setValueDouble(double value) {
 
 // send the value back to the controller
 void ChildDouble::sendValue() {
-  if (_value == -255) return;
+  if (_samples == 0) return;
   _sensor->_node->sendMessage(child_id,type,_value);
   _last_value = _value;
-  _value = -255;
-  _total = -255;
+  _total = 0;
   _samples = 0;
 }
 
diff --git a/NodeManager.h b/NodeManager.h
index 50a6bdc..10ea005 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -344,8 +344,8 @@ class ChildInt: public Child {
     void sendValue();
     bool isNewValue();
   private:
-    int _value = -255;
-    int _last_value = -255;
+    int _value;
+    int _last_value;
     int _total = 0;
 };
 
@@ -356,34 +356,33 @@ class ChildFloat: public Child {
     void sendValue();
     bool isNewValue();
   private:
-    float _value = -255;
-    float _last_value = -255;
+    float _value;
+    float _last_value;
     float _total = 0;
 };
 
-class ChildString: public Child {
+class ChildDouble: public Child {
   public:
-    ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description);
-    void setValueString(char* value);
+    ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueDouble(double value);
     void sendValue();
     bool isNewValue();
   private:
-    char* _value = "";
-    char* _last_value = "";
+    double _value;
+    double _last_value;
+    double _total = 0;
 };
 
-class ChildDouble: public Child {
+class ChildString: public Child {
   public:
-    ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
-    void setValueDouble(double value);
+    ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueString(char* value);
     void sendValue();
     bool isNewValue();
   private:
-    double _value = -255;
-    double _last_value = -255;
-    double _total = 0;
+    char* _value = "";
+    char* _last_value = "";
 };
-
 /***************************************
    Sensor: generic sensor class
 */
diff --git a/NodeManager.ino b/NodeManager.ino
index 5537e90..15115df 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -32,6 +32,7 @@ SensorConfiguration configuration(node);
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);
+  battery.setReportIntervalSeconds(10);
   node.setReportIntervalSeconds(20);
   //node.setSleepSeconds(20);
   

From 62845f2644edc7d9901d9df13dd28b0495f617f5 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 17:05:20 +0100
Subject: [PATCH 26/51] Migrated SensorAnalogInput, SensorLDR

---
 NodeManager.cpp | 82 ++++++++++++++++++++++++++-----------------------
 NodeManager.h   | 21 ++++++-------
 NodeManager.ino |  9 ++++--
 config.h        |  4 +--
 4 files changed, 62 insertions(+), 54 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index ba3b944..4fd6608 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -344,8 +344,8 @@ bool ChildString::isNewValue() {
 // constructor
 Sensor::Sensor() {  
 }
-Sensor::Sensor(NodeManager& nodeManager, int pin = -1) {
-  _node = &nodeManager;
+Sensor::Sensor(const NodeManager& node_manager, int pin = -1) {
+  _node = &node_manager;
   _pin = pin;
   _report_timer = new Timer(_node);
   _node->registerSensor(this);
@@ -550,7 +550,7 @@ void Sensor::onInterrupt(){}
    SensorBattery
 */
 // contructor
-SensorBattery::SensorBattery(NodeManager& nodeManager): Sensor(nodeManager) {
+SensorBattery::SensorBattery(const NodeManager& node_manager): Sensor(node_manager) {
   _name = "BAT";
   // report battery level every 60 minutes by default
   setReportIntervalMinutes(60);
@@ -619,7 +619,7 @@ void SensorBattery::onInterrupt() {
    SensorSignal
 */
 // contructor
-SensorSignal::SensorSignal(NodeManager& nodeManager): Sensor(nodeManager) {
+SensorSignal::SensorSignal(const NodeManager& node_manager): Sensor(node_manager) {
   _name = "SIG";
   // report signal level every 60 minutes by default
   setReportIntervalMinutes(60);
@@ -665,7 +665,7 @@ void SensorSignal::onInterrupt() {
    SensorConfiguration
 */
 // contructor
-SensorConfiguration::SensorConfiguration(NodeManager& nodeManager): Sensor(nodeManager) {
+SensorConfiguration::SensorConfiguration(const NodeManager& node_manager): Sensor(node_manager) {
   _name = "CONF";
 }
 
@@ -772,6 +772,19 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_ANALOG_INPUT == 1
+      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0) {
+        SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setReference(request.getValueInt()); break;
+          case 102: custom_sensor->setReverse(request.getValueInt()); break;
+          case 103: custom_sensor->setOutputPercentage(request.getValueInt()); break;
+          case 104: custom_sensor->setRangeMin(request.getValueInt()); break;
+          case 105: custom_sensor->setRangeMax(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -788,7 +801,8 @@ void SensorConfiguration::onInterrupt() {
 */
 
 // contructor
-SensorAnalogInput::SensorAnalogInput(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
+SensorAnalogInput::SensorAnalogInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "A-IN";
 }
 
 // setter/getter
@@ -810,12 +824,13 @@ void SensorAnalogInput::setRangeMax(int value) {
 
 // what to do during before
 void SensorAnalogInput::onBefore() {
-  // prepare the pin for input
-  pinMode(_pin, INPUT);
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
 }
 
 // what to do during setup
 void SensorAnalogInput::onSetup() {
+  // prepare the pin for input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -826,34 +841,23 @@ void SensorAnalogInput::onLoop(Child* child) {
   int percentage = 0;
   if (_output_percentage) percentage = _getPercentage(adc);
   #if DEBUG == 1
-    Serial.print(F("A-IN I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" V="));
     Serial.print(adc);
     Serial.print(F(" %="));
     Serial.println(percentage);
   #endif
   // store the result
-  _value_int = _output_percentage ? percentage : adc;
+  ((ChildInt*)child)->setValueInt(_output_percentage ? percentage : adc);
 }
 
 // what to do during loop
-void SensorAnalogInput::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorAnalogInput::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setReference(request.getValueInt()); break;
-    case 102: setReverse(request.getValueInt()); break;
-    case 103: setOutputPercentage(request.getValueInt()); break;
-    case 104: setRangeMin(request.getValueInt()); break;
-    case 105: setRangeMax(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorAnalogInput::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
@@ -893,13 +897,17 @@ int SensorAnalogInput::_getPercentage(int adc) {
 */
 
 // contructor
-SensorLDR::SensorLDR(NodeManager* node_manager, int child_id, int pin): SensorAnalogInput(node_manager, child_id, pin) {
-  // set presentation and type and reverse (0: no light, 100: max light)
-  setPresentation(S_LIGHT_LEVEL);
-  setType(V_LIGHT_LEVEL);
-  setReverse(true);
+SensorLDR::SensorLDR(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "LDR";
 }
 
+// what to do during before
+void SensorLDR::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
+  setReverse(true);
+}
+#endif
+#if MODULE_ANALOG_INPUT2 == 1
 /*
    SensorThermistor
 */
@@ -1513,7 +1521,7 @@ void SensorDHT::onInterrupt() {
 */
 #if MODULE_SHT21 == 1
 // contructor
-SensorSHT21::SensorSHT21(NodeManager& nodeManager): Sensor(nodeManager) {
+SensorSHT21::SensorSHT21(const NodeManager& node_manager): Sensor(node_manager) {
   _name = "SHT21";
 }
 
@@ -1522,12 +1530,12 @@ void SensorSHT21::onBefore() {
   // register the child
   new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
   new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-  // initialize the library
-  Wire.begin();
 }
 
 // what to do during setup
 void SensorSHT21::onSetup() {
+  // initialize the library
+  Wire.begin();
 }
 
 // what to do during loop
@@ -1572,10 +1580,6 @@ void SensorSHT21::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving a remote message
-void SensorSHT21::onProcess(Request & request) {
-}
-
 // what to do when receiving an interrupt
 void SensorSHT21::onInterrupt() {
 }
diff --git a/NodeManager.h b/NodeManager.h
index 10ea005..d1f1ee9 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -390,7 +390,7 @@ class ChildString: public Child {
 class Sensor {
   public:
     Sensor();
-    Sensor(NodeManager& nodeManager, int pin);
+    Sensor(const NodeManager& node_manager, int pin);
     // return the name of the sensor
     char* getName();
     // [1] where the sensor is attached to (default: not set)
@@ -459,7 +459,7 @@ class Sensor {
 */
 class SensorBattery: public Sensor {
   public:
-    SensorBattery(NodeManager& nodeManager);
+    SensorBattery(const NodeManager& nodeManager);
       // [11] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
       void setMinVoltage(float value);
       // [12] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
@@ -489,7 +489,7 @@ class SensorBattery: public Sensor {
 */
 class SensorSignal: public Sensor {
   public:
-    SensorSignal(NodeManager& nodeManager);
+    SensorSignal(const NodeManager& nodeManager);
     // [101] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
     void setSignalCommand(int value);
     // define what to do at each stage of the sketch
@@ -507,7 +507,7 @@ class SensorSignal: public Sensor {
 */
 class SensorConfiguration: public Sensor {
   public:
-    SensorConfiguration(NodeManager& nodeManager);
+    SensorConfiguration(const NodeManager& nodeManager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -523,7 +523,7 @@ class SensorConfiguration: public Sensor {
 */
 class SensorAnalogInput: public Sensor {
   public:
-    SensorAnalogInput(NodeManager* node_manager, int child_id, int pin);
+    SensorAnalogInput(const NodeManager& node_manager, int pin);
     // [101] the analog reference to use (default: not set, can be either INTERNAL or DEFAULT)
     void setReference(int value);
     // [102] reverse the value or the percentage (e.g. 70% -> 30%) (default: false)
@@ -539,7 +539,6 @@ class SensorAnalogInput: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     int _reference = -1;
@@ -556,7 +555,9 @@ class SensorAnalogInput: public Sensor {
 */
 class SensorLDR: public SensorAnalogInput {
   public:
-    SensorLDR(NodeManager* node_manager, int child_id, int pin);
+    SensorLDR(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
 };
 
 /*
@@ -564,7 +565,7 @@ class SensorLDR: public SensorAnalogInput {
 */
 class SensorThermistor: public Sensor {
   public:
-    SensorThermistor(NodeManager* node_manager, int child_id, int pin);
+    SensorThermistor(const NodeManager& node_manager, int pin);
     // [101] resistance at 25 degrees C (default: 10000)
     void setNominalResistor(long value);
     // [102] temperature for nominal resistance (default: 25)
@@ -580,7 +581,6 @@ class SensorThermistor: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     long _nominal_resistor = 10000;
@@ -769,13 +769,12 @@ class SensorDHT: public Sensor {
 #if MODULE_SHT21 == 1
 class SensorSHT21: public Sensor {
   public:
-    SensorSHT21(NodeManager& nodeManager);
+    SensorSHT21(const NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
 };
diff --git a/NodeManager.ino b/NodeManager.ino
index 15115df..87ab4ae 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -22,9 +22,14 @@ Documentation available on: https://github.com/mysensors/NodeManager
 
 // create a NodeManager instance
 NodeManager node;
+//SensorAnalogInput analog(node,A0);
+//SensorLDR ldr(node,A0);
+
+
+
 //SensorSHT21 sht(node);
 //PowerManager power(5,6);
-SensorBattery battery(node);
+//SensorBattery battery(node);
 SensorConfiguration configuration(node);
 //SensorSignal signal(node);
 
@@ -32,7 +37,7 @@ SensorConfiguration configuration(node);
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);
-  battery.setReportIntervalSeconds(10);
+//  battery.setReportIntervalSeconds(10);
   node.setReportIntervalSeconds(20);
   //node.setSleepSeconds(20);
   
diff --git a/config.h b/config.h
index 247de88..f72d2d8 100755
--- a/config.h
+++ b/config.h
@@ -113,7 +113,7 @@
 // if enabled, enable debug messages on serial port
 #define DEBUG 1
 
-// Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
+// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
 #define MODULE_ANALOG_INPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT
 #define MODULE_DIGITAL_INPUT 0
@@ -122,7 +122,7 @@
 // Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
 #define MODULE_DHT 0
 // Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
-#define MODULE_SHT21 1
+#define MODULE_SHT21 0
 // Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION
 #define MODULE_SWITCH 0
 // Enable this module to use one of the following sensors: SENSOR_DS18B20

From 2e47e698b6531677479ddf0b0af16428dd6042c6 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 17:21:01 +0100
Subject: [PATCH 27/51] Migrated SensorThermistor SensorML8511

---
 NodeManager.cpp | 88 +++++++++++++++++++++++++------------------------
 NodeManager.h   |  9 +++--
 NodeManager.ino |  2 ++
 config.h        |  6 +++-
 4 files changed, 59 insertions(+), 46 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 4fd6608..cc79b58 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -785,6 +785,19 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_THERMISTOR == 1
+      if (strcmp(sensor->getName(),"THER") == 0) {
+        SensorThermistor* custom_sensor = (SensorThermistor*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setNominalResistor((long)request.getValueInt()); break;
+          case 102: custom_sensor->setNominalTemperature(request.getValueInt()); break;
+          case 103: custom_sensor->setBCoefficient(request.getValueInt()); break;
+          case 104: custom_sensor->setSeriesResistor((long)request.getValueInt()); break;
+          case 105: custom_sensor->setOffset(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -907,17 +920,15 @@ void SensorLDR::onBefore() {
   setReverse(true);
 }
 #endif
-#if MODULE_ANALOG_INPUT2 == 1
+
+#if MODULE_THERMISTOR == 1
 /*
    SensorThermistor
 */
 
 // contructor
-SensorThermistor::SensorThermistor(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
-  // set presentation, type and value type
-  setPresentation(S_TEMP);
-  setType(V_TEMP);
-  setValueType(TYPE_FLOAT);
+SensorThermistor::SensorThermistor(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "THER";
 }
 
 // setter/getter
@@ -939,12 +950,13 @@ void SensorThermistor::setOffset(float value) {
 
 // what to do during before
 void SensorThermistor::onBefore() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
 }
 
 // what to do during setup
 void SensorThermistor::onSetup() {
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -963,60 +975,49 @@ void SensorThermistor::onLoop(Child* child) {
   temperature -= 273.15;                         // convert to C
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
-    Serial.print(F("THER I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" V="));
     Serial.print(adc);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  _value_float = temperature;
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
 }
 
 // what to do as the main task when receiving a message
-void SensorThermistor::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorThermistor::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setNominalResistor((long)request.getValueInt()); break;
-    case 102: setNominalTemperature(request.getValueInt()); break;
-    case 103: setBCoefficient(request.getValueInt()); break;
-    case 104: setSeriesResistor((long)request.getValueInt()); break;
-    case 105: setOffset(request.getValueFloat()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorThermistor::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
 void SensorThermistor::onInterrupt() {
 }
+#endif
 
+#if MODULE_ML8511 == 1
 /*
    SensorML8511
 */
 
 // contructor
-SensorML8511::SensorML8511(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
-  // set presentation, type and value type
-  setPresentation(S_UV);
-  setType(V_UV);
-  setValueType(TYPE_FLOAT);
+SensorML8511::SensorML8511(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "UV";
 }
 
 // what to do during before
 void SensorML8511::onBefore() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
+  new ChildFloat(this,_node->getAvailableChildId(),S_UV,V_UV);
 }
 
 // what to do during setup
 void SensorML8511::onSetup() {
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -1029,24 +1030,23 @@ void SensorML8511::onLoop(Child* child) {
   //Convert the voltage to a UV intensity level
   float uvIntensity = _mapfloat(outputVoltage, 0.99, 2.8, 0.0, 15.0); 
   #if DEBUG == 1
-    Serial.print(F("UV I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" V="));
     Serial.print(outputVoltage);
     Serial.print(F(" I="));
     Serial.println(uvIntensity);
   #endif
   // store the value
-  _value_float = uvIntensity;
+  ((ChildFloat*)child)->setValueFloat(uvIntensity);
 }
 
 // what to do as the main task when receiving a message
-void SensorML8511::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorML8511::onProcess(Request & request) {
+void SensorML8511::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
@@ -1057,7 +1057,9 @@ void SensorML8511::onInterrupt() {
 float SensorML8511::_mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
   return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 }
+#endif
 
+#if MODULE_ANALOG_INPUT2 == 1
 /*
    SensorACS712
 */
diff --git a/NodeManager.h b/NodeManager.h
index d1f1ee9..6fe180b 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -559,7 +559,9 @@ class SensorLDR: public SensorAnalogInput {
     // define what to do at each stage of the sketch
     void onBefore();
 };
+#endif
 
+#if MODULE_THERMISTOR == 1
 /*
    SensorThermistor: read the temperature from a thermistor
 */
@@ -589,24 +591,27 @@ class SensorThermistor: public Sensor {
     long _series_resistor = 10000;
     float _offset = 0;
 };
+#endif
 
+#if MODULE_ML8511 == 1
 /*
     SensorML8511
 */
 
 class SensorML8511: public Sensor {
   public:
-    SensorML8511(NodeManager* node_manager, int child_id, int pin);
+    SensorML8511(const NodeManager& node_Manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     float _mapfloat(float x, float in_min, float in_max, float out_min, float out_max);
 };
+#endif
+#if MODULE_ANALOG_INPUT2 == 1
 
 /*
     SensorACS712
diff --git a/NodeManager.ino b/NodeManager.ino
index 87ab4ae..b5b1053 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -24,6 +24,8 @@ Documentation available on: https://github.com/mysensors/NodeManager
 NodeManager node;
 //SensorAnalogInput analog(node,A0);
 //SensorLDR ldr(node,A0);
+//SensorThermistor thermistor(node,A0);
+SensorML8511 ml8511(node,A0);
 
 
 
diff --git a/config.h b/config.h
index f72d2d8..347bf74 100755
--- a/config.h
+++ b/config.h
@@ -113,8 +113,12 @@
 // if enabled, enable debug messages on serial port
 #define DEBUG 1
 
-// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
+// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
 #define MODULE_ANALOG_INPUT 0
+// Enable this module to use one of the following sensors: SensorThermistor
+#define MODULE_THERMISTOR 0
+// Enable this module to use one of the following sensors: SensorML8511
+#define MODULE_ML8511 1
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT
 #define MODULE_DIGITAL_INPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_OUTPUT, SENSOR_RELAY, SENSOR_LATCHING_RELAY

From f36d914ff9d98022ab5bed7ddb8d827c0e63c3df Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 17:34:39 +0100
Subject: [PATCH 28/51] Migrated SensorRain  SensorSoilMoisture SensorACS712

---
 NodeManager.cpp | 133 +++++++++++++++++++++++++++---------------------
 NodeManager.h   |  45 ++++++++--------
 NodeManager.ino |   7 ++-
 config.h        |   8 +--
 4 files changed, 111 insertions(+), 82 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index cc79b58..eba7e6f 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -773,7 +773,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
       }
       #endif
       #if MODULE_ANALOG_INPUT == 1
-      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0) {
+      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0 || strcmp(sensor->getName(),"RAIN") == 0 || strcmp(sensor->getName(),"SOIL") == 0) {
         SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
         switch(function) {
           case 101: custom_sensor->setReference(request.getValueInt()); break;
@@ -798,6 +798,16 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_ACS712 == 1
+      if (strcmp(sensor->getName(),"ACS") == 0) {
+        SensorACS712* custom_sensor = (SensorACS712*)sensor;
+        switch(function) {
+          case 100: custom_sensor->setmVPerAmp(request.getValueInt()); break;
+          case 102: custom_sensor->setOffset(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -917,7 +927,56 @@ SensorLDR::SensorLDR(const NodeManager& node_manager, int pin): SensorAnalogInpu
 // what to do during before
 void SensorLDR::onBefore() {
   new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
+}
+
+// what to do during setup
+void SensorLDR::onSetup() {
+  setReverse(true);
+}
+
+/*
+   SensorRain
+*/
+
+// contructor
+SensorRain::SensorRain(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "RAIN";
+}
+
+// what to do during before
+void SensorRain::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_RAIN,V_RAINRATE);
+}
+
+// what to do during setup
+void SensorRain::onSetup() {
+  setReference(DEFAULT);
+  setOutputPercentage(true);
   setReverse(true);
+  setRangeMin(100);
+}
+
+/*
+   SensorSoilMoisture
+*/
+
+// contructor
+SensorSoilMoisture::SensorSoilMoisture(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "SOIL";
+}
+
+// what to do during before
+void SensorSoilMoisture::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_MOISTURE,V_LEVEL);
+}
+
+// what to do during setup
+void SensorSoilMoisture::onSetup() {
+  setReverse(true);
+  setReference(DEFAULT);
+  setOutputPercentage(true);
+  setReverse(true);
+  setRangeMin(100);
 }
 #endif
 
@@ -1059,17 +1118,14 @@ float SensorML8511::_mapfloat(float x, float in_min, float in_max, float out_min
 }
 #endif
 
-#if MODULE_ANALOG_INPUT2 == 1
+#if MODULE_ACS712 == 1
 /*
    SensorACS712
 */
 
 // contructor
-SensorACS712::SensorACS712(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
-  // set presentation, type and value type
-  setPresentation(S_MULTIMETER);
-  setType(V_CURRENT);
-  setValueType(TYPE_FLOAT);
+SensorACS712::SensorACS712(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "ACS";
 }
 
 // setter/getter
@@ -1082,12 +1138,13 @@ void SensorACS712::setOffset(int value) {
 
 // what to do during before
 void SensorACS712::onBefore() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
+  new ChildFloat(this,_node->getAvailableChildId(),S_MULTIMETER,V_CURRENT);
 }
 
 // what to do during setup
 void SensorACS712::onSetup() {
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -1096,65 +1153,27 @@ void SensorACS712::onLoop(Child* child) {
   // convert the analog read in mV
   double voltage = (value / 1024.0) * 5000; 
   // convert voltage in amps
-  _value_float = ((voltage - _ACS_offset) / _mv_per_amp);
+  float value_float = ((voltage - _ACS_offset) / _mv_per_amp);
   #if DEBUG == 1
-    Serial.print(F("ACS I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" A="));
-    Serial.println(_value_float);
+    Serial.println(value_float);
   #endif
+  ((ChildFloat*)child)->setValueFloat(value_float);
 }
 
 // what to do as the main task when receiving a message
-void SensorACS712::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorACS712::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 100: setmVPerAmp(request.getValueInt()); break;
-    case 102: setOffset(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorACS712::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
 void SensorACS712::onInterrupt() {
 }
-
-/*
-   SensorRain
-*/
-
-// contructor
-SensorRain::SensorRain(NodeManager* node_manager, int child_id, int pin): SensorAnalogInput(node_manager,child_id, pin) {
-  // set presentation and type and reverse
-  setPresentation(S_RAIN);
-  setType(V_RAINRATE);
-  setReference(DEFAULT);
-  setOutputPercentage(true);
-  setReverse(true);
-  setRangeMin(100);
-}
-
-/*
-   SensorSoilMoisture
-*/
-
-// contructor
-SensorSoilMoisture::SensorSoilMoisture(NodeManager* node_manager, int child_id, int pin): SensorAnalogInput(node_manager, child_id, pin) {
-  // set presentation and type and reverse
-  setPresentation(S_MOISTURE);
-  setType(V_LEVEL);
-  setReference(DEFAULT);
-  setOutputPercentage(true);
-  setReverse(true);
-  setRangeMin(100);
-}
-
 #endif
 
 #if MODULE_DIGITAL_INPUT == 1
diff --git a/NodeManager.h b/NodeManager.h
index 6fe180b..e7bdb74 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -558,6 +558,29 @@ class SensorLDR: public SensorAnalogInput {
     SensorLDR(const NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
+    void onSetup();
+};
+
+/*
+   SensorRain
+*/
+class SensorRain: public SensorAnalogInput {
+  public:
+    SensorRain(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+};
+
+/*
+   SensorSoilMoisture
+*/
+class SensorSoilMoisture: public SensorAnalogInput {
+  public:
+    SensorSoilMoisture(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
 };
 #endif
 
@@ -611,15 +634,15 @@ class SensorML8511: public Sensor {
     float _mapfloat(float x, float in_min, float in_max, float out_min, float out_max);
 };
 #endif
-#if MODULE_ANALOG_INPUT2 == 1
 
+#if MODULE_ACS712 == 1
 /*
     SensorACS712
 */
 
 class SensorACS712: public Sensor {
   public:
-    SensorACS712(NodeManager* node_manager, int child_id, int pin);
+    SensorACS712(const NodeManager& node_manager, int pin);
     // [101] set how many mV are equivalent to 1 Amp. The value depends on the module (100 for 20A Module, 66 for 30A Module) (default: 185);
     void setmVPerAmp(int value);
     // [102] set ACS offset (default: 2500);
@@ -629,31 +652,13 @@ class SensorACS712: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     int _ACS_offset = 2500;
     int _mv_per_amp = 185;
 };
-
-/*
-   SensorRain
-*/
-class SensorRain: public SensorAnalogInput {
-  public:
-    SensorRain(NodeManager* node_manager, int child_id, int pin);
-};
-
-/*
-   SensorSoilMoisture
-*/
-class SensorSoilMoisture: public SensorAnalogInput {
-  public:
-    SensorSoilMoisture(NodeManager* node_manager, int child_id, int pin);
-};
 #endif
 
-
 #if MODULE_DIGITAL_INPUT == 1
 /*
    SensorDigitalInput: read the digital input of the configured pin
diff --git a/NodeManager.ino b/NodeManager.ino
index b5b1053..552d69d 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -23,9 +23,12 @@ Documentation available on: https://github.com/mysensors/NodeManager
 // create a NodeManager instance
 NodeManager node;
 //SensorAnalogInput analog(node,A0);
-//SensorLDR ldr(node,A0);
+SensorLDR ldr(node,A0);
+//SensorRain rain(node,A0);
+//SensorSoilMoisture soil(node,A0);
 //SensorThermistor thermistor(node,A0);
-SensorML8511 ml8511(node,A0);
+//SensorML8511 ml8511(node,A0);
+//SensorACS712 acs712(node,A0);
 
 
 
diff --git a/config.h b/config.h
index 347bf74..844610c 100755
--- a/config.h
+++ b/config.h
@@ -113,12 +113,14 @@
 // if enabled, enable debug messages on serial port
 #define DEBUG 1
 
-// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
-#define MODULE_ANALOG_INPUT 0
+// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SensorRain, SensorSoilMoisture
+#define MODULE_ANALOG_INPUT 1
 // Enable this module to use one of the following sensors: SensorThermistor
 #define MODULE_THERMISTOR 0
 // Enable this module to use one of the following sensors: SensorML8511
-#define MODULE_ML8511 1
+#define MODULE_ML8511 0
+// Enable this module to use one of the following sensors: SensorACS712
+#define MODULE_ACS712 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT
 #define MODULE_DIGITAL_INPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_OUTPUT, SENSOR_RELAY, SENSOR_LATCHING_RELAY

From 1b49538b7d20e9be7e70decb5f7f4c86e3fd82f0 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 17:38:58 +0100
Subject: [PATCH 29/51] Migrated SensorDigitalInput

---
 NodeManager.cpp | 26 ++++++++++++++------------
 NodeManager.h   |  3 +--
 NodeManager.ino |  3 ++-
 config.h        |  4 ++--
 4 files changed, 19 insertions(+), 17 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index eba7e6f..c1bb37d 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -1182,17 +1182,20 @@ void SensorACS712::onInterrupt() {
 */
 
 // contructor
-SensorDigitalInput::SensorDigitalInput(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id, pin) {
+SensorDigitalInput::SensorDigitalInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "D-IN";
 }
 
 // what to do during before
 void SensorDigitalInput::onBefore() {
-  // set the pin for input
-  pinMode(_pin, INPUT);
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
 }
 
 // what to do during setup
 void SensorDigitalInput::onSetup() {
+  // set the pin for input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
@@ -1200,24 +1203,23 @@ void SensorDigitalInput::onLoop(Child* child) {
   // read the value
   int value = digitalRead(_pin);
   #if DEBUG == 1
-    Serial.print(F("D-IN I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" P="));
     Serial.print(_pin);
     Serial.print(F(" V="));
     Serial.println(value);
   #endif
   // store the value
-  _value_int = value;
+  ((ChildInt*)child)->setValueInt(value);
 }
 
 // what to do as the main task when receiving a message
-void SensorDigitalInput::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorDigitalInput::onProcess(Request & request) {
+void SensorDigitalInput::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
diff --git a/NodeManager.h b/NodeManager.h
index e7bdb74..f1b5d4a 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -665,13 +665,12 @@ class SensorACS712: public Sensor {
 */
 class SensorDigitalInput: public Sensor {
   public:
-    SensorDigitalInput(NodeManager* node_manager, int child_id, int pin);
+    SensorDigitalInput(const NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
 };
 #endif
diff --git a/NodeManager.ino b/NodeManager.ino
index 552d69d..986e633 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -23,12 +23,13 @@ Documentation available on: https://github.com/mysensors/NodeManager
 // create a NodeManager instance
 NodeManager node;
 //SensorAnalogInput analog(node,A0);
-SensorLDR ldr(node,A0);
+//SensorLDR ldr(node,A0);
 //SensorRain rain(node,A0);
 //SensorSoilMoisture soil(node,A0);
 //SensorThermistor thermistor(node,A0);
 //SensorML8511 ml8511(node,A0);
 //SensorACS712 acs712(node,A0);
+SensorDigitalInput digital(node,6);
 
 
 
diff --git a/config.h b/config.h
index 844610c..4767499 100755
--- a/config.h
+++ b/config.h
@@ -114,14 +114,14 @@
 #define DEBUG 1
 
 // Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SensorRain, SensorSoilMoisture
-#define MODULE_ANALOG_INPUT 1
+#define MODULE_ANALOG_INPUT 0
 // Enable this module to use one of the following sensors: SensorThermistor
 #define MODULE_THERMISTOR 0
 // Enable this module to use one of the following sensors: SensorML8511
 #define MODULE_ML8511 0
 // Enable this module to use one of the following sensors: SensorACS712
 #define MODULE_ACS712 0
-// Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT
+// Enable this module to use one of the following sensors: SensorDigitalInput
 #define MODULE_DIGITAL_INPUT 0
 // Enable this module to use one of the following sensors: SENSOR_DIGITAL_OUTPUT, SENSOR_RELAY, SENSOR_LATCHING_RELAY
 #define MODULE_DIGITAL_OUTPUT 0

From 2f303dd923fca1ef47037708be2b62bc25f04c2d Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 18:10:54 +0100
Subject: [PATCH 30/51] Migrated SensorDigitalOutput SensorRelay
 SensorLatchingRelay

---
 NodeManager.cpp | 128 ++++++++++++++++++++++++------------------------
 NodeManager.h   |  20 ++++----
 NodeManager.ino |   5 +-
 config.h        |   4 +-
 4 files changed, 80 insertions(+), 77 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index c1bb37d..f12c3a8 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -808,6 +808,28 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_DIGITAL_OUTPUT == 1
+      if (strcmp(sensor->getName(),"DOUT") == 0 || strcmp(sensor->getName(),"REL") == 0 || strcmp(sensor->getName(),"LATC") == 0) {
+        SensorDigitalOutput* custom_sensor = (SensorDigitalOutput*)sensor;
+        switch(function) {
+            case 103: custom_sensor->setOnValue(request.getValueInt()); break;
+            case 104: custom_sensor->setLegacyMode(request.getValueInt()); break;
+            case 105: custom_sensor->setSafeguard(request.getValueInt()); break;
+            case 106: custom_sensor->setInputIsElapsed(request.getValueInt()); break;
+            case 107: custom_sensor->setWaitAfterSet(request.getValueInt()); break;
+          default: return;
+        }
+        if (function > 200 && strcmp(sensor->getName(),"LATC") == 0) {
+          SensorLatchingRelay* custom_sensor_2 = (SensorLatchingRelay*)sensor;
+          switch(function) {
+            case 201: custom_sensor_2->setPulseWidth(request.getValueInt()); break;
+            case 202: custom_sensor_2->setPinOff(request.getValueInt()); break;
+            case 203: custom_sensor_2->setPinOn(request.getValueInt()); break;
+          default: return;
+        }
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1233,18 +1255,19 @@ void SensorDigitalInput::onInterrupt() {
    SensorDigitalOutput
 */
 
-SensorDigitalOutput::SensorDigitalOutput(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id, pin) {
-  _safeguard_timer = new Timer(node_manager);
+SensorDigitalOutput::SensorDigitalOutput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DOUT";
 }
 
 // what to do during before
 void SensorDigitalOutput::onBefore() {
-  _setupPin(_pin);
-
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
 }
 
 // what to do during setup
 void SensorDigitalOutput::onSetup() {
+  _setupPin(children.get(1), _pin);
+  _safeguard_timer = new Timer(_node);
 }
 
 // setter/getter
@@ -1270,50 +1293,37 @@ void SensorDigitalOutput::setWaitAfterSet(int value) {
 // main task
 void SensorDigitalOutput::onLoop(Child* child) {
   // set the value to -1 so to avoid reporting to the gateway during loop
-  _value_int = -1;
-  _last_value_int = -1;
+  ((ChildInt*)child)->setValueInt(-1);
   // if a safeguard is set, check if it is time for it
   if (_safeguard_timer->isRunning()) {
     // update the timer
     _safeguard_timer->update();
     // if the time is over, turn the output off
-    if (_safeguard_timer->isOver()) setStatus(OFF);
+    if (_safeguard_timer->isOver()) setStatus(child->child_id,OFF);
   }
 }
 
 // what to do as the main task when receiving a message
-void SensorDigitalOutput::onReceive(const MyMessage & message) {
+void SensorDigitalOutput::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
   // by default handle a SET message but when legacy mode is set when a REQ message is expected instead
-  if ( (message.getCommand() == C_SET && ! _legacy_mode) || (message.getCommand() == C_REQ && _legacy_mode)) {
+  if ( (message->getCommand() == C_SET && ! _legacy_mode) || (message->getCommand() == C_REQ && _legacy_mode)) {
     // switch the output
-    setStatus(message.getInt());
+    setStatus(child, message->getInt());
   }
-  if (message.getCommand() == C_REQ && ! _legacy_mode) {
-    // return the current status
-    _value_int = _status;
+  if (message->getCommand() == C_REQ && ! _legacy_mode) {
+    // just return the current status
+    ((ChildInt*)child)->setValueInt(_status);
   }
 }
 
-// what to do when receiving a remote message
-void SensorDigitalOutput::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 103: setOnValue(request.getValueInt()); break;
-    case 104: setLegacyMode(request.getValueInt()); break;
-    case 105: setSafeguard(request.getValueInt()); break;
-    case 106: setInputIsElapsed(request.getValueInt()); break;
-    case 107: setWaitAfterSet(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
-}
-
 // what to do when receiving an interrupt
 void SensorDigitalOutput::onInterrupt() {
 }
 
 // write the value to the output
-void SensorDigitalOutput::setStatus(int value) {
+void SensorDigitalOutput::setStatus(Child* child, int value) {
   // pre-process the input value
   if (_input_is_elapsed) {
     // the input provided is an elapsed time
@@ -1331,33 +1341,34 @@ void SensorDigitalOutput::setStatus(int value) {
     // if turning the output on and a safeguard timer is configured, start it
     if (value == ON && _safeguard_timer->isConfigured() && ! _safeguard_timer->isRunning()) _safeguard_timer->start();
   }
-  _setStatus(value);
+  _setStatus(child, value);
   // wait if needed for relay drawing a lot of current
   if (_wait_after_set > 0) _node->sleepOrWait(_wait_after_set);
   // store the new status so it will be sent to the controller
   _status = value;
-  _value_int = value;
+  ((ChildInt*)child)->setValueInt(value);
 }
 
 // setup the provided pin for output
-void SensorDigitalOutput::_setupPin(int pin) {
+void SensorDigitalOutput::_setupPin(Child* child, int pin) {
   // set the pin as output and initialize it accordingly
   pinMode(pin, OUTPUT);
   // setup the pin in a off status
   _status = ! _on_value;
   digitalWrite(pin, _status);
   // the initial value is now the current value
-  _value_int = _status;
+  ((ChildInt*)child)->setValueInt(_status);
 }
 
 // switch to the requested status
-void SensorDigitalOutput::_setStatus(int value) {
+void SensorDigitalOutput::_setStatus(Child* child, int value) {
   int value_to_write = _getValueToWrite(value);
   // set the value to the pin
   digitalWrite(_pin, value_to_write);
   #if DEBUG == 1
-    Serial.print(F("DOUT I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" P="));
     Serial.print(_pin);
     Serial.print(F(" V="));
@@ -1376,16 +1387,18 @@ int SensorDigitalOutput::_getValueToWrite(int value) {
   return value_to_write;
 }
 
-
 /*
    SensorRelay
 */
 
 // contructor
-SensorRelay::SensorRelay(NodeManager* node_manager, int child_id, int pin): SensorDigitalOutput(node_manager, child_id, pin) {
-  // set presentation and type
-  setPresentation(S_BINARY);
-  setType(V_STATUS);
+SensorRelay::SensorRelay(const NodeManager& node_manager, int pin): SensorDigitalOutput(node_manager, pin) {
+  _name = "REL";
+}
+
+// what to do during before
+void SensorRelay::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
 }
 
 /*
@@ -1393,11 +1406,10 @@ SensorRelay::SensorRelay(NodeManager* node_manager, int child_id, int pin): Sens
 */
 
 // contructor
-SensorLatchingRelay::SensorLatchingRelay(NodeManager* node_manager, int child_id, int pin): SensorRelay(node_manager, child_id, pin) {
-  // set the "off" pin to the provided pin
-  setPinOff(pin);
-  // set the "on" pin to the provided pin + 1
-  setPinOn(pin + 1);
+SensorLatchingRelay::SensorLatchingRelay(const NodeManager& node_manager, int pin): SensorRelay(node_manager, pin) {
+  // set the "off" pin to the provided pin and the "on" pin to the provided pin + 1
+  _pin_on = pin;
+  _pin_off = pin + 1;
 }
 
 // setter/getter
@@ -1413,29 +1425,17 @@ void SensorLatchingRelay::setPinOff(int value) {
 
 // what to do during before
 void SensorLatchingRelay::onBefore() {
-  _setupPin(_pin_on);
-  _setupPin(_pin_off);
+  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
 }
 
-// what to do when receiving a remote message
-void SensorLatchingRelay::onProcess(Request & request) {
-  int function = request.getFunction();
-  if (function < 200) {
-    // if this is for SensorDigitalOutput call its onProcess()
-    SensorDigitalOutput::onProcess(request);
-    return;
-  }
-  switch(function) {
-    case 201: setPulseWidth(request.getValueInt()); break;
-    case 202: setPinOff(request.getValueInt()); break;
-    case 203: setPinOn(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+// what to do during setup
+void SensorLatchingRelay::onSetup() {
+  _setupPin(children.get(1),_pin_on);
+  _setupPin(children.get(1),_pin_off);
 }
 
 // switch to the requested status
-void SensorLatchingRelay::_setStatus(int value) {
+void SensorLatchingRelay::_setStatus(Child* child, int value) {
   // select the right pin to send the pulse to
   int pin = value == OFF ? _pin_off : _pin_on;
   // set the value
@@ -1445,7 +1445,7 @@ void SensorLatchingRelay::_setStatus(int value) {
   digitalWrite(pin, ! _on_value);
   #if DEBUG == 1
     Serial.print(F("LAT I="));
-    Serial.print(_child_id);
+    Serial.print(child->child_id);
     Serial.print(F(" P="));
     Serial.print(pin);
     Serial.print(F(" S="));
diff --git a/NodeManager.h b/NodeManager.h
index f1b5d4a..0334ef2 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -681,7 +681,7 @@ class SensorDigitalInput: public Sensor {
 */
 class SensorDigitalOutput: public Sensor {
   public:
-    SensorDigitalOutput(NodeManager* node_manager, int child_id, int pin);
+    SensorDigitalOutput(const NodeManager& node_manager, int pin);
     // [103] define which value to set to the output when set to on (default: HIGH)
     void setOnValue(int value);
     // [104] when legacy mode is enabled expect a REQ message to trigger, otherwise the default SET (default: false)
@@ -693,7 +693,7 @@ class SensorDigitalOutput: public Sensor {
     // [107] optionally wait for the given number of milliseconds after changing the status (default: 0)
     void setWaitAfterSet(int value);
     // manually switch the output to the provided value
-    void setStatus(int value);
+    void setStatus(Child* child, int value);
     // get the current state
     int getStatus();
     // define what to do at each stage of the sketch
@@ -701,7 +701,6 @@ class SensorDigitalOutput: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     int _on_value = HIGH;
@@ -710,18 +709,19 @@ class SensorDigitalOutput: public Sensor {
     bool _input_is_elapsed = false;
     int _wait_after_set = 0;
     Timer* _safeguard_timer;
-    void _setupPin(int pin);
-    virtual void _setStatus(int value);
+    void _setupPin(Child* child, int pin);
+    virtual void _setStatus(Child* child, int value);
     int _getValueToWrite(int value);
 };
 
-
 /*
    SensorRelay
 */
 class SensorRelay: public SensorDigitalOutput {
   public:
-    SensorRelay(NodeManager* node_manager, int child_id, int pin);
+    SensorRelay(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
 };
 
 /*
@@ -729,7 +729,7 @@ class SensorRelay: public SensorDigitalOutput {
 */
 class SensorLatchingRelay: public SensorRelay {
   public:
-    SensorLatchingRelay(NodeManager* node_manager, int child_id, int pin);
+    SensorLatchingRelay(const NodeManager& node_manager, int pin);
     // [201] set the duration of the pulse to send in ms to activate the relay (default: 50)
     void setPulseWidth(int value);
     // [202] set the pin which turns the relay off (default: the pin provided while registering the sensor)
@@ -738,12 +738,12 @@ class SensorLatchingRelay: public SensorRelay {
     void setPinOn(int value);
     // define what to do at each stage of the sketch
     void onBefore();
-    void onProcess(Request & request);
+    void onSetup();
   protected:
     int _pin_on;
     int _pin_off;
     int _pulse_width = 50;
-    void _setStatus(int value);
+    void _setStatus(Child* child, int value);
 };
 #endif
 
diff --git a/NodeManager.ino b/NodeManager.ino
index 986e633..bc448da 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -29,7 +29,10 @@ NodeManager node;
 //SensorThermistor thermistor(node,A0);
 //SensorML8511 ml8511(node,A0);
 //SensorACS712 acs712(node,A0);
-SensorDigitalInput digital(node,6);
+//SensorDigitalInput digitalIn(node,6);
+//SensorDigitalOutput digitalOut(node,6);
+//SensorRelay relay(node,6);
+SensorLatchingRelay latching(node,6);
 
 
 
diff --git a/config.h b/config.h
index 4767499..223528b 100755
--- a/config.h
+++ b/config.h
@@ -123,8 +123,8 @@
 #define MODULE_ACS712 0
 // Enable this module to use one of the following sensors: SensorDigitalInput
 #define MODULE_DIGITAL_INPUT 0
-// Enable this module to use one of the following sensors: SENSOR_DIGITAL_OUTPUT, SENSOR_RELAY, SENSOR_LATCHING_RELAY
-#define MODULE_DIGITAL_OUTPUT 0
+// Enable this module to use one of the following sensors: SensorDigitalOutput, SensorRelay, SensorLatchingRelay
+#define MODULE_DIGITAL_OUTPUT 1
 // Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
 #define MODULE_DHT 0
 // Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D

From 3cf5b01c0ae5aeec02ef721e3fe1404486146a34 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 18:27:25 +0100
Subject: [PATCH 31/51] Migrated SensorDHT11 SensorDHT22

---
 NodeManager.cpp | 77 +++++++++++++++++++++++++++++--------------------
 NodeManager.h   | 23 +++++++++++----
 NodeManager.ino |  4 ++-
 config.h        |  6 ++--
 4 files changed, 68 insertions(+), 42 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index f12c3a8..ff2d7f3 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -1458,36 +1458,29 @@ void SensorLatchingRelay::_setStatus(Child* child, int value) {
 }
 
 #endif
+
+#if MODULE_DHT == 1
 /*
    SensorDHT
 */
-#if MODULE_DHT == 1
+
 // contructor
-SensorDHT::SensorDHT(NodeManager* node_manager, int child_id, int pin, DHT* dht, int sensor_type, int dht_type): Sensor(node_manager, child_id, pin) {
-  // store the dht object
-  _dht = dht;
-  _sensor_type = sensor_type;
-  _dht_type = dht_type;
-  if (_sensor_type == SensorDHT::TEMPERATURE) {
-    // temperature sensor
-    setPresentation(S_TEMP);
-    setType(V_TEMP);
-    setValueType(TYPE_FLOAT);
-  }
-  else if (_sensor_type == SensorDHT::HUMIDITY) {
-    // humidity sensor
-    setPresentation(S_HUM);
-    setType(V_HUM);
-    setValueType(TYPE_FLOAT);
-  }
+SensorDHT::SensorDHT(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DHT";
+  _dht_type = DHT::DHT11;
 }
 
 // what to do during before
 void SensorDHT::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
 }
 
 // what to do during setup
 void SensorDHT::onSetup() {
+  // store the dht object
+  _dht = new DHT();
   // initialize the dht library
   _dht->setup(_pin,_dht_type);
 }
@@ -1497,46 +1490,66 @@ void SensorDHT::onLoop(Child* child) {
   _node->sleepOrWait(_dht->getMinimumSamplingPeriod());
   _dht->readSensor(true);
   // temperature sensor
-  if (_sensor_type == SensorDHT::TEMPERATURE) {
+  if (child->type == V_TEMP) {
     // read the temperature
     float temperature = _dht->getTemperature();
     if (! _node->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(F("DHT I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
     // store the value
-    if (! isnan(temperature)) _value_float = temperature;
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
   }
   // humidity sensor
-  else if (_sensor_type == SensorDHT::HUMIDITY) {
+  else if (child->type == V_HUM) {
     // read humidity
     float humidity = _dht->getHumidity();
     #if DEBUG == 1
-      Serial.print(F("DHT I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
     #endif
     // store the value
-    if (! isnan(humidity)) _value_float = humidity;
+    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
   }
 }
 
 // what to do as the main task when receiving a message
-void SensorDHT::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorDHT::onProcess(Request & request) {
+void SensorDHT::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
 void SensorDHT::onInterrupt() {
 }
+
+/*
+   SensorDHT11
+*/
+
+// contructor
+SensorDHT11::SensorDHT11(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
+  _name = "DHT11";
+  _dht_type = DHT::DHT11;
+}
+
+/*
+   SensorDHT11
+*/
+
+// contructor
+SensorDHT22::SensorDHT22(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
+  _name = "DHT22";
+  _dht_type = DHT::DHT22;
+}
 #endif
 
 /*
diff --git a/NodeManager.h b/NodeManager.h
index 0334ef2..67e9ff9 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -753,22 +753,33 @@ class SensorLatchingRelay: public SensorRelay {
 #if MODULE_DHT == 1
 class SensorDHT: public Sensor {
   public:
-    SensorDHT(NodeManager* node_manager, int child_id, int pin, DHT* dht, int sensor_type, int dht_type);
+    SensorDHT(const NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
-    // constants
-    const static int TEMPERATURE = 0;
-    const static int HUMIDITY = 1;
   protected:
     DHT* _dht;
     int _dht_type;
     float _offset = 0;
-    int _sensor_type = 0;
+};
+
+/*
+   SensorDHT11
+*/
+class SensorDHT11: public SensorDHT {
+  public:
+    SensorDHT11(const NodeManager& node_manager, int pin);
+};
+
+/*
+   SensorDHT22
+*/
+class SensorDHT22: public SensorDHT {
+  public:
+    SensorDHT22(const NodeManager& node_manager, int pin);
 };
 #endif
 
diff --git a/NodeManager.ino b/NodeManager.ino
index bc448da..dcb7774 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -32,7 +32,9 @@ NodeManager node;
 //SensorDigitalInput digitalIn(node,6);
 //SensorDigitalOutput digitalOut(node,6);
 //SensorRelay relay(node,6);
-SensorLatchingRelay latching(node,6);
+//SensorLatchingRelay latching(node,6);
+//SensorDHT11 dht11(node,6);
+//SensorDHT22 dht22(node,6);
 
 
 
diff --git a/config.h b/config.h
index 223528b..aa2dcec 100755
--- a/config.h
+++ b/config.h
@@ -124,9 +124,9 @@
 // Enable this module to use one of the following sensors: SensorDigitalInput
 #define MODULE_DIGITAL_INPUT 0
 // Enable this module to use one of the following sensors: SensorDigitalOutput, SensorRelay, SensorLatchingRelay
-#define MODULE_DIGITAL_OUTPUT 1
-// Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
-#define MODULE_DHT 0
+#define MODULE_DIGITAL_OUTPUT 0
+// Enable this module to use one of the following sensors: SensorDHT11, SensorDHT22
+#define MODULE_DHT 1
 // Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
 #define MODULE_SHT21 0
 // Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION

From fed5bcbbc28b98ea63b7828ab875ff02fc3067ac Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 18:43:30 +0100
Subject: [PATCH 32/51] Migrated SensorSwitch SensorDoor

---
 NodeManager.cpp | 82 ++++++++++++++++++++++++++++++-------------------
 NodeManager.h   | 10 +++---
 NodeManager.ino |  6 +++-
 config.h        |  8 ++---
 4 files changed, 65 insertions(+), 41 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index ff2d7f3..d02d595 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -765,7 +765,7 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #if MODULE_SHT21 == 1
-      if (strcmp(sensor->getName(),"SHT21") == 0) {
+      if (strcmp(sensor->getName(),"SHT21") == 0 || strcmp(sensor->getName(),"HTU21") == 0) {
         SensorSHT21* custom_sensor = (SensorSHT21*)sensor;
         switch(function) {
           default: return;
@@ -830,6 +830,18 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_SWITCH == 1
+      if (strcmp(sensor->getName(),"SWITCH") == 0 || strcmp(sensor->getName(),"DOOR") == 0 || strcmp(sensor->getName(),"MOTION") == 0) {
+        SensorSwitch* custom_sensor = (SensorSwitch*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setMode(request.getValueInt()); break;
+          case 102: custom_sensor->setDebounce(request.getValueInt()); break;
+          case 103: custom_sensor->setTriggerTime(request.getValueInt()); break;
+          case 104: custom_sensor->setInitial(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1619,14 +1631,13 @@ void SensorSHT21::onReceive(MyMessage* message) {
 // what to do when receiving an interrupt
 void SensorSHT21::onInterrupt() {
 }
-#endif
 
 /*
  * SensorHTU21D
  */
- #if MODULE_SHT21 == 1
-// constructor
+ // constructor
 SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
+  _name = "HTU21";
 }
 #endif 
 
@@ -1634,8 +1645,8 @@ SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
 /*
  * SensorSwitch
  */
-SensorSwitch::SensorSwitch(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id,pin) {
-  setType(V_TRIPPED);
+SensorSwitch::SensorSwitch(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "SWITCH";
 }
 
 // setter/getter
@@ -1654,12 +1665,13 @@ void SensorSwitch::setInitial(int value) {
 
 // what to do during before
 void SensorSwitch::onBefore() {
-  // set the interrupt pin so it will be called only when waking up from that interrupt
-  setInterrupt(_pin,_mode,_initial);
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_TRIPPED);
 }
 
 // what to do during setup
 void SensorSwitch::onSetup() {
+  // set the interrupt pin so it will be called only when waking up from that interrupt
+  setInterrupt(_pin,_mode,_initial);
   // report immediately
   _report_timer->unset();
 }
@@ -1669,27 +1681,18 @@ void SensorSwitch::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
-void SensorSwitch::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) {
-    _value_int = digitalRead(_pin);
-  }
-}
-
-// what to do when receiving a remote message
-void SensorSwitch::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setMode(request.getValueInt()); break;
-    case 102: setDebounce(request.getValueInt()); break;
-    case 103: setTriggerTime(request.getValueInt()); break;
-    case 104: setInitial(request.getValueInt()); break;
-    default: return;
+void SensorSwitch::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == V_STATUS) {
+    // return current status
+    ((ChildInt*)child)->setValueInt(digitalRead(_pin));
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
 void SensorSwitch::onInterrupt() {
+  Child* child = children.get(1);
   // wait to ensure the the input is not floating
   if (_debounce > 0) _node->sleepOrWait(_debounce);
   // read the value of the pin
@@ -1697,34 +1700,49 @@ void SensorSwitch::onInterrupt() {
   // process the value
   if ( (_mode == RISING && value == HIGH ) || (_mode == FALLING && value == LOW) || (_mode == CHANGE) )  {
     #if DEBUG == 1
-      Serial.print(F("SWITCH I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" P="));
       Serial.print(_pin);
       Serial.print(F(" V="));
       Serial.println(value);
     #endif
-    _value_int = value;
+    ((ChildInt*)child)->setValueInt(value);
     // allow the signal to be restored to its normal value
     if (_trigger_time > 0) _node->sleepOrWait(_trigger_time);
   } else {
     // invalid
-    _value_int = -1;
+    ((ChildInt*)child)->setValueInt(-1);
   }
 }
 
 /*
  * SensorDoor
  */
-SensorDoor::SensorDoor(NodeManager* node_manager, int child_id, int pin): SensorSwitch(node_manager,child_id,pin) {
-  setPresentation(S_DOOR);
+SensorDoor::SensorDoor(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
+  _name = "DOOR";
+}
+
+// what to do during before
+void SensorDoor::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_DOOR,V_TRIPPED);
 }
 
 /*
  * SensorMotion
  */
-SensorMotion::SensorMotion(NodeManager* node_manager, int child_id, int pin): SensorSwitch(node_manager, child_id,pin) {
-  setPresentation(S_MOTION);
+SensorMotion::SensorMotion(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
+  _name = "MOTION";
+}
+
+// what to do during before
+void SensorMotion::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_MOTION,V_TRIPPED);
+}
+
+// what to do during setup
+void SensorMotion::onSetup() {
   // set initial value to LOW
   setInitial(LOW);
 }
diff --git a/NodeManager.h b/NodeManager.h
index 67e9ff9..7c3a549 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -815,7 +815,7 @@ class SensorHTU21D: public SensorSHT21 {
 #if MODULE_SWITCH == 1
 class SensorSwitch: public Sensor {
   public:
-    SensorSwitch(NodeManager* node_manager, int child_id, int pin);
+    SensorSwitch(const NodeManager& node_manager, int pin);
     // [101] set the interrupt mode. Can be CHANGE, RISING, FALLING (default: CHANGE)
     void setMode(int value);
     // [102] milliseconds to wait before reading the input (default: 0)
@@ -829,7 +829,6 @@ class SensorSwitch: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     int _debounce = 0;
@@ -843,7 +842,8 @@ class SensorSwitch: public Sensor {
  */
 class SensorDoor: public SensorSwitch {
   public:
-    SensorDoor(NodeManager* node_manager, int child_id, int pin);
+    SensorDoor(const NodeManager& node_manager, int pin);
+    void onBefore();
 };
 
 /*
@@ -851,7 +851,9 @@ class SensorDoor: public SensorSwitch {
  */
 class SensorMotion: public SensorSwitch {
   public:
-    SensorMotion(NodeManager* node_manager, int child_id, int pin);
+    SensorMotion(const NodeManager& node_manager, int pin);
+    void onBefore();
+    void onSetup();
 };
 #endif
 /*
diff --git a/NodeManager.ino b/NodeManager.ino
index dcb7774..642c102 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -35,10 +35,14 @@ NodeManager node;
 //SensorLatchingRelay latching(node,6);
 //SensorDHT11 dht11(node,6);
 //SensorDHT22 dht22(node,6);
+//SensorSHT21 sht21(node);
+//SensorHTU21D htu21(node);
+//SensorSwitch sensorSwitch(node,3);
+//SensorDoor door(node,3);
+SensorMotion motion(node,3);
 
 
 
-//SensorSHT21 sht(node);
 //PowerManager power(5,6);
 //SensorBattery battery(node);
 SensorConfiguration configuration(node);
diff --git a/config.h b/config.h
index aa2dcec..d611a70 100755
--- a/config.h
+++ b/config.h
@@ -126,11 +126,11 @@
 // Enable this module to use one of the following sensors: SensorDigitalOutput, SensorRelay, SensorLatchingRelay
 #define MODULE_DIGITAL_OUTPUT 0
 // Enable this module to use one of the following sensors: SensorDHT11, SensorDHT22
-#define MODULE_DHT 1
-// Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
+#define MODULE_DHT 0
+// Enable this module to use one of the following sensors: SensorSHT21, SensorHTU21D
 #define MODULE_SHT21 0
-// Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION
-#define MODULE_SWITCH 0
+// Enable this module to use one of the following sensors: SensorSwitch, SensorDoor, SensorMotion
+#define MODULE_SWITCH 1
 // Enable this module to use one of the following sensors: SENSOR_DS18B20
 #define MODULE_DS18B20 0
 // Enable this module to use one of the following sensors: SENSOR_BH1750

From 38f3e67566a482054c736c8b540b7fdc6f08fb6f Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 19:10:51 +0100
Subject: [PATCH 33/51] Migrated SensorDs18b20

---
 NodeManager.cpp | 88 +++++++++++++++++++++++++++++++------------------
 NodeManager.h   | 15 +++++----
 NodeManager.ino |  3 +-
 config.h        |  6 ++--
 4 files changed, 69 insertions(+), 43 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index d02d595..188fec4 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -242,6 +242,10 @@ void Child::sendValue() {
 bool Child::isNewValue() {
 }
 
+/*
+ ChildInt class
+*/
+
 // ChildInt class
 ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -267,6 +271,10 @@ bool ChildInt::isNewValue() {
   return _last_value != _value;
 }
 
+/*
+ ChildFloat class
+*/
+
 // ChildFloat class
 ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -292,6 +300,18 @@ bool ChildFloat::isNewValue() {
   return _last_value != _value;
 }
 
+/*
+ ChildDs18b20 class
+*/
+
+ChildDs18b20::ChildDs18b20(Sensor* sensor, int child_id, int presentation, int type, int _index, char* description = ""): ChildFloat(sensor, child_id, presentation, type, description)  {
+  index = index;
+}
+
+/*
+ ChildDouble class
+*/
+
 // ChildDouble class
 ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -317,6 +337,10 @@ bool ChildDouble::isNewValue() {
   return _last_value != _value;
 }
 
+/*
+ ChildString class
+*/
+
 // ChildString class
 ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
 }
@@ -842,6 +866,16 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_DS18B20 == 1
+      if (strcmp(sensor->getName(),"DS18B20") == 0) {
+        SensorDs18b20* custom_sensor = (SensorDs18b20*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setResolution(request.getValueInt()); break;
+          case 102: custom_sensor->setSleepDuringConversion(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1753,18 +1787,21 @@ void SensorMotion::onSetup() {
 */
 #if MODULE_DS18B20 == 1
 // contructor
-SensorDs18b20::SensorDs18b20(NodeManager* node_manager, int child_id, int pin, DallasTemperature* sensors, int index): Sensor(node_manager,child_id, pin) {
-  setPresentation(S_TEMP);
-  setType(V_TEMP);
-  setValueType(TYPE_FLOAT);
-  _index = index;
-  _sensors = sensors;
-  // retrieve and store the address from the index
-  _sensors->getAddress(_device_address, index);
+SensorDs18b20::SensorDs18b20(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DS18B20";
 }
 
 // what to do during before
 void SensorDs18b20::onBefore() {
+  // initialize the library
+  OneWire* oneWire = new OneWire(_pin);
+  DallasTemperature* _sensors = new DallasTemperature(oneWire);
+  // initialize the sensors
+  _sensors->begin();
+  // register a new child for each sensor on the bus
+  for(int i = 0; i < _sensors->getDeviceCount(); i++) {
+    new ChildDs18b20(this,_node->getAvailableChildId(),S_TEMP,V_TEMP,i);
+  }
 }
 
 // what to do during setup
@@ -1783,52 +1820,39 @@ void SensorDs18b20::onLoop(Child* child) {
     sleep(conversion_time);
   }
   // read the temperature
-  float temperature = _sensors->getTempCByIndex(_index);
+  float temperature = _sensors->getTempCByIndex(((ChildDs18b20*)child)->index);
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
-    Serial.print(F("DS18B20 I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  _value_float = temperature;
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
 }
 
 // what to do as the main task when receiving a message
-void SensorDs18b20::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorDs18b20::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setResolution(request.getValueInt()); break;
-    case 102: setSleepDuringConversion(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorDs18b20::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
 void SensorDs18b20::onInterrupt() {
 }
 
-// function to print a device address
-DeviceAddress* SensorDs18b20::getDeviceAddress() {
-  return &_device_address;
-}
-
 // returns the sensor's resolution in bits
 int SensorDs18b20::getResolution() {
-  return _sensors->getResolution(_device_address);
+  return _sensors->getResolution();
 }
 
 // set the sensor's resolution in bits
 void SensorDs18b20::setResolution(int value) {
-   _sensors->setResolution(_device_address, value);
+  _sensors->setResolution(value);
 }
 
 // sleep while DS18B20 calculates temperature
diff --git a/NodeManager.h b/NodeManager.h
index 7c3a549..7a54687 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -361,6 +361,12 @@ class ChildFloat: public Child {
     float _total = 0;
 };
 
+class ChildDs18b20: public ChildFloat {
+  public:
+    ChildDs18b20(Sensor* sensor, int child_id, int presentation, int type, int _index, char* description);
+    int index;
+};
+
 class ChildDouble: public Child {
   public:
     ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
@@ -383,6 +389,7 @@ class ChildString: public Child {
     char* _value = "";
     char* _last_value = "";
 };
+
 /***************************************
    Sensor: generic sensor class
 */
@@ -862,28 +869,22 @@ class SensorMotion: public SensorSwitch {
 #if MODULE_DS18B20 == 1
 class SensorDs18b20: public Sensor {
   public:
-    SensorDs18b20(NodeManager* node_manager, int child_id, int pin, DallasTemperature* sensors, int index);
+    SensorDs18b20(const NodeManager& node_manager, int pin);
     // returns the sensor's resolution in bits
     int getResolution();
     // [101] set the sensor's resolution in bits
     void setResolution(int value);
     // [102] sleep while DS18B20 calculates temperature (default: false)
     void setSleepDuringConversion(bool value);
-    // return the sensors' device address
-    DeviceAddress* getDeviceAddress();
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
-    float _offset = 0;
-    int _index;
     bool _sleep_during_conversion = false;
     DallasTemperature* _sensors;
-    DeviceAddress _device_address;
 };
 #endif
 
diff --git a/NodeManager.ino b/NodeManager.ino
index 642c102..b1d8c47 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -39,7 +39,8 @@ NodeManager node;
 //SensorHTU21D htu21(node);
 //SensorSwitch sensorSwitch(node,3);
 //SensorDoor door(node,3);
-SensorMotion motion(node,3);
+//SensorMotion motion(node,3);
+SensorDs18b20 ds18b20(node,4);
 
 
 
diff --git a/config.h b/config.h
index d611a70..af3f2b7 100755
--- a/config.h
+++ b/config.h
@@ -130,9 +130,9 @@
 // Enable this module to use one of the following sensors: SensorSHT21, SensorHTU21D
 #define MODULE_SHT21 0
 // Enable this module to use one of the following sensors: SensorSwitch, SensorDoor, SensorMotion
-#define MODULE_SWITCH 1
-// Enable this module to use one of the following sensors: SENSOR_DS18B20
-#define MODULE_DS18B20 0
+#define MODULE_SWITCH 0
+// Enable this module to use one of the following sensors: SensorDs18b20
+#define MODULE_DS18B20 1
 // Enable this module to use one of the following sensors: SENSOR_BH1750
 #define MODULE_BH1750 0
 // Enable this module to use one of the following sensors: SENSOR_MLX90614

From 50d33bd817c56d7297f1bb6afaa4db076baa7563 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 19:15:56 +0100
Subject: [PATCH 34/51] Migrated SensorBH1750

---
 NodeManager.cpp | 48 +++++++++++++++++++++++++-----------------------
 NodeManager.h   |  3 +--
 NodeManager.ino |  3 ++-
 config.h        |  6 +++---
 4 files changed, 31 insertions(+), 29 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 188fec4..0299d63 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -876,6 +876,15 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_BH1750 == 1
+      if (strcmp(sensor->getName(),"BH1750") == 0) {
+        SensorBH1750* custom_sensor = (SensorBH1750*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setMode(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1867,53 +1876,46 @@ void SensorDs18b20::setSleepDuringConversion(bool value) {
 */
 #if MODULE_BH1750 == 1
 // contructor
-SensorBH1750::SensorBH1750(NodeManager* node_manager, int child_id): Sensor(node_manager,child_id,A4) {
-  setPresentation(S_LIGHT_LEVEL);
-  setType(V_LEVEL);
-  _lightSensor = new BH1750();
+SensorBH1750::SensorBH1750(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "BH1750";
 }
-
+// setter/getter
 void SensorBH1750::setMode(uint8_t mode) {
   _lightSensor->configure(mode);
 }
 
 // what to do during before
 void SensorBH1750::onBefore() {
-  _lightSensor->begin();
+  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
 }
 
 // what to do during setup
 void SensorBH1750::onSetup() {
+  _lightSensor = new BH1750();
+  _lightSensor->begin();
 }
 
 // what to do during loop
 void SensorBH1750::onLoop(Child* child) {
   // request the light level
-  _value_int = _lightSensor->readLightLevel();
+  int value = _lightSensor->readLightLevel();
   #if DEBUG == 1
-    Serial.print(F("BH1 I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" L="));
-    Serial.println(_value_int);
+    Serial.println(value);
   #endif
+  ((ChildInt*)child)->setValueInt(value);
 }
 
 // what to do as the main task when receiving a message
-void SensorBH1750::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorBH1750::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setMode(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorBH1750::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-
 // what to do when receiving an interrupt
 void SensorBH1750::onInterrupt() {
 }
diff --git a/NodeManager.h b/NodeManager.h
index 7a54687..91577fa 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -894,7 +894,7 @@ class SensorDs18b20: public Sensor {
 #if MODULE_BH1750 == 1
 class SensorBH1750: public Sensor {
   public:
-    SensorBH1750(NodeManager* node_manager, int child_id);
+    SensorBH1750(const NodeManager& node_manager);
     // [101] set sensor reading mode, e.g. BH1750_ONE_TIME_HIGH_RES_MODE
     void setMode(uint8_t mode);
     // define what to do at each stage of the sketch
@@ -902,7 +902,6 @@ class SensorBH1750: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     BH1750* _lightSensor;
diff --git a/NodeManager.ino b/NodeManager.ino
index b1d8c47..aeca764 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -40,7 +40,8 @@ NodeManager node;
 //SensorSwitch sensorSwitch(node,3);
 //SensorDoor door(node,3);
 //SensorMotion motion(node,3);
-SensorDs18b20 ds18b20(node,4);
+//SensorDs18b20 ds18b20(node,4);
+SensorBH1750 bh1750(node);
 
 
 
diff --git a/config.h b/config.h
index af3f2b7..bfbd319 100755
--- a/config.h
+++ b/config.h
@@ -132,9 +132,9 @@
 // Enable this module to use one of the following sensors: SensorSwitch, SensorDoor, SensorMotion
 #define MODULE_SWITCH 0
 // Enable this module to use one of the following sensors: SensorDs18b20
-#define MODULE_DS18B20 1
-// Enable this module to use one of the following sensors: SENSOR_BH1750
-#define MODULE_BH1750 0
+#define MODULE_DS18B20 0
+// Enable this module to use one of the following sensors: SensorBH1750
+#define MODULE_BH1750 1
 // Enable this module to use one of the following sensors: SENSOR_MLX90614
 #define MODULE_MLX90614 0
 // Enable this module to use one of the following sensors: SENSOR_BME280

From cbc7ba76c9e07b4b21b62377a36ce3b146097550 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 19:30:37 +0100
Subject: [PATCH 35/51] Migrated SensorMLX90614

---
 NodeManager.cpp | 34 ++++++++++++++++------------------
 NodeManager.h   |  3 +--
 NodeManager.ino |  3 ++-
 config.h        |  6 +++---
 4 files changed, 22 insertions(+), 24 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 0299d63..331b39f 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -1926,46 +1926,44 @@ void SensorBH1750::onInterrupt() {
 */
 #if MODULE_MLX90614 == 1
 // contructor
-SensorMLX90614::SensorMLX90614(NodeManager* node_manager, int child_id, Adafruit_MLX90614* mlx, int sensor_type): Sensor(node_manager,child_id,A4) {
-  _sensor_type = sensor_type;
-  _mlx = mlx;
-  // set presentation and type
-  setPresentation(S_TEMP);
-  setType(V_TEMP);
-  setValueType(TYPE_FLOAT);
+SensorMLX90614::SensorMLX90614(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "MLX90614";
 }
 
 // what to do during before
 void SensorMLX90614::onBefore() {
-  // initialize the library
-  _mlx->begin();
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
 }
 
 // what to do during setup
 void SensorMLX90614::onSetup() {
+  // initialize the library
+  _mlx->begin();
 }
 
 // what to do during loop
 void SensorMLX90614::onLoop(Child* child) {
-  float temperature = _sensor_type == SensorMLX90614::TEMPERATURE_OBJECT ? _mlx->readAmbientTempC() : _mlx->readObjectTempC();
+  float temperature;
+  // the first child is the ambient temperature, the second the object temperature
+  if (children.get(1) == child) temperature = _mlx->readAmbientTempC();
+  else temperature = _mlx->readObjectTempC();
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
     Serial.print(F("MLX I="));
-    Serial.print(_child_id);
+    Serial.print(child->child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
-  if (! isnan(temperature)) _value_float = temperature;
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
 }
 
 // what to do as the main task when receiving a message
-void SensorMLX90614::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorMLX90614::onProcess(Request & request) {
+void SensorMLX90614::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
diff --git a/NodeManager.h b/NodeManager.h
index 91577fa..a8910d9 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -914,13 +914,12 @@ class SensorBH1750: public Sensor {
 #if MODULE_MLX90614 == 1
 class SensorMLX90614: public Sensor {
   public:
-    SensorMLX90614(NodeManager* node_manager, int child_id, Adafruit_MLX90614* mlx, int sensor_type);
+    SensorMLX90614(const NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
     // constants
     const static int TEMPERATURE_AMBIENT = 0;
diff --git a/NodeManager.ino b/NodeManager.ino
index aeca764..512886b 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -41,7 +41,8 @@ NodeManager node;
 //SensorDoor door(node,3);
 //SensorMotion motion(node,3);
 //SensorDs18b20 ds18b20(node,4);
-SensorBH1750 bh1750(node);
+//SensorBH1750 bh1750(node);
+SensorMLX90614 mlx90614(node);
 
 
 
diff --git a/config.h b/config.h
index bfbd319..873e7df 100755
--- a/config.h
+++ b/config.h
@@ -134,9 +134,9 @@
 // Enable this module to use one of the following sensors: SensorDs18b20
 #define MODULE_DS18B20 0
 // Enable this module to use one of the following sensors: SensorBH1750
-#define MODULE_BH1750 1
-// Enable this module to use one of the following sensors: SENSOR_MLX90614
-#define MODULE_MLX90614 0
+#define MODULE_BH1750 9
+// Enable this module to use one of the following sensors: SensorMLX90614
+#define MODULE_MLX90614 1
 // Enable this module to use one of the following sensors: SENSOR_BME280
 #define MODULE_BME280 0
 // Enable this module to use one of the following sensors: SENSOR_SONOFF

From b5d2ef865d68bdfa5cd9a51e63caa2ed030d8db1 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 19:47:11 +0100
Subject: [PATCH 36/51] Migrated SensorBME280

---
 NodeManager.cpp | 118 ++++++++++++++++++------------------------------
 NodeManager.h   |  19 ++------
 NodeManager.ino |   3 +-
 config.h        |   8 ++--
 4 files changed, 52 insertions(+), 96 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 331b39f..4caaef9 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -300,14 +300,6 @@ bool ChildFloat::isNewValue() {
   return _last_value != _value;
 }
 
-/*
- ChildDs18b20 class
-*/
-
-ChildDs18b20::ChildDs18b20(Sensor* sensor, int child_id, int presentation, int type, int _index, char* description = ""): ChildFloat(sensor, child_id, presentation, type, description)  {
-  index = index;
-}
-
 /*
  ChildDouble class
 */
@@ -1809,7 +1801,7 @@ void SensorDs18b20::onBefore() {
   _sensors->begin();
   // register a new child for each sensor on the bus
   for(int i = 0; i < _sensors->getDeviceCount(); i++) {
-    new ChildDs18b20(this,_node->getAvailableChildId(),S_TEMP,V_TEMP,i);
+    new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
   }
 }
 
@@ -1819,6 +1811,11 @@ void SensorDs18b20::onSetup() {
 
 // what to do during loop
 void SensorDs18b20::onLoop(Child* child) {
+  int index = -1;
+  // get the index of the requested child
+  for (int i = 1; i <= children.size(); i++) {
+    if (children.get(i) == child) index = i-1;
+  }
   // do not wait for conversion, will sleep manually during it
   if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
   // request the temperature
@@ -1829,7 +1826,7 @@ void SensorDs18b20::onLoop(Child* child) {
     sleep(conversion_time);
   }
   // read the temperature
-  float temperature = _sensors->getTempCByIndex(((ChildDs18b20*)child)->index);
+  float temperature = _sensors->getTempCByIndex(index);
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
@@ -1977,32 +1974,8 @@ void SensorMLX90614::onInterrupt() {
 */
 #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
 // contructor
-SensorBosch::SensorBosch(NodeManager* node_manager, int child_id, int sensor_type): Sensor(node_manager, child_id,A4) {
-  _sensor_type = sensor_type;
-  if (_sensor_type == SensorBosch::TEMPERATURE) {
-    // temperature sensor
-    setPresentation(S_TEMP);
-    setType(V_TEMP);
-    setValueType(TYPE_FLOAT);
-  }
-  else if (_sensor_type == SensorBosch::HUMIDITY) {
-    // humidity sensor
-    setPresentation(S_HUM);
-    setType(V_HUM);
-    setValueType(TYPE_FLOAT);
-  }
-  else if (_sensor_type == SensorBosch::PRESSURE) {
-    // pressure sensor
-    setPresentation(S_BARO);
-    setType(V_PRESSURE);
-    setValueType(TYPE_FLOAT);
-  }
-  else if (_sensor_type == SensorBosch::FORECAST) {
-    // pressure sensor
-    setPresentation(S_BARO);
-    setType(V_FORECAST);
-    setValueType(TYPE_STRING);
-  }
+SensorBosch::SensorBosch(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "BOSH";
 }
 
 // setter/getter
@@ -2012,12 +1985,17 @@ void SensorBosch::setForecastSamplesCount(int value) {
 
 // what to do during before
 void SensorBosch::onBefore() {
-  // initialize the forecast samples array
-  _forecast_samples = new float[_forecast_samples_count];
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
 // what to do during setup
 void SensorBosch::onSetup() {
+  // initialize the forecast samples array
+  _forecast_samples = new float[_forecast_samples_count];
 }
 
 // what to do during loop
@@ -2025,18 +2003,10 @@ void SensorBosch::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
-void SensorBosch::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorBosch::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setForecastSamplesCount(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorBosch::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
@@ -2044,7 +2014,7 @@ void SensorBosch::onInterrupt() {
 }
 
 // calculate and send the forecast back
-void SensorBosch::_forecast(float pressure) {
+char* SensorBosch::_forecast(float pressure) {
   if (isnan(pressure)) return;
   // Calculate the average of the last n minutes.
   int index = _minute_count % _forecast_samples_count;
@@ -2107,17 +2077,16 @@ void SensorBosch::_forecast(float pressure) {
   else if ((_dP_dt > 0.05) && (_dP_dt < 0.25)) forecast = 1;
   else if ((_dP_dt >(-0.05)) && (_dP_dt < 0.05)) forecast = 0;
   else forecast = 5;
-  _value_string = _weather[forecast];
   #if DEBUG == 1
-    Serial.print(F("BMP I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
     Serial.print(F(" M="));
     Serial.print(_minute_count);
     Serial.print(F(" dP="));
     Serial.print(_dP_dt);
     Serial.print(F(" F="));
-    Serial.println(_value_string);
+    Serial.println(_weather[forecast]);
   #endif
+  return _weather[forecast];
 }
 
 // returns the average of the latest pressure samples
@@ -2156,58 +2125,57 @@ uint8_t SensorBosch::GetI2CAddress(uint8_t chip_id) {
  * SensorBME280
  */
 #if MODULE_BME280 == 1
-SensorBME280::SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME280* bme, int sensor_type): SensorBosch(node_manager, child_id,sensor_type) {
-  _bme = bme;
+SensorBME280::SensorBME280(const NodeManager& node_manager): SensorBosch(node_manager) {
+  _name = "BME280";
 }
 
 void SensorBME280::onLoop(Child* child) {
   // temperature sensor
-  if (_sensor_type == SensorBME280::TEMPERATURE) {
+  if (child->type == V_TEMP) {
     // read the temperature
     float temperature = _bme->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(F("BME I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
-    if (isnan(temperature)) return;
     // store the value
-    _value_float = temperature;
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
   }
   // Humidity Sensor
-  else if (_sensor_type == SensorBME280::HUMIDITY) {
+  else if (child->type == V_HUM) {
     // read humidity
     float humidity = _bme->readHumidity();
     #if DEBUG == 1
-      Serial.print(F("BME I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" H="));
       Serial.println(humidity);
     #endif
-    if (isnan(humidity)) return;
     // store the value
-    _value_float = humidity;
+    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
   }
   // Pressure Sensor
-  else if (_sensor_type == SensorBME280::PRESSURE) {
+  else if (child->type == V_PRESSURE) {
     // read pressure
     float pressure = _bme->readPressure() / 100.0F;
-    if (isnan(pressure)) return;
     #if DEBUG == 1
-      Serial.print(F("BME I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" P="));
       Serial.println(pressure);
     #endif
-    if (isnan(pressure)) return;
     // store the value
-    _value_float = pressure;
+    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
   }
   // Forecast Sensor
-  else if (_sensor_type == SensorBME280::FORECAST) {
+  else if (child->type == V_FORECAST) {
     float pressure = _bme->readPressure() / 100.0F;
     _forecast(pressure);
   }
@@ -2258,7 +2226,7 @@ void SensorBMP085::onLoop(Child* child) {
   // Forecast Sensor
   else if (_sensor_type == SensorBMP085::FORECAST) {
     float pressure = _bmp->readPressure() / 100.0F;
-    _forecast(pressure);    
+    ((ChildString*)child)->setValueString(_forecast(pressure));
   }
 }
 #endif
diff --git a/NodeManager.h b/NodeManager.h
index a8910d9..651eda7 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -361,12 +361,6 @@ class ChildFloat: public Child {
     float _total = 0;
 };
 
-class ChildDs18b20: public ChildFloat {
-  public:
-    ChildDs18b20(Sensor* sensor, int child_id, int presentation, int type, int _index, char* description);
-    int index;
-};
-
 class ChildDouble: public Child {
   public:
     ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
@@ -938,7 +932,7 @@ class SensorMLX90614: public Sensor {
 #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
 class SensorBosch: public Sensor {
   public:
-    SensorBosch(NodeManager* node_manager, int child_id, int sensor_type);
+    SensorBosch(const NodeManager& node_manager);
     // [101] define how many pressure samples to keep track of for calculating the forecast (default: 5)
     void setForecastSamplesCount(int value);
     // define what to do at each stage of the sketch
@@ -946,16 +940,9 @@ class SensorBosch: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
-    // constants
-    const static int TEMPERATURE = 0;
-    const static int HUMIDITY = 1;
-    const static int PRESSURE = 2;
-    const static int FORECAST = 3;
     static uint8_t GetI2CAddress(uint8_t chip_id);
   protected:
-    int _sensor_type;
     char* _weather[6] = { "stable", "sunny", "cloudy", "unstable", "thunderstorm", "unknown" };
     int _forecast_samples_count = 5;
     float* _forecast_samples;
@@ -965,7 +952,7 @@ class SensorBosch: public Sensor {
     float _dP_dt;
     bool _first_round = true;
     float _getLastPressureSamplesAverage();
-    void _forecast(float pressure);
+    char* _forecast(float pressure);
 };
 #endif
 
@@ -975,7 +962,7 @@ class SensorBosch: public Sensor {
 #if MODULE_BME280 == 1
 class SensorBME280: public SensorBosch {
   public:
-    SensorBME280(NodeManager* node_manager, int child_id, Adafruit_BME280* bme, int sensor_type);
+    SensorBME280(const NodeManager& node_manager);
     void onLoop(Child* child);
   protected:
     Adafruit_BME280* _bme;
diff --git a/NodeManager.ino b/NodeManager.ino
index 512886b..c70f176 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -42,7 +42,8 @@ NodeManager node;
 //SensorMotion motion(node,3);
 //SensorDs18b20 ds18b20(node,4);
 //SensorBH1750 bh1750(node);
-SensorMLX90614 mlx90614(node);
+//SensorMLX90614 mlx90614(node);
+SensorBME280 bme280(node);
 
 
 
diff --git a/config.h b/config.h
index 873e7df..ccfa3be 100755
--- a/config.h
+++ b/config.h
@@ -134,11 +134,11 @@
 // Enable this module to use one of the following sensors: SensorDs18b20
 #define MODULE_DS18B20 0
 // Enable this module to use one of the following sensors: SensorBH1750
-#define MODULE_BH1750 9
+#define MODULE_BH1750 0
 // Enable this module to use one of the following sensors: SensorMLX90614
-#define MODULE_MLX90614 1
-// Enable this module to use one of the following sensors: SENSOR_BME280
-#define MODULE_BME280 0
+#define MODULE_MLX90614 0
+// Enable this module to use one of the following sensors: SensorBME280
+#define MODULE_BME280 1
 // Enable this module to use one of the following sensors: SENSOR_SONOFF
 #define MODULE_SONOFF 0
 // Enable this module to use one of the following sensors: SENSOR_BMP085

From 190546295dee6ce33457b0d8582893604fa44724 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 10 Dec 2017 20:00:36 +0100
Subject: [PATCH 37/51] Migrated SensorBMP085 SensorBMP280

---
 NodeManager.cpp | 115 ++++++++++++++++++++++++++++++------------------
 NodeManager.h   |  16 ++++---
 NodeManager.ino |   6 ++-
 config.h        |  10 ++---
 4 files changed, 93 insertions(+), 54 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 4caaef9..bc77700 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -877,6 +877,16 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
+      if (strcmp(sensor->getName(),"BME280") == 0) {
+        SensorBosch* custom_sensor = (SensorBosch*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setForecastSamplesCount(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -1985,11 +1995,6 @@ void SensorBosch::setForecastSamplesCount(int value) {
 
 // what to do during before
 void SensorBosch::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
 // what to do during setup
@@ -2129,11 +2134,20 @@ SensorBME280::SensorBME280(const NodeManager& node_manager): SensorBosch(node_ma
   _name = "BME280";
 }
 
+// what to do during before
+void SensorBME280::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
+}
+
 void SensorBME280::onLoop(Child* child) {
   // temperature sensor
   if (child->type == V_TEMP) {
     // read the temperature
-    float temperature = _bme->readTemperature();
+    float temperature = _bm->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
@@ -2149,7 +2163,7 @@ void SensorBME280::onLoop(Child* child) {
   // Humidity Sensor
   else if (child->type == V_HUM) {
     // read humidity
-    float humidity = _bme->readHumidity();
+    float humidity = _bm->readHumidity();
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -2163,7 +2177,7 @@ void SensorBME280::onLoop(Child* child) {
   // Pressure Sensor
   else if (child->type == V_PRESSURE) {
     // read pressure
-    float pressure = _bme->readPressure() / 100.0F;
+    float pressure = _bm->readPressure() / 100.0F;
     #if DEBUG == 1
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -2176,7 +2190,7 @@ void SensorBME280::onLoop(Child* child) {
   }
   // Forecast Sensor
   else if (child->type == V_FORECAST) {
-    float pressure = _bme->readPressure() / 100.0F;
+    float pressure = _bm->readPressure() / 100.0F;
     _forecast(pressure);
   }
 }
@@ -2187,46 +2201,54 @@ void SensorBME280::onLoop(Child* child) {
 */
 #if MODULE_BMP085 == 1
 // contructor
-SensorBMP085::SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP085* bmp, int sensor_type): SensorBosch(node_manager, child_id,sensor_type) {
-  _bmp = bmp;
+SensorBMP085::SensorBMP085(const NodeManager& node_manager): SensorBosch(node_manager) {
+  _name = "BMP085";
+}
+
+// what to do during before
+void SensorBMP085::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
 // what to do during loop
 void SensorBMP085::onLoop(Child* child) {
   // temperature sensor
-  if (_sensor_type == SensorBMP085::TEMPERATURE) {
+  if (child->type == V_TEMP) {
     // read the temperature
-    float temperature = _bmp->readTemperature();
+    float temperature = _bm->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(F("BMP I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
-    if (isnan(temperature)) return;
     // store the value
-    _value_float = temperature;
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
   }
   // Pressure Sensor
-  else if (_sensor_type == SensorBMP085::PRESSURE) {
+  else if (child->type == V_PRESSURE) {
     // read pressure
-    float pressure = _bmp->readPressure() / 100.0F;
+    float pressure = _bm->readPressure() / 100.0F;
     #if DEBUG == 1
-      Serial.print(F("BMP I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" P="));
       Serial.println(pressure);
     #endif
-    if (isnan(pressure)) return;
     // store the value
-    _value_float = pressure;
+    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
   }
   // Forecast Sensor
-  else if (_sensor_type == SensorBMP085::FORECAST) {
-    float pressure = _bmp->readPressure() / 100.0F;
-    ((ChildString*)child)->setValueString(_forecast(pressure));
+  else if (child->type == V_FORECAST) {
+    float pressure = _bm->readPressure() / 100.0F;
+    _forecast(pressure);
   }
 }
 #endif
@@ -2235,45 +2257,52 @@ void SensorBMP085::onLoop(Child* child) {
  * SensorBMP280
  */
 #if MODULE_BMP280 == 1
-SensorBMP280::SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP280* bmp, int sensor_type): SensorBosch(node_manager, child_id,sensor_type) {
-  _bmp = bmp;
+SensorBMP280::SensorBMP280(const NodeManager& node_manager): SensorBosch(node_manager) {
+  _name = "BMP280";
+}
+
+  // what to do during before
+void SensorBMP280::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
 void SensorBMP280::onLoop(Child* child) {
   // temperature sensor
-  if (_sensor_type == SensorBMP280::TEMPERATURE) {
+  if (child->type == V_TEMP) {
     // read the temperature
-    float temperature = _bmp->readTemperature();
+    float temperature = _bm->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
     #if DEBUG == 1
-      Serial.print(F("BMP I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" T="));
       Serial.println(temperature);
     #endif
-    if (isnan(temperature)) return;
     // store the value
-    _value_float = temperature;
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
   }
   // Pressure Sensor
-  else if (_sensor_type == SensorBMP280::PRESSURE) {
+  else if (child->type == V_PRESSURE) {
     // read pressure
-    float pressure = _bmp->readPressure() / 100.0F;
-    if (isnan(pressure)) return;
+    float pressure = _bm->readPressure() / 100.0F;
     #if DEBUG == 1
-      Serial.print(F("BMP I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" P="));
       Serial.println(pressure);
     #endif
-    if (isnan(pressure)) return;
     // store the value
-    _value_float = pressure;
+    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
   }
   // Forecast Sensor
-  else if (_sensor_type == SensorBMP280::FORECAST) {
-    float pressure = _bmp->readPressure() / 100.0F;
+  else if (child->type == V_FORECAST) {
+    float pressure = _bm->readPressure() / 100.0F;
     _forecast(pressure);
   }
 }
diff --git a/NodeManager.h b/NodeManager.h
index 651eda7..826a1af 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -963,9 +963,11 @@ class SensorBosch: public Sensor {
 class SensorBME280: public SensorBosch {
   public:
     SensorBME280(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
     void onLoop(Child* child);
   protected:
-    Adafruit_BME280* _bme;
+    Adafruit_BME280* _bm;
 };
 #endif
 
@@ -975,10 +977,12 @@ class SensorBME280: public SensorBosch {
 #if MODULE_BMP085 == 1
 class SensorBMP085: public SensorBosch {
   public:
-    SensorBMP085(NodeManager* node_manager, int child_id, Adafruit_BMP085* bmp, int sensor_type);
+    SensorBMP085(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
     void onLoop(Child* child);
   protected:
-    Adafruit_BMP085* _bmp;
+    Adafruit_BMP085* _bm;
 };
 #endif
 
@@ -988,10 +992,12 @@ class SensorBMP085: public SensorBosch {
 #if MODULE_BMP280 == 1
 class SensorBMP280: public SensorBosch {
   public:
-    SensorBMP280(NodeManager* node_manager, int child_id, Adafruit_BMP280* bmp, int sensor_type);
+    SensorBMP280(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
     void onLoop(Child* child);
   protected:
-    Adafruit_BMP280* _bmp;
+    Adafruit_BMP280* _bm;
 };
 #endif
 
diff --git a/NodeManager.ino b/NodeManager.ino
index c70f176..3a9af63 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -43,7 +43,11 @@ NodeManager node;
 //SensorDs18b20 ds18b20(node,4);
 //SensorBH1750 bh1750(node);
 //SensorMLX90614 mlx90614(node);
-SensorBME280 bme280(node);
+//SensorBME280 bme280(node);
+//SensorBMP085 bmp085(node);
+SensorBMP280 bmp280(node);
+
+
 
 
 
diff --git a/config.h b/config.h
index ccfa3be..d8b38d4 100755
--- a/config.h
+++ b/config.h
@@ -138,11 +138,13 @@
 // Enable this module to use one of the following sensors: SensorMLX90614
 #define MODULE_MLX90614 0
 // Enable this module to use one of the following sensors: SensorBME280
-#define MODULE_BME280 1
+#define MODULE_BME280 0
+// Enable this module to use one of the following sensors: SensorBMP085
+#define MODULE_BMP085 0
+// Enable this module to use one of the following sensors: SensorBMP280
+#define MODULE_BMP280 1
 // Enable this module to use one of the following sensors: SENSOR_SONOFF
 #define MODULE_SONOFF 0
-// Enable this module to use one of the following sensors: SENSOR_BMP085
-#define MODULE_BMP085 0
 // Enable this module to use one of the following sensors: SENSOR_HCSR04
 #define MODULE_HCSR04 0
 // Enable this module to use one of the following sensors: SENSOR_MCP9808
@@ -157,8 +159,6 @@
 #define MODULE_TSL2561 0
 // Enable this module to use one of the following sensors: SENSOR_PT100
 #define MODULE_PT100 0
-// Enable this module to use one of the following sensors: SENSOR_BMP280
-#define MODULE_BMP280 0
 // Enable this module to use one of the following sensors: SENSOR_DIMMER
 #define MODULE_DIMMER 0
 // Enable this module to use one of the following sensors: SENSOR_RAIN_GAUGE, SENSOR_POWER_METER, SENSOR_WATER_METER

From 6e6a17d8acbd203a9a0ae5960a468161f8265a1b Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 18:12:32 +0100
Subject: [PATCH 38/51] Migrated SensorSonoff

---
 NodeManager.cpp | 46 +++++++++++++++++++---------------------------
 NodeManager.h   |  5 ++---
 NodeManager.ino |  4 +++-
 config.h        |  6 +++---
 4 files changed, 27 insertions(+), 34 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index bc77700..942dfe3 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -2381,10 +2381,9 @@ void SensorHCSR04::onInterrupt() {
 */
 #if MODULE_SONOFF == 1
 // contructor
-SensorSonoff::SensorSonoff(NodeManager* node_manager, int child_id): Sensor(node_manager, child_id,1) {
-  setPresentation(S_BINARY);
-  setType(V_STATUS);
-}
+SensorSonoff::SensorSonoff(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "SONOFF";
+} 
 
 // setter/getter
 void SensorSonoff::setButtonPin(int value) {
@@ -2399,6 +2398,8 @@ void SensorSonoff::setLedPin(int value) {
 
 // what to do during before
 void SensorSonoff::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
 }
 
 // what to do during setup
@@ -2424,44 +2425,34 @@ void SensorSonoff::onLoop(Child* child) {
   int value = _debouncer.read();
   if (value != _old_value && value == 0) {
     // button pressed, toggle the state
-    _toggle();
+    _toggle(child);
   }
   _old_value = value;
 }
 
 // what to do as the main task when receiving a message
-void SensorSonoff::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_SET) {
+void SensorSonoff::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_SET) {
     // retrieve from the message the value to set
-    int value = message.getInt();
+    int value = message->getInt();
     if (value != 0 && value != 1 || value == _state) return;
     // toggle the state
-    _toggle();
+    _toggle(child);
   }
-  if (message.getCommand() == C_REQ) {
+  if (message->getCommand() == C_REQ) {
     // return the current state
-    _value_int = _state;
+    ((ChildInt*)child)->setValueInt(_state);
   }
 }
 
-// what to do when receiving a remote message
-void SensorSonoff::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setButtonPin(request.getValueInt()); break;
-    case 102: setRelayPin(request.getValueInt()); break;
-    case 103: setLedPin(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
-}
-
 // what to do when receiving an interrupt
 void SensorSonoff::onInterrupt() {
 }
 
 // toggle the state
-void SensorSonoff::_toggle() {
+void SensorSonoff::_toggle(Child* child) {
   // toggle the state
   _state = _state ? false : true;
   // Change relay state
@@ -2469,12 +2460,13 @@ void SensorSonoff::_toggle() {
   // Change LED state
   digitalWrite(_led_pin, _state? _led_on: _led_off);
   #if DEBUG == 1
-    Serial.print(F("SONOFF I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" V="));
     Serial.println(_state);
   #endif
-  _value_int = _state;
+  ((ChildInt*)child)->setValueInt(_state);
 }
 
 // blink the led
diff --git a/NodeManager.h b/NodeManager.h
index 826a1af..d4cb03f 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1035,7 +1035,7 @@ class SensorHCSR04: public Sensor {
 #if MODULE_SONOFF == 1
 class SensorSonoff: public Sensor {
   public:
-    SensorSonoff(NodeManager* node_manager, int child_id);
+    SensorSonoff(const NodeManager& node_manager);
     // [101] set the button's pin (default: 0)
     void setButtonPin(int value);
     // [102] set the relay's pin (default: 12)
@@ -1047,7 +1047,6 @@ class SensorSonoff: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     Bounce _debouncer = Bounce();
@@ -1061,7 +1060,7 @@ class SensorSonoff: public Sensor {
     int _led_on = 0;
     int _led_off = 1;
     void _blink();
-    void _toggle();
+    void _toggle(Child* child);
 };
 #endif
 
diff --git a/NodeManager.ino b/NodeManager.ino
index 3a9af63..9455c98 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -45,7 +45,8 @@ NodeManager node;
 //SensorMLX90614 mlx90614(node);
 //SensorBME280 bme280(node);
 //SensorBMP085 bmp085(node);
-SensorBMP280 bmp280(node);
+//SensorBMP280 bmp280(node);
+SensorSonoff sonoff(node);
 
 
 
@@ -120,3 +121,4 @@ void receiveTime(unsigned long ts) {
   // call NodeManager receiveTime routine
   node.receiveTime(ts);
 }
+
diff --git a/config.h b/config.h
index d8b38d4..a583572 100755
--- a/config.h
+++ b/config.h
@@ -142,9 +142,9 @@
 // Enable this module to use one of the following sensors: SensorBMP085
 #define MODULE_BMP085 0
 // Enable this module to use one of the following sensors: SensorBMP280
-#define MODULE_BMP280 1
-// Enable this module to use one of the following sensors: SENSOR_SONOFF
-#define MODULE_SONOFF 0
+#define MODULE_BMP280 0
+// Enable this module to use one of the following sensors: SensorSonoff
+#define MODULE_SONOFF 1
 // Enable this module to use one of the following sensors: SENSOR_HCSR04
 #define MODULE_HCSR04 0
 // Enable this module to use one of the following sensors: SENSOR_MCP9808

From 9fda15241cb0523efb9ed4865b126a74ffa40886 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 18:19:40 +0100
Subject: [PATCH 39/51] Migrated SensorHCSR04

---
 NodeManager.cpp | 148 ++++++++++++++++++++++++++----------------------
 NodeManager.h   |  56 +++++++++---------
 NodeManager.ino |   3 +-
 config.h        |   6 +-
 4 files changed, 113 insertions(+), 100 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 942dfe3..0f704df 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -886,6 +886,28 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_SONOFF == 1
+      if (strcmp(sensor->getName(),"SONOFF") == 0) {
+        SensorSonoff* custom_sensor = (SensorSonoff*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setButtonPin(request.getValueInt()); break;
+          case 102: custom_sensor->setRelayPin(request.getValueInt()); break;
+          case 103: custom_sensor->setLedPin(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_HCSR04 == 1
+      if (strcmp(sensor->getName(),"HCSR04") == 0) {
+        SensorHCSR04* custom_sensor = (SensorHCSR04*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setTriggerPin(request.getValueInt()); break;
+          case 102: custom_sensor->setEchoPin(request.getValueInt()); break;
+          case 103: custom_sensor->setMaxDistance(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
       
     }
   }
@@ -2308,74 +2330,6 @@ void SensorBMP280::onLoop(Child* child) {
 }
 #endif
 
-/*
-   SensorHCSR04
-*/
-#if MODULE_HCSR04 == 1
-// contructor
-SensorHCSR04::SensorHCSR04(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
-  // set presentation and type
-  setPresentation(S_DISTANCE);
-  setType(V_DISTANCE);
-  _trigger_pin = pin;
-  _echo_pin = pin;
-}
-
-// what to do during before
-void SensorHCSR04::onBefore() {
-  // initialize the library
-  _sonar = new NewPing(_trigger_pin,_echo_pin,_max_distance);
-}
-
-// setter/getter
-void SensorHCSR04::setTriggerPin(int value) {
-  _trigger_pin = value;
-}
-void SensorHCSR04::setEchoPin(int value) {
-  _echo_pin = value;
-}
-void SensorHCSR04::setMaxDistance(int value) {
-  _max_distance = value;
-}
-
-// what to do during setup
-void SensorHCSR04::onSetup() {
-}
-
-// what to do during loop
-void SensorHCSR04::onLoop(Child* child) {
-  int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
-  #if DEBUG == 1
-    Serial.print(F("HC I="));
-    Serial.print(_child_id);
-    Serial.print(F(" D="));
-    Serial.println(distance);
-  #endif
-  _value_int = distance;
-}
-
-// what to do as the main task when receiving a message
-void SensorHCSR04::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorHCSR04::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setTriggerPin(request.getValueInt()); break;
-    case 102: setEchoPin(request.getValueInt()); break;
-    case 103: setMaxDistance(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
-}
-
-// what to do when receiving an interrupt
-void SensorHCSR04::onInterrupt() {
-}
-#endif
-
 /*
    SensorSonoff
 */
@@ -2481,6 +2435,64 @@ void SensorSonoff::_blink() {
 }
 #endif
 
+/*
+   SensorHCSR04
+*/
+#if MODULE_HCSR04 == 1
+// contructor
+SensorHCSR04::SensorHCSR04(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "HCSR04";
+  _trigger_pin = pin;
+  _echo_pin = pin;
+}
+
+// setter/getter
+void SensorHCSR04::setTriggerPin(int value) {
+  _trigger_pin = value;
+}
+void SensorHCSR04::setEchoPin(int value) {
+  _echo_pin = value;
+}
+void SensorHCSR04::setMaxDistance(int value) {
+  _max_distance = value;
+}
+
+// what to do during before
+void SensorHCSR04::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_DISTANCE,V_DISTANCE);
+}
+
+// what to do during setup
+void SensorHCSR04::onSetup() {
+  // initialize the library
+  _sonar = new NewPing(_trigger_pin,_echo_pin,_max_distance);
+}
+
+// what to do during loop
+void SensorHCSR04::onLoop(Child* child) {
+  int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" D="));
+    Serial.println(distance);
+  #endif
+  ((ChildInt*)child)->setValueInt(distance);
+}
+
+// what to do as the main task when receiving a message
+void SensorHCSR04::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorHCSR04::onInterrupt() {
+}
+#endif
 
 /*
    SensorMCP9808
diff --git a/NodeManager.h b/NodeManager.h
index d4cb03f..d65710f 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1001,34 +1001,6 @@ class SensorBMP280: public SensorBosch {
 };
 #endif
 
-/*
-   SensorHCSR04
-*/
-#if MODULE_HCSR04 == 1
-class SensorHCSR04: public Sensor {
-  public:
-    SensorHCSR04(NodeManager* node_manager, int child_id, int pin);
-    // [101] Arduino pin tied to trigger pin on the ultrasonic sensor (default: the pin set while registering the sensor)
-    void setTriggerPin(int value);
-    // [102] Arduino pin tied to echo pin on the ultrasonic sensor (default: the pin set while registering the sensor)
-    void setEchoPin(int value);
-    // [103] Maximum distance we want to ping for (in centimeters) (default: 300)
-    void setMaxDistance(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onProcess(Request & request);
-    void onInterrupt();
-  protected:
-    int _trigger_pin;
-    int _echo_pin;
-    int _max_distance = 300;
-    NewPing* _sonar;
-};
-#endif
-
 /*
    SensorSonoff
 */
@@ -1064,6 +1036,34 @@ class SensorSonoff: public Sensor {
 };
 #endif
 
+/*
+   SensorHCSR04
+*/
+#if MODULE_HCSR04 == 1
+class SensorHCSR04: public Sensor {
+  public:
+    SensorHCSR04(const NodeManager& node_manager, int pin);
+    // [101] Arduino pin tied to trigger pin on the ultrasonic sensor (default: the pin set while registering the sensor)
+    void setTriggerPin(int value);
+    // [102] Arduino pin tied to echo pin on the ultrasonic sensor (default: the pin set while registering the sensor)
+    void setEchoPin(int value);
+    // [103] Maximum distance we want to ping for (in centimeters) (default: 300)
+    void setMaxDistance(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onProcess(Request & request);
+    void onInterrupt();
+  protected:
+    int _trigger_pin;
+    int _echo_pin;
+    int _max_distance = 300;
+    NewPing* _sonar;
+};
+#endif
+
 /*
    SensorMCP9808
 */
diff --git a/NodeManager.ino b/NodeManager.ino
index 9455c98..77b3cf9 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -46,7 +46,8 @@ NodeManager node;
 //SensorBME280 bme280(node);
 //SensorBMP085 bmp085(node);
 //SensorBMP280 bmp280(node);
-SensorSonoff sonoff(node);
+//SensorSonoff sonoff(node);
+SensorHCSR04 hcsr04(node,4);
 
 
 
diff --git a/config.h b/config.h
index a583572..bb04095 100755
--- a/config.h
+++ b/config.h
@@ -144,9 +144,9 @@
 // Enable this module to use one of the following sensors: SensorBMP280
 #define MODULE_BMP280 0
 // Enable this module to use one of the following sensors: SensorSonoff
-#define MODULE_SONOFF 1
-// Enable this module to use one of the following sensors: SENSOR_HCSR04
-#define MODULE_HCSR04 0
+#define MODULE_SONOFF 0
+// Enable this module to use one of the following sensors: SensorHCSR04
+#define MODULE_HCSR04 1
 // Enable this module to use one of the following sensors: SENSOR_MCP9808
 #define MODULE_MCP9808 0
 // Enable this module to use one of the following sensors: SENSOR_MQ

From 7f22d1fa9739d3eb520ef559bf18afed36dbafcf Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 18:25:35 +0100
Subject: [PATCH 40/51] Migrated SensorMCP9808

---
 NodeManager.cpp | 27 +++++++++++++--------------
 NodeManager.h   |  2 +-
 NodeManager.ino |  3 ++-
 config.h        |  6 +++---
 4 files changed, 19 insertions(+), 19 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 0f704df..7c9a3c7 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -1968,6 +1968,7 @@ void SensorMLX90614::onBefore() {
 // what to do during setup
 void SensorMLX90614::onSetup() {
   // initialize the library
+  _mlx = new Adafruit_MLX90614();
   _mlx->begin();
 }
 
@@ -2499,19 +2500,18 @@ void SensorHCSR04::onInterrupt() {
 */
 #if MODULE_MCP9808 == 1
 // contructor
-SensorMCP9808::SensorMCP9808(NodeManager* node_manager, int child_id, Adafruit_MCP9808* mcp): Sensor(node_manager, child_id,A2) {
-  _mcp = mcp;
-  setPresentation(S_TEMP);
-  setType(V_TEMP);
-  setValueType(TYPE_FLOAT);
+SensorMCP9808::SensorMCP9808(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "MCP9808";
 }
 
 // what to do during before
 void SensorMCP9808::onBefore() {
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
 }
 
 // what to do during setup
 void SensorMCP9808::onSetup() {
+  _mcp = new Adafruit_MCP9808();
 }
 
 // what to do during loop
@@ -2520,22 +2520,21 @@ void SensorMCP9808::onLoop(Child* child) {
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
   #if DEBUG == 1
-    Serial.print(F("MCP I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  if (! isnan(temperature)) _value_float = temperature;
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
 }
 
 // what to do as the main task when receiving a message
-void SensorMCP9808::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorMCP9808::onProcess(Request & request) {
+void SensorMCP9808::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
diff --git a/NodeManager.h b/NodeManager.h
index d65710f..f06692d 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1070,7 +1070,7 @@ class SensorHCSR04: public Sensor {
 #if MODULE_MCP9808 == 1
 class SensorMCP9808: public Sensor {
   public:
-    SensorMCP9808(NodeManager* node_manager, int child_id, Adafruit_MCP9808* mcp);
+    SensorMCP9808(const NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
diff --git a/NodeManager.ino b/NodeManager.ino
index 77b3cf9..c219ac7 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -47,7 +47,8 @@ NodeManager node;
 //SensorBMP085 bmp085(node);
 //SensorBMP280 bmp280(node);
 //SensorSonoff sonoff(node);
-SensorHCSR04 hcsr04(node,4);
+//SensorHCSR04 hcsr04(node,4);
+SensorMCP9808 mcp9808(node);
 
 
 
diff --git a/config.h b/config.h
index bb04095..8d9e54c 100755
--- a/config.h
+++ b/config.h
@@ -146,9 +146,9 @@
 // Enable this module to use one of the following sensors: SensorSonoff
 #define MODULE_SONOFF 0
 // Enable this module to use one of the following sensors: SensorHCSR04
-#define MODULE_HCSR04 1
-// Enable this module to use one of the following sensors: SENSOR_MCP9808
-#define MODULE_MCP9808 0
+#define MODULE_HCSR04 0
+// Enable this module to use one of the following sensors: SensorMCP9808
+#define MODULE_MCP9808 1
 // Enable this module to use one of the following sensors: SENSOR_MQ
 #define MODULE_MQ 0
 // Enable this module to use one of the following sensors: SENSOR_MHZ19

From 42062bf236dc2692a807ed6ed1d30db41f7d85ab Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 18:31:44 +0100
Subject: [PATCH 41/51] Migrated 936

---
 NodeManager.cpp | 53 ++++++++++++++++++++++++++-----------------------
 NodeManager.h   |  4 +---
 NodeManager.ino |  3 ++-
 config.h        |  6 +++---
 4 files changed, 34 insertions(+), 32 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 7c9a3c7..1dc447d 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -908,6 +908,22 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
+      #if MODULE_MQ == 1
+      if (strcmp(sensor->getName(),"MQ") == 0) {
+        SensorMQ* custom_sensor = (SensorMQ*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setTargetGas(request.getValueInt()); break;
+          case 102: custom_sensor->setRlValue(request.getValueFloat()); break;
+          case 103: custom_sensor->setRoValue(request.getValueFloat()); break;
+          case 104: custom_sensor->setCleanAirFactor(request.getValueFloat()); break;
+          case 105: custom_sensor->setCalibrationSampleTimes(request.getValueInt()); break;
+          case 106: custom_sensor->setCalibrationSampleInterval(request.getValueInt()); break;
+          case 107: custom_sensor->setReadSampleTimes(request.getValueInt()); break;
+          case 108: custom_sensor->setReadSampleInterval(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
       
     }
   }
@@ -2552,9 +2568,8 @@ static float SensorMQ::_default_LPGCurve[3] = {2.3,0.21,-0.47};
 static float SensorMQ::_default_COCurve[3] = {2.3,0.72,-0.34};
 static float SensorMQ::_default_SmokeCurve[3] = {2.3,0.53,-0.44};
 
-SensorMQ::SensorMQ(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id,pin) {
-  setPresentation(S_AIR_QUALITY);
-  setType(V_LEVEL);
+SensorMQ::SensorMQ(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "MQ";
   _LPGCurve = SensorMQ::_default_LPGCurve;
   _COCurve = SensorMQ::_default_COCurve;
   _SmokeCurve = SensorMQ::_default_SmokeCurve;
@@ -2599,6 +2614,8 @@ void SensorMQ::setSmokeCurve(float *value) {
 void SensorMQ::onBefore() {
   // prepare the pin for input
   pinMode(_pin, INPUT);
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
 }
 
 // what to do during setup
@@ -2620,8 +2637,9 @@ void SensorMQ::onLoop(Child* child) {
   if (_target_gas == _gas_co) value = co;
   if (_target_gas == _gas_smoke) value = smoke;
   #if DEBUG == 1
-    Serial.print(F("MQ I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" V="));
     Serial.print(value);
     Serial.print(F(" LPG="));
@@ -2632,29 +2650,14 @@ void SensorMQ::onLoop(Child* child) {
     Serial.println(smoke);
   #endif
   // store the value
-  _value_int = (int16_t)ceil(value);
+  ((ChildInt*)child)->setValueInt((int16_t)ceil(value));
 }
 
 // what to do as the main task when receiving a message
-void SensorMQ::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorMQ::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 1: setTargetGas(request.getValueInt()); break;
-    case 2: setRlValue(request.getValueFloat()); break;
-    case 3: setRoValue(request.getValueFloat()); break;
-    case 4: setCleanAirFactor(request.getValueFloat()); break;
-    case 5: setCalibrationSampleTimes(request.getValueInt()); break;
-    case 6: setCalibrationSampleInterval(request.getValueInt()); break;
-    case 7: setReadSampleTimes(request.getValueInt()); break;
-    case 8: setReadSampleInterval(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorMQ::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
diff --git a/NodeManager.h b/NodeManager.h
index f06692d..c53e878 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1076,7 +1076,6 @@ class SensorMCP9808: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     Adafruit_MCP9808* _mcp;
@@ -1089,7 +1088,7 @@ class SensorMCP9808: public Sensor {
  #if MODULE_MQ == 1
 class SensorMQ: public Sensor {
   public:
-    SensorMQ(NodeManager* node_manager, int child_id, int pin);
+    SensorMQ(const NodeManager& node_manager, int pin);
     // [101] define the target gas whose ppm has to be returned. 0: LPG, 1: CO, 2: Smoke (default: 1);
     void setTargetGas(int value);
     // [102] define the load resistance on the board, in kilo ohms (default: 1);
@@ -1117,7 +1116,6 @@ class SensorMQ: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     float _rl_value = 1.0;
diff --git a/NodeManager.ino b/NodeManager.ino
index c219ac7..942d8da 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -48,7 +48,8 @@ NodeManager node;
 //SensorBMP280 bmp280(node);
 //SensorSonoff sonoff(node);
 //SensorHCSR04 hcsr04(node,4);
-SensorMCP9808 mcp9808(node);
+//SensorMCP9808 mcp9808(node);
+SensorMQ mq(node,A0);
 
 
 
diff --git a/config.h b/config.h
index 8d9e54c..d1a91e1 100755
--- a/config.h
+++ b/config.h
@@ -148,9 +148,9 @@
 // Enable this module to use one of the following sensors: SensorHCSR04
 #define MODULE_HCSR04 0
 // Enable this module to use one of the following sensors: SensorMCP9808
-#define MODULE_MCP9808 1
-// Enable this module to use one of the following sensors: SENSOR_MQ
-#define MODULE_MQ 0
+#define MODULE_MCP9808 0
+// Enable this module to use one of the following sensors: SensorMQ
+#define MODULE_MQ 1
 // Enable this module to use one of the following sensors: SENSOR_MHZ19
 #define MODULE_MHZ19 0
 // Enable this module to use one of the following sensors: SENSOR_AM2320    

From 89af5e8a7a0fefec876abb5125472fbea39c1aa3 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 18:38:25 +0100
Subject: [PATCH 42/51] Migrated SensorMHZ19

---
 NodeManager.cpp | 74 +++++++++++++++++++------------------------------
 NodeManager.h   |  7 ++---
 NodeManager.ino |  4 +--
 config.h        |  6 ++--
 4 files changed, 35 insertions(+), 56 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 1dc447d..83840d2 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -2723,21 +2723,16 @@ int SensorMQ::_MQGetPercentage(float rs_ro_ratio, float *pcurve) {
 */
 #if MODULE_MHZ19 == 1
 // contructor
-SensorMHZ19::SensorMHZ19(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
-  // set presentation, type and value type
-  setPresentation(S_AIR_QUALITY);
-  setType(V_LEVEL);
-  setRxTx(pin, pin+1);
-}
-
-void SensorMHZ19::setRxTx(int rxpin, int txpin) {
-  _rx_pin = rxpin;
-  _tx_pin = txpin;
+SensorMHZ19::SensorMHZ19(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "MHZ19";
+  _rx_pin = pin;
+  _tx_pin = pin+1;
 }
 
-
 // what to do during before
 void SensorMHZ19::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
 }
 
 // what to do during setup
@@ -2745,36 +2740,46 @@ void SensorMHZ19::onSetup() {
   _ser = new SoftwareSerial(_rx_pin, _tx_pin);
   _ser->begin(9600);
   delay(2000);
-  while (_ser->read()!=-1) {};  // clear CO2 buffer.
+  // clear CO2 buffer
+  while (_ser->read()!=-1) {};  
 }
 
 // what to do during loop
 void SensorMHZ19::onLoop(Child* child) {
   // Read the ppm value
-  int co2ppm = readCO2(); // This is there the function gets called that talks to the Co2 sensor.
+  int co2ppm = _readCO2(); 
   #if DEBUG == 1
-    Serial.print(F("CO2 I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" ppm="));
     Serial.println(co2ppm);
   #endif
   // store the value
-  _value_int = co2ppm;
+  ((ChildInt*)child)->setValueInt(co2ppm);
+}
+
+
+// what to do as the main task when receiving a message
+void SensorMHZ19::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorMHZ19::onInterrupt() {
 }
 
 // Read out the CO2 data
-int SensorMHZ19::readCO2() {
+int SensorMHZ19::_readCO2() {
   while (_ser->read() != -1) {};  //clear serial buffer
-
   unsigned char response[9]; // for answer
   byte cmd[9] = {0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79};
-
   // Command to ask for data.
   _ser->write(cmd, 9); //request PPM CO2
-
   // Then for 1 second listen for 9 bytes of data.
   _ser->readBytes(response, 9);
-
   #if DEBUG == 1
   for (int i=0; i<9; i++) {
     Serial.print(response[i], HEX);
@@ -2782,43 +2787,20 @@ int SensorMHZ19::readCO2() {
   }
   Serial.println(F("END"));
   #endif
-
   if (response[0] != 0xFF) {
-    Serial.println(F("Wrong starting byte from co2 sensor! (should be FF)"));
+    Serial.println(F("ERR byte"));
     return -1;
   }
-
   if (response[1] != 0x86) {
-    Serial.println(F("Wrong command from co2 sensor! (should be 86)"));
+    Serial.println(F("ERR command"));
     return -1;
   }
-
   int responseHigh = (int) response[2];
   int responseLow = (int) response[3];
   int ppm = (256 * responseHigh) + responseLow;
-  
   return ppm;
 }
 
-
-// what to do as the main task when receiving a message
-void SensorMHZ19::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorMHZ19::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
-}
-
-// what to do when receiving an interrupt
-void SensorMHZ19::onInterrupt() {
-}
-
 #endif
 
 /*
diff --git a/NodeManager.h b/NodeManager.h
index c53e878..f4f6505 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1149,18 +1149,15 @@ class SensorMQ: public Sensor {
 #if MODULE_MHZ19 == 1
 class SensorMHZ19: public Sensor {
   public:
-    SensorMHZ19(NodeManager* node_manager, int child_id, int pin);
-    // set the pins for RX and TX of the SoftwareSerial (default: Rx=6, Tx=7)
-    void setRxTx(int rxpin, int txpin);
-    int readCO2();
+    SensorMHZ19(const NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
+    int _readCO2();
     SoftwareSerial* _ser;
     int _tx_pin = 6;
     int _rx_pin = 7;
diff --git a/NodeManager.ino b/NodeManager.ino
index 942d8da..ff85630 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -49,8 +49,8 @@ NodeManager node;
 //SensorSonoff sonoff(node);
 //SensorHCSR04 hcsr04(node,4);
 //SensorMCP9808 mcp9808(node);
-SensorMQ mq(node,A0);
-
+//SensorMQ mq(node,A0);
+SensorMHZ19 mhz19(node,6);
 
 
 
diff --git a/config.h b/config.h
index d1a91e1..392c681 100755
--- a/config.h
+++ b/config.h
@@ -150,9 +150,9 @@
 // Enable this module to use one of the following sensors: SensorMCP9808
 #define MODULE_MCP9808 0
 // Enable this module to use one of the following sensors: SensorMQ
-#define MODULE_MQ 1
-// Enable this module to use one of the following sensors: SENSOR_MHZ19
-#define MODULE_MHZ19 0
+#define MODULE_MQ 0
+// Enable this module to use one of the following sensors: SensorMHZ19
+#define MODULE_MHZ19 1
 // Enable this module to use one of the following sensors: SENSOR_AM2320    
 #define MODULE_AM2320 0
 // Enable this module to use one of the following sensors: SENSOR_TSL2561    

From 0b4b9cce64b7e33799dc01accc5a0e96f2c44d51 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 18:57:47 +0100
Subject: [PATCH 43/51] Migrated SensorAM2320 SensorTSL2561

---
 NodeManager.cpp | 208 +++++++++++++++++++++++++-----------------------
 NodeManager.h   |  13 ++-
 NodeManager.ino |   4 +-
 config.h        |   8 +-
 4 files changed, 122 insertions(+), 111 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 83840d2..a891343 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -257,6 +257,11 @@ void ChildInt::setValueInt(int value) {
   _value = (int) (_total / _samples);
 }
 
+// return the value
+int ChildInt::getValueInt() {
+  return _value;
+}
+
 // send the value back to the controller
 void ChildInt::sendValue() {
   if (_samples == 0) return;
@@ -286,6 +291,11 @@ void ChildFloat::setValueFloat(float value) {
   _value = _total / _samples;
 }
 
+// return the value
+float ChildFloat::getValueFloat() {
+  return _value;
+}
+
 // send the value back to the controller
 void ChildFloat::sendValue() {
   if (_samples == 0) return;
@@ -315,6 +325,11 @@ void ChildDouble::setValueDouble(double value) {
   _value = _total / _samples;
 }
 
+// return the value
+double ChildDouble::getValueDouble() {
+  return _value;
+}
+
 // send the value back to the controller
 void ChildDouble::sendValue() {
   if (_samples == 0) return;
@@ -342,6 +357,11 @@ void ChildString::setValueString(char* value) {
   _value = value;
 }
 
+// return the value
+char* ChildString::getValueString() {
+  return _value;
+}
+
 // send the value back to the controller
 void ChildString::sendValue() {
   _sensor->_node->sendMessage(child_id,type,_value);
@@ -924,7 +944,18 @@ void SensorConfiguration::onReceive(MyMessage* message) {
         }
       }
       #endif
-      
+      #if MODULE_TSL2561 == 1
+      if (strcmp(sensor->getName(),"TSL2561") == 0) {
+        SensorTSL2561* custom_sensor = (SensorTSL2561*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setGain(request.getValueInt()); break;
+          case 102: custom_sensor->setTiming(request.getValueInt()); break;
+          case 103: custom_sensor->setSpectrum(request.getValueInt()); break;
+          case 104: custom_sensor->setAddress(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif      
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -2808,76 +2839,61 @@ int SensorMHZ19::_readCO2() {
 */
 #if MODULE_AM2320 == 1
 // constructor
-SensorAM2320::SensorAM2320(NodeManager* node_manager, int child_id, AM2320* th, int sensor_type): Sensor(node_manager, child_id,A2) {
-  _th = th;
-  _sensor_type = sensor_type;
-  if (_sensor_type == SensorAM2320::TEMPERATURE) {
-    // temperature sensor
-    setPresentation(S_TEMP);
-    setType(V_TEMP);
-    setValueType(TYPE_FLOAT);
-  }
-  else if (_sensor_type == SensorAM2320::HUMIDITY) {
-    // humidity sensor
-    setPresentation(S_HUM);
-    setType(V_HUM);
-    setValueType(TYPE_FLOAT);
-  }
+SensorAM2320::SensorAM2320(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "AM2320";
 }
 
 // what do to during before
 void SensorAM2320::onBefore() {
-
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
 }
 
 // what do to during setup
 void SensorAM2320::onSetup() {
+  _th = new AM2320();
 }
 
 // what do to during loop
 void SensorAM2320::onLoop(Child* child) {
-  switch(_th->Read()) {
-    case 0:
-      // temperature sensor
-      if (_sensor_type == SensorAM2320::TEMPERATURE) {
-        // read the temperature
-        float temperature = _th->t;
-        #if DEBUG == 1
-          Serial.print(F("AM2320 I="));
-          Serial.print(_child_id);
-          Serial.print(F(" T="));
-          Serial.println(temperature);
-        #endif
-        // store the value
-        _value_float = temperature;
-      }
-      // humidity sensor
-      else if (_sensor_type == SensorAM2320::HUMIDITY) {
-        // read humidity
-        float humidity = _th->h;
-        if (isnan(humidity)) return;
-          #if DEBUG == 1
-            Serial.print(F("AM2320 I="));
-            Serial.print(_child_id);
-            Serial.print(F(" H="));
-            Serial.println(humidity);
-          #endif
-          // store the value
-          _value_float = humidity;
-        }
-        break;
-      case 1: Serial.println(F("AM2320 offline")); break;
-      case 2: Serial.println(F("AM2320 CRC failed")); break;
-    }
+  // read data from the sensor
+  int status = _th->Read();
+  if (status != 0) return;
+  // temperature sensor
+  if (child->type == V_TEMP) {
+    float temperature = _th->t;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  }
+  // Humidity Sensor
+  else if (child->type == V_HUM) {
+    // read humidity
+    float humidity = _th->h;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(humidity);
+    #endif
+    // store the value
+    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+  }
 }
 
 // what do to as the main task when receiving a message
-void SensorAM2320::onReceive(const MyMessage & message) {
-  onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorAM2320::onProcess(Request & request) {
+void SensorAM2320::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
@@ -2890,9 +2906,8 @@ void SensorAM2320::onInterrupt() {
 */
 #if MODULE_TSL2561 == 1
 // contructor
-SensorTSL2561::SensorTSL2561(NodeManager* node_manager, int child_id): Sensor(node_manager, child_id,A2) {
-  setPresentation(S_LIGHT_LEVEL);
-  setType(V_LEVEL);
+SensorTSL2561::SensorTSL2561(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "TSL2561";
 }
 
 // setter/getter
@@ -2911,6 +2926,12 @@ void SensorTSL2561::setAddress(int value) {
 
 // what do to during before
 void SensorTSL2561::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
+}
+
+// what do to during setup
+void SensorTSL2561::onSetup() {
    switch (_tsl_address) {
     case SensorTSL2561::ADDR_FLOAT:
       _tsl = new TSL2561(TSL2561_ADDR_FLOAT);
@@ -2922,11 +2943,7 @@ void SensorTSL2561::onBefore() {
       _tsl = new TSL2561(TSL2561_ADDR_HIGH);
       break;   
   }
-}
-
-// what do to during setup
-void SensorTSL2561::onSetup() {
-   if (_tsl->begin()) {
+  if (_tsl->begin()) {
     switch (_tsl_gain) {
       case SensorTSL2561::GAIN_0X:
         _tsl->setGain(TSL2561_GAIN_0X);
@@ -2948,7 +2965,9 @@ void SensorTSL2561::onSetup() {
     }
   }
   else {
-    Serial.println(F("TSL2561 offline"));
+    #if DEBUG == 1
+      Serial.println(F("ERROR"));
+    #endif
   } 
 }
 
@@ -2957,13 +2976,13 @@ void SensorTSL2561::onLoop(Child* child) {
   // request the light level
    switch (_tsl_spectrum) {
     case SensorTSL2561::VISIBLE:
-      _value_int = _tsl->getLuminosity(TSL2561_VISIBLE); 
+      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_VISIBLE));
       break; 
     case SensorTSL2561::FULLSPECTRUM:
-      _value_int = _tsl->getLuminosity(TSL2561_FULLSPECTRUM); 
+      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_FULLSPECTRUM));
       break; 
     case SensorTSL2561::INFRARED:
-      _value_int = _tsl->getLuminosity(TSL2561_INFRARED); 
+      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_INFRARED));
       break; 
     case SensorTSL2561::FULL:
       // request the full light level
@@ -2971,47 +2990,38 @@ void SensorTSL2561::onLoop(Child* child) {
       uint16_t ir, full;
       ir = lum >> 16;
       full = lum & 0xFFFF;
-      _value_int = _tsl->calculateLux(full, ir);
-  #if DEBUG == 1
-      Serial.print(F("TSL I="));
-      Serial.print(_child_id);
-      Serial.print(F(" LUX="));
-      Serial.print(_value_int);
-      Serial.print(F(" IR="));
-      Serial.print(ir);
-      Serial.print(F(" FULL="));
-      Serial.print(full);
-      Serial.print(F(" VIS="));
-      Serial.println(full-ir);
-   #endif
+      ((ChildInt*)child)->setValueInt(_tsl->calculateLux(full, ir));
+      #if DEBUG == 1
+        Serial.print(_name);
+        Serial.print(F(" I="));
+        Serial.print(child->child_id);
+        Serial.print(F(" LUX="));
+        Serial.print(((ChildInt*)child)->getValueInt());
+        Serial.print(F(" IR="));
+        Serial.print(ir);
+        Serial.print(F(" FULL="));
+        Serial.print(full);
+        Serial.print(F(" VIS="));
+        Serial.println(full-ir);
+      #endif
       break; 
   }
   #if DEBUG == 1
     if (_tsl_spectrum < 3) {
-      Serial.print(F("TSL I="));
-      Serial.print(_child_id);
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
       Serial.print(F(" L="));
-      Serial.println(_value_int);
+      Serial.println(((ChildInt*)child)->getValueInt());
     }
   #endif
 }
 
 // what do to as the main task when receiving a message
-void SensorTSL2561::onReceive(const MyMessage & message) {
-  onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorTSL2561::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 101: setGain(request.getValueInt()); break;
-    case 102: setTiming(request.getValueInt()); break;
-    case 103: setSpectrum(request.getValueInt()); break;
-    case 104: setAddress(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorTSL2561::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
diff --git a/NodeManager.h b/NodeManager.h
index f4f6505..b029748 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -341,6 +341,7 @@ class ChildInt: public Child {
   public:
     ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueInt(int value);
+    int getValueInt();
     void sendValue();
     bool isNewValue();
   private:
@@ -353,6 +354,7 @@ class ChildFloat: public Child {
   public:
     ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueFloat(float value);
+    float getValueFloat();
     void sendValue();
     bool isNewValue();
   private:
@@ -365,6 +367,7 @@ class ChildDouble: public Child {
   public:
     ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueDouble(double value);
+    double getValueDouble();
     void sendValue();
     bool isNewValue();
   private:
@@ -377,6 +380,7 @@ class ChildString: public Child {
   public:
     ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description);
     void setValueString(char* value);
+    char* getValueString();
     void sendValue();
     bool isNewValue();
   private:
@@ -1170,20 +1174,15 @@ class SensorMHZ19: public Sensor {
 #if MODULE_AM2320 == 1
 class SensorAM2320: public Sensor {
   public:
-    SensorAM2320(NodeManager* node_manager, int child_id, AM2320* th, int sensor_type);
+    SensorAM2320(const NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
-    // constants
-    const static int TEMPERATURE = 0;
-    const static int HUMIDITY = 1;
   protected:
     AM2320* _th;
-    int _sensor_type = 0;
 };
 #endif
 
@@ -1193,7 +1192,7 @@ class SensorAM2320: public Sensor {
 #if MODULE_TSL2561 == 1
 class SensorTSL2561: public Sensor {
   public:
-    SensorTSL2561(NodeManager* node_manager, int child_id);
+    SensorTSL2561(const NodeManager& node_manager);
     // [101] set the gain, possible values are SensorTSL2561::GAIN_0X (0), SensorTSL2561::GAIN_16X (1) (default 16x)
     void setGain(int value);
     // [102] set the timing, possible values are SensorTSL2561::INTEGRATIONTIME_13MS (0), SensorTSL2561::INTEGRATIONTIME_101MS (1), SensorTSL2561::INTEGRATIONTIME_402MS (2) (default: 13ms)
diff --git a/NodeManager.ino b/NodeManager.ino
index ff85630..5ff92d2 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -50,7 +50,9 @@ NodeManager node;
 //SensorHCSR04 hcsr04(node,4);
 //SensorMCP9808 mcp9808(node);
 //SensorMQ mq(node,A0);
-SensorMHZ19 mhz19(node,6);
+//SensorMHZ19 mhz19(node,6);
+//SensorAM2320 am2320(node);
+SensorTSL2561 tsl2561(node);
 
 
 
diff --git a/config.h b/config.h
index 392c681..bcedb5b 100755
--- a/config.h
+++ b/config.h
@@ -152,11 +152,11 @@
 // Enable this module to use one of the following sensors: SensorMQ
 #define MODULE_MQ 0
 // Enable this module to use one of the following sensors: SensorMHZ19
-#define MODULE_MHZ19 1
-// Enable this module to use one of the following sensors: SENSOR_AM2320    
+#define MODULE_MHZ19 0
+// Enable this module to use one of the following sensors: SensorAM2320    
 #define MODULE_AM2320 0
-// Enable this module to use one of the following sensors: SENSOR_TSL2561    
-#define MODULE_TSL2561 0
+// Enable this module to use one of the following sensors: SensorTSL2561    
+#define MODULE_TSL2561 1
 // Enable this module to use one of the following sensors: SENSOR_PT100
 #define MODULE_PT100 0
 // Enable this module to use one of the following sensors: SENSOR_DIMMER

From b4e189daeeb92c1ec2d5ef4cf6fb169e4dced84c Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 19:06:25 +0100
Subject: [PATCH 44/51] Migrated SensorPT100

---
 NodeManager.cpp | 50 +++++++++++++++++++++++++------------------------
 NodeManager.h   |  3 +--
 NodeManager.ino |  3 ++-
 config.h        |  6 +++---
 4 files changed, 32 insertions(+), 30 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index a891343..02ce952 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -955,7 +955,16 @@ void SensorConfiguration::onReceive(MyMessage* message) {
           default: return;
         }
       }
-      #endif      
+      #endif
+      #if MODULE_PT100 == 1
+      if (strcmp(sensor->getName(),"PT100") == 0) {
+        SensorPT100* custom_sensor = (SensorPT100*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setVoltageRef(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      #endif
     }
   }
   _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
@@ -3034,11 +3043,8 @@ void SensorTSL2561::onInterrupt() {
 */
 #if MODULE_PT100 == 1
 // contructor
-SensorPT100::SensorPT100(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
-  // set presentation, type and value type
-  setPresentation(S_TEMP);
-  setType(V_TEMP);
-  setValueType(TYPE_FLOAT);
+SensorPT100::SensorPT100(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "PT100";
 }
 
 // setter/getter
@@ -3048,13 +3054,16 @@ void SensorPT100::setVoltageRef(float value) {
 
 // what to do during before
 void SensorPT100::onBefore() {
-  _PT100 = new DFRobotHighTemperature(_voltageRef); 
-  // set the pin as input
-  pinMode(_pin, INPUT);
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
 }
 
 // what to do during setup
 void SensorPT100::onSetup() {
+  _PT100 = new DFRobotHighTemperature(_voltageRef); 
+  // set the pin as input
+  pinMode(_pin, INPUT);
+
 }
 
 // what to do during loop
@@ -3062,28 +3071,21 @@ void SensorPT100::onLoop(Child* child) {
   // read the PT100 sensor
   int temperature = _PT100->readTemperature(_pin);  
   #if DEBUG == 1
-    Serial.print(F("PT100 I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" T="));
     Serial.println(temperature);
   #endif
   // store the value
-  _value_float = temperature;
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
 }
 
 // what to do as the main task when receiving a message
-void SensorPT100::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) onLoop(NULL);
-}
-
-// what to do when receiving a remote message
-void SensorPT100::onProcess(Request & request) {
-   int function = request.getFunction();
-  switch(function) {
-    case 101: setVoltageRef(request.getValueFloat()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
+void SensorPT100::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
 // what to do when receiving an interrupt
diff --git a/NodeManager.h b/NodeManager.h
index b029748..121ff85 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1236,7 +1236,7 @@ class SensorTSL2561: public Sensor {
 #if MODULE_PT100 == 1
 class SensorPT100: public Sensor {
   public:
-    SensorPT100(NodeManager* node_manager, int child_id, int pin);
+    SensorPT100(const NodeManager& node_manager, int pin);
     // [101] set the voltageRef used to compare with analog measures
     void setVoltageRef(float value);
     // define what to do at each stage of the sketch
@@ -1244,7 +1244,6 @@ class SensorPT100: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
     DFRobotHighTemperature* _PT100;
diff --git a/NodeManager.ino b/NodeManager.ino
index 5ff92d2..86e87cb 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -52,7 +52,8 @@ NodeManager node;
 //SensorMQ mq(node,A0);
 //SensorMHZ19 mhz19(node,6);
 //SensorAM2320 am2320(node);
-SensorTSL2561 tsl2561(node);
+//SensorTSL2561 tsl2561(node);
+SensorPT100 pt100(node,4);
 
 
 
diff --git a/config.h b/config.h
index bcedb5b..aa22dcc 100755
--- a/config.h
+++ b/config.h
@@ -156,9 +156,9 @@
 // Enable this module to use one of the following sensors: SensorAM2320    
 #define MODULE_AM2320 0
 // Enable this module to use one of the following sensors: SensorTSL2561    
-#define MODULE_TSL2561 1
-// Enable this module to use one of the following sensors: SENSOR_PT100
-#define MODULE_PT100 0
+#define MODULE_TSL2561 0
+// Enable this module to use one of the following sensors: SensorPT100
+#define MODULE_PT100 1
 // Enable this module to use one of the following sensors: SENSOR_DIMMER
 #define MODULE_DIMMER 0
 // Enable this module to use one of the following sensors: SENSOR_RAIN_GAUGE, SENSOR_POWER_METER, SENSOR_WATER_METER

From a7e641b2a4f2b1a76d1140abb8695b46dff96c0f Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 19:12:51 +0100
Subject: [PATCH 45/51] Migrated SensorDimmer

---
 NodeManager.cpp | 45 ++++++++++++++++++---------------------------
 NodeManager.h   | 19 +++++++++----------
 NodeManager.ino |  3 ++-
 config.h        |  6 +++---
 4 files changed, 32 insertions(+), 41 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 02ce952..1bae7bf 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -3099,10 +3099,8 @@ void SensorPT100::onInterrupt() {
 
 #if MODULE_DIMMER == 1
 // contructor
-SensorDimmer::SensorDimmer(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager, child_id, pin) {
-  // set presentation, type and value type
-  setPresentation(S_DIMMER);
-  setType(V_PERCENTAGE);
+SensorDimmer::SensorDimmer(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DIMMER";
 }
 
 // setter/getter
@@ -3118,11 +3116,13 @@ void SensorDimmer::setStepDuration(int value) {
 
 // what to do during before
 void SensorDimmer::onBefore() {
-  pinMode(_pin, OUTPUT);
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_DIMMER,V_PERCENTAGE);
 }
 
 // what to do during setup
 void SensorDimmer::onSetup() {
+  pinMode(_pin, OUTPUT);
 }
 
 // what to do during loop
@@ -3130,42 +3130,33 @@ void SensorDimmer::onLoop(Child* child) {
 }
 
 // what to do as the main task when receiving a message
-void SensorDimmer::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_SET) {
-    int percentage = message.getInt();
+void SensorDimmer::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_SET && message->type == child->type) {
+    int percentage = message->getInt();
     // normalize the provided percentage
     if (percentage < 0) percentage = 0;
     if (percentage > 100) percentage = 100;
-    fadeTo(percentage);
-    _value_int = percentage;
+    _fadeTo(child,percentage);
+    ((ChildInt*)child)->setValueInt(_percentage);
   }
-  if (message.getCommand() == C_REQ) {
+  if (message->getCommand() == C_REQ) {
     // return the current status
-    _value_int = _percentage;
+    ((ChildInt*)child)->setValueInt(_percentage);
   }
 }
 
-// what to do when receiving a remote message
-void SensorDimmer::onProcess(Request & request) {
-   int function = request.getFunction();
-  switch(function) {
-    case 101: setEasing(request.getValueInt()); break;
-    case 102: setDuration(request.getValueInt()); break;
-    case 103: setStepDuration(request.getValueInt()); break;
-    default: return;
-  }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
-}
-
 // what to do when receiving an interrupt
 void SensorDimmer::onInterrupt() {
 }
 
 // fade to the provided value
-void SensorDimmer::fadeTo(int target_percentage) {
+void SensorDimmer::_fadeTo(Child* child, int target_percentage) {
   #if DEBUG == 1
-    Serial.print(F("DIM I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" V="));
     Serial.println(target_percentage);
   #endif
diff --git a/NodeManager.h b/NodeManager.h
index 121ff85..77e073e 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1257,29 +1257,28 @@ class SensorPT100: public Sensor {
 #if MODULE_DIMMER == 1
 class SensorDimmer: public Sensor {
   public:
-    SensorDimmer(NodeManager* node_manager, int child_id, int pin);
+    SensorDimmer(const NodeManager& node_manager, int pin);
     // [101] set the effect to use for a smooth transition, can be one of SensorDimmer::EASE_LINEAR, SensorDimmer::EASE_INSINE, SensorDimmer::EASE_OUTSINE, SensorDimmer::EASE_INOUTSINE (default: EASE_LINEAR)
     void setEasing(int value);
     // [102] the duration of entire the transition in seconds (default: 1)
     void setDuration(int value);
     // [103] the duration of a single step of the transition in milliseconds (default: 100)
     void setStepDuration(int value);
-    // fade the output from the current value to the target provided in the range 0-100
-    void fadeTo(int value);
-    enum easing {
-      EASE_LINEAR,
-      EASE_INSINE,
-      EASE_OUTSINE,
-      EASE_INOUTSINE,
-    };
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onProcess(Request & request);
     void onInterrupt();
   protected:
+    // fade the output from the current value to the target provided in the range 0-100
+    void _fadeTo(Child* child, int value);
+    enum _easing_list {
+      EASE_LINEAR,
+      EASE_INSINE,
+      EASE_OUTSINE,
+      EASE_INOUTSINE,
+    };
     int _percentage = 0;
     int _easing = EASE_LINEAR;
     int _duration = 1000;
diff --git a/NodeManager.ino b/NodeManager.ino
index 86e87cb..055dab5 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -53,7 +53,8 @@ NodeManager node;
 //SensorMHZ19 mhz19(node,6);
 //SensorAM2320 am2320(node);
 //SensorTSL2561 tsl2561(node);
-SensorPT100 pt100(node,4);
+//SensorPT100 pt100(node,4);
+SensorDimmer dimmer(node,A0);
 
 
 
diff --git a/config.h b/config.h
index aa22dcc..c5a868c 100755
--- a/config.h
+++ b/config.h
@@ -158,9 +158,9 @@
 // Enable this module to use one of the following sensors: SensorTSL2561    
 #define MODULE_TSL2561 0
 // Enable this module to use one of the following sensors: SensorPT100
-#define MODULE_PT100 1
-// Enable this module to use one of the following sensors: SENSOR_DIMMER
-#define MODULE_DIMMER 0
+#define MODULE_PT100 0
+// Enable this module to use one of the following sensors: SensorDimmer
+#define MODULE_DIMMER 1
 // Enable this module to use one of the following sensors: SENSOR_RAIN_GAUGE, SENSOR_POWER_METER, SENSOR_WATER_METER
 #define MODULE_PULSE_METER 0
 

From 65db33758ed78d839ef7570c7f10e467dea6ddfb Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sat, 16 Dec 2017 19:28:51 +0100
Subject: [PATCH 46/51] Migrated SensorRainGauge SensorPowerMeter
 SensorWaterMeter

---
 NodeManager.cpp | 91 +++++++++++++++++++++++++++++--------------------
 NodeManager.h   | 20 ++++++++---
 NodeManager.ino |  5 ++-
 config.h        |  6 ++--
 4 files changed, 76 insertions(+), 46 deletions(-)

diff --git a/NodeManager.cpp b/NodeManager.cpp
index 1bae7bf..979c417 100644
--- a/NodeManager.cpp
+++ b/NodeManager.cpp
@@ -3190,9 +3190,8 @@ float SensorDimmer::_getEasing(float t, float b, float c, float d) {
 */
 #if MODULE_PULSE_METER == 1
 // contructor
-SensorPulseMeter::SensorPulseMeter(NodeManager* node_manager, int child_id, int pin): Sensor(node_manager,child_id, pin) {
-  // set presentation, type and value type
-  setValueType(TYPE_FLOAT);
+SensorPulseMeter::SensorPulseMeter(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "PULSE";
 }
 
 // setter/getter
@@ -3208,12 +3207,14 @@ void SensorPulseMeter::setInterruptMode(int value) {
 
 // what to do during before
 void SensorPulseMeter::onBefore() {
-  // configure the interrupt pin so onInterrupt() will be called on tip
-  setInterrupt(_pin,_interrupt_mode,_initial_value);
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
 }
 
 // what to do during setup
 void SensorPulseMeter::onSetup() {
+  // configure the interrupt pin so onInterrupt() will be called on tip
+  setInterrupt(_pin,_interrupt_mode,_initial_value);
 }
 
 // what to do during loop
@@ -3221,33 +3222,26 @@ void SensorPulseMeter::onLoop(Child* child) {
   // do not report anything if called by an interrupt
   if (_node->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
-  _reportTotal();
+  _reportTotal(child);
   #if DEBUG == 1
-    Serial.print(F("PLS I="));
-    Serial.print(_child_id);
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
     Serial.print(F(" T="));
-    Serial.println(_value_float);
+    Serial.println(((ChildFloat*)child)->getValueFloat());
   #endif
   // reset the counter
   _count = 0;
 }
 
 // what to do as the main task when receiving a message
-void SensorPulseMeter::onReceive(const MyMessage & message) {
-  if (message.getCommand() == C_REQ) {
+void SensorPulseMeter::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) {
     // report the total the last period
-    _reportTotal();
-  }
-}
-
-// what to do when receiving a remote message
-void SensorPulseMeter::onProcess(Request & request) {
-  int function = request.getFunction();
-  switch(function) {
-    case 102: setPulseFactor(request.getValueFloat()); break;
-    default: return;
+    _reportTotal(child);
   }
-  _node->sendMessage(request.getRecipientChildId(),V_CUSTOM,function);
 }
 
 // what to do when receiving an interrupt
@@ -3255,23 +3249,28 @@ void SensorPulseMeter::onInterrupt() {
   // increase the counter
   _count++;
   #if DEBUG == 1
-    Serial.println(F("PLS+"));
+    Serial.print(_name);
+    Serial.println(F("+"));
   #endif
 }
 
 // return the total based on the pulses counted
-void SensorPulseMeter::_reportTotal() {
-  if (_value_type == TYPE_DOUBLE) _value_double = _count / _pulse_factor;
-  else _value_float = _count / _pulse_factor;
+void SensorPulseMeter::_reportTotal(Child* child) {
+  ((ChildFloat*)child)->setValueFloat(_count / _pulse_factor);
 }
 
 /*
    SensorRainGauge
 */
 // contructor
-SensorRainGauge::SensorRainGauge(NodeManager* node_manager, int child_id, int pin): SensorPulseMeter(node_manager,child_id, pin) {
-  setPresentation(S_RAIN);
-  setType(V_RAIN);
+SensorRainGauge::SensorRainGauge(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "RAING";
+}
+
+// what to do during before
+void SensorRainGauge::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_RAIN,V_RAIN);
   setPulseFactor(9.09);
 }
 
@@ -3279,23 +3278,41 @@ SensorRainGauge::SensorRainGauge(NodeManager* node_manager, int child_id, int pi
    SensorPowerMeter
 */
 // contructor
-SensorPowerMeter::SensorPowerMeter(NodeManager* node_manager, int child_id, int pin): SensorPulseMeter(node_manager,child_id, pin) {
-  setPresentation(S_POWER);
-  setType(V_KWH);
-  setValueType(TYPE_DOUBLE);
+SensorPowerMeter::SensorPowerMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "POWER";
+}
+
+// what to do during before
+void SensorPowerMeter::onBefore() {
+  // register the child
+  new ChildDouble(this,_node->getAvailableChildId(),S_POWER,V_KWH);
   setPulseFactor(1000);
 }
 
+// return the total based on the pulses counted
+void SensorPowerMeter::_reportTotal(Child* child) {
+  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
+}
+
 /*
    SensorWaterMeter
 */
 // contructor
-SensorWaterMeter::SensorWaterMeter(NodeManager* node_manager, int child_id, int pin): SensorPulseMeter(node_manager,child_id, pin) {
-  setPresentation(S_WATER);
-  setType(V_VOLUME);
-  setValueType(TYPE_DOUBLE);
+SensorWaterMeter::SensorWaterMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "WATER";
+}
+
+// what to do during before
+void SensorWaterMeter::onBefore() {
+  // register the child
+  new ChildDouble(this,_node->getAvailableChildId(),S_WATER,V_VOLUME);
   setPulseFactor(1000);
 }
+
+// return the total based on the pulses counted
+void SensorWaterMeter::_reportTotal(Child* child) {
+  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
+}
 #endif
 
 /*******************************************
diff --git a/NodeManager.h b/NodeManager.h
index 77e073e..463e036 100644
--- a/NodeManager.h
+++ b/NodeManager.h
@@ -1293,7 +1293,7 @@ class SensorDimmer: public Sensor {
 #if MODULE_PULSE_METER == 1
 class SensorPulseMeter: public Sensor {
   public:
-    SensorPulseMeter(NodeManager* node_manager, int child_id, int pin);
+    SensorPulseMeter(const NodeManager& node_manager, int pin);
     // [102] set how many pulses for each unit (e.g. 1000 pulses for 1 kwh of power, 9 pulses for 1 mm of rain, etc.)
     void setPulseFactor(float value);
     // set initial value - internal pull up (default: HIGH)
@@ -1312,7 +1312,7 @@ class SensorPulseMeter: public Sensor {
     float _pulse_factor;
     int _initial_value = HIGH;
     int _interrupt_mode = FALLING;
-    void _reportTotal();
+    virtual void _reportTotal(Child* child);
 };
 
 /*
@@ -1320,7 +1320,9 @@ class SensorPulseMeter: public Sensor {
 */
 class SensorRainGauge: public SensorPulseMeter {
   public:
-    SensorRainGauge(NodeManager* node_manager, int child_id, int pin);
+    SensorRainGauge(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
 };
 
 /*
@@ -1328,7 +1330,11 @@ class SensorRainGauge: public SensorPulseMeter {
 */
 class SensorPowerMeter: public SensorPulseMeter {
   public:
-    SensorPowerMeter(NodeManager* node_manager, int child_id, int pin);
+    SensorPowerMeter(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+  protected:
+    void _reportTotal(Child* child);
 };
 
 /*
@@ -1336,7 +1342,11 @@ class SensorPowerMeter: public SensorPulseMeter {
 */
 class SensorWaterMeter: public SensorPulseMeter {
   public:
-    SensorWaterMeter(NodeManager* node_manager, int child_id, int pin);
+    SensorWaterMeter(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+  protected:
+    void _reportTotal(Child* child);
 };
 #endif
 
diff --git a/NodeManager.ino b/NodeManager.ino
index 055dab5..9c8a588 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -54,7 +54,10 @@ NodeManager node;
 //SensorAM2320 am2320(node);
 //SensorTSL2561 tsl2561(node);
 //SensorPT100 pt100(node,4);
-SensorDimmer dimmer(node,A0);
+//SensorDimmer dimmer(node,A0);
+//SensorRainGauge rainGauge(node,3);
+//SensorPowerMeter powerMeter(node,3);
+SensorWaterMeter waterMeter(node,3);
 
 
 
diff --git a/config.h b/config.h
index c5a868c..53fda66 100755
--- a/config.h
+++ b/config.h
@@ -160,9 +160,9 @@
 // Enable this module to use one of the following sensors: SensorPT100
 #define MODULE_PT100 0
 // Enable this module to use one of the following sensors: SensorDimmer
-#define MODULE_DIMMER 1
-// Enable this module to use one of the following sensors: SENSOR_RAIN_GAUGE, SENSOR_POWER_METER, SENSOR_WATER_METER
-#define MODULE_PULSE_METER 0
+#define MODULE_DIMMER 0
+// Enable this module to use one of the following sensors: SensorRainGauge, SensorPowerMeter, SensorWaterMeter
+#define MODULE_PULSE_METER 1
 
 #endif
 

From cb47ad7bffb9534587fbdda15e3c08cfc0fdeb90 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 17 Dec 2017 15:28:09 +0100
Subject: [PATCH 47/51] Re-organized the files

---
 NodeManager.ino        |  259 ++-
 NodeManagerLibrary.h   | 1477 ++++++++++++++
 NodeManagerLibrary.ino | 4192 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 5880 insertions(+), 48 deletions(-)
 create mode 100644 NodeManagerLibrary.h
 create mode 100644 NodeManagerLibrary.ino

diff --git a/NodeManager.ino b/NodeManager.ino
index 9c8a588..d5fc701 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -1,27 +1,206 @@
-/*
-NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, speeding up the development cycle of your projects.
-NodeManager includes the following main components:
-- Sleep manager: allows managing automatically the complexity behind battery-powered sensors spending most of their time sleeping
-- Power manager: allows powering on your sensors only while the node is awake
-- Battery manager: provides common functionalities to read and report the battery level
-- Remote configuration: allows configuring remotely the node without the need to have physical access to it
-- Built-in personalities: for the most common sensors, provide embedded code so to allow their configuration with a single line 
-Documentation available on: https://github.com/mysensors/NodeManager
+/**
+ * The MySensors Arduino library handles the wireless radio link and protocol
+ * between your home built sensors/actuators and HA controller of choice.
+ * The sensors forms a self healing radio network with optional repeaters. Each
+ * repeater and gateway builds a routing tables in EEPROM which keeps track of the
+ * network topology allowing messages to be routed to nodes.
+ *
+ * Created by Henrik Ekblad <henrik.ekblad@mysensors.org>
+ * Copyright (C) 2013-2016 Sensnology AB
+ * Full contributor list: https://github.com/mysensors/Arduino/graphs/contributors
+ *
+ * Documentation: http://www.mysensors.org
+ * Support Forum: http://forum.mysensors.org
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ *******************************
+ *
+ * DESCRIPTION
+ *
+ * NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, 
+ * speeding up the development cycle of your projects.
+ * Documentation available on: https://github.com/mysensors/NodeManager
 */
  
-// load user settings
-#include "config.h"
-// include supporting libraries
-#ifdef MY_GATEWAY_ESP8266
-  #include <ESP8266WiFi.h>
-#endif
-// load MySensors library
-#include <MySensors.h>
-// load NodeManager library
-#include "NodeManager.h"
-
-// create a NodeManager instance
+#define SKETCH_NAME "NodeManager"
+#define SKETCH_VERSION "1.0"
+
+
+/**********************************
+ * MySensors node configuration
+ */
+
+// General settings
+#define MY_BAUD_RATE 9600
+//#define MY_DEBUG
+#define MY_NODE_ID 99
+//#define MY_SMART_SLEEP_WAIT_DURATION_MS 500
+#define MY_SPLASH_SCREEN_DISABLED
+
+// NRF24 radio settings
+#define MY_RADIO_NRF24
+//#define MY_RF24_ENABLE_ENCRYPTION
+//#define MY_RF24_CHANNEL 125
+//#define MY_RF24_PA_LEVEL RF24_PA_HIGH
+//#define MY_DEBUG_VERBOSE_RF24
+//#define MY_RF24_DATARATE RF24_250KBPS
+
+// RFM69 radio settings
+//#define MY_RADIO_RFM69
+//#define MY_RFM69_FREQUENCY RF69_868MHZ
+//#define MY_RFM69_FREQUENCY RFM69_868MHZ
+//#define MY_IS_RFM69HW
+//#define MY_RFM69_NEW_DRIVER
+//#define MY_RFM69_ENABLE_ENCRYPTION
+//#define MY_RFM69_NETWORKID 100
+//#define MY_DEBUG_VERBOSE_RFM69
+//#define MY_RF69_IRQ_PIN D1
+//#define MY_RF69_IRQ_NUM MY_RF69_IRQ_PIN
+//#define MY_RF69_SPI_CS D2
+//#define MY_RFM69_ATC_MODE_DISABLED
+
+// RS485 serial transport settings
+//#define MY_RS485
+//#define MY_RS485_BAUD_RATE 9600
+//#define MY_RS485_DE_PIN 2
+//#define MY_RS485_MAX_MESSAGE_LENGTH 40
+//#define MY_RS485_HWSERIAL Serial1
+
+// Message signing settings
+//#define MY_SIGNING_SOFT
+//#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7
+//#define MY_SIGNING_REQUEST_SIGNATURES
+//#define MY_SIGNING_ATSHA204
+
+// OTA Firmware update settings
+//#define MY_OTA_FIRMWARE_FEATURE
+//#define OTA_WAIT_PERIOD 300
+//#define FIRMWARE_MAX_REQUESTS 2
+//#define MY_OTA_RETRY 2
+
+/**********************************
+ * MySensors gateway configuration
+ */
+// Common gateway settings
+//#define MY_REPEATER_FEATURE
+
+// Serial gateway settings
+//#define MY_GATEWAY_SERIAL
+
+// Ethernet gateway settings
+//#define MY_GATEWAY_W5100
+
+// ESP8266 gateway settings
+//#define MY_GATEWAY_ESP8266
+//#define MY_ESP8266_SSID ""
+//#define MY_ESP8266_PASSWORD ""
+
+// Gateway networking settings
+//#define MY_IP_ADDRESS 192,168,178,87
+//#define MY_IP_GATEWAY_ADDRESS 192,168,178,1
+//#define MY_IP_SUBNET_ADDRESS 255,255,255,0
+//#define MY_PORT 5003
+//#define MY_GATEWAY_MAX_CLIENTS 2
+//#define MY_USE_UDP
+
+// Gateway MQTT settings
+//#define MY_GATEWAY_MQTT_CLIENT
+//#define MY_CONTROLLER_IP_ADDRESS 192, 168, 178, 68
+//#define MY_PORT 1883
+//#define MY_MQTT_USER "username"
+//#define MY_MQTT_PASSWORD "password"
+//#define MY_MQTT_CLIENT_ID "mysensors-1"
+//#define MY_MQTT_PUBLISH_TOPIC_PREFIX "mygateway1-out"
+//#define MY_MQTT_SUBSCRIBE_TOPIC_PREFIX "mygateway1-in"
+
+// Gateway inclusion mode
+//#define MY_INCLUSION_MODE_FEATURE
+//#define MY_INCLUSION_BUTTON_FEATURE
+//#define MY_INCLUSION_MODE_DURATION 60
+//#define MY_DEFAULT_LED_BLINK_PERIOD 300
+
+// Gateway Leds settings
+//#define MY_DEFAULT_ERR_LED_PIN 4
+//#define MY_DEFAULT_RX_LED_PIN  5
+//#define MY_DEFAULT_TX_LED_PIN  6
+
+/***********************************
+ * NodeManager configuration
+ */
+
+// if enabled, enable debug messages on serial port
+#define DEBUG 1
+
+// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SensorRain, SensorSoilMoisture
+#define MODULE_ANALOG_INPUT 0
+// Enable this module to use one of the following sensors: SensorThermistor
+#define MODULE_THERMISTOR 0
+// Enable this module to use one of the following sensors: SensorML8511
+#define MODULE_ML8511 0
+// Enable this module to use one of the following sensors: SensorACS712
+#define MODULE_ACS712 0
+// Enable this module to use one of the following sensors: SensorDigitalInput
+#define MODULE_DIGITAL_INPUT 0
+// Enable this module to use one of the following sensors: SensorDigitalOutput, SensorRelay, SensorLatchingRelay
+#define MODULE_DIGITAL_OUTPUT 0
+// Enable this module to use one of the following sensors: SensorDHT11, SensorDHT22
+#define MODULE_DHT 0
+// Enable this module to use one of the following sensors: SensorSHT21, SensorHTU21D
+#define MODULE_SHT21 0
+// Enable this module to use one of the following sensors: SensorSwitch, SensorDoor, SensorMotion
+#define MODULE_SWITCH 0
+// Enable this module to use one of the following sensors: SensorDs18b20
+#define MODULE_DS18B20 0
+// Enable this module to use one of the following sensors: SensorBH1750
+#define MODULE_BH1750 0
+// Enable this module to use one of the following sensors: SensorMLX90614
+#define MODULE_MLX90614 0
+// Enable this module to use one of the following sensors: SensorBME280
+#define MODULE_BME280 0
+// Enable this module to use one of the following sensors: SensorBMP085
+#define MODULE_BMP085 0
+// Enable this module to use one of the following sensors: SensorBMP280
+#define MODULE_BMP280 0
+// Enable this module to use one of the following sensors: SensorSonoff
+#define MODULE_SONOFF 0
+// Enable this module to use one of the following sensors: SensorHCSR04
+#define MODULE_HCSR04 0
+// Enable this module to use one of the following sensors: SensorMCP9808
+#define MODULE_MCP9808 0
+// Enable this module to use one of the following sensors: SensorMQ
+#define MODULE_MQ 0
+// Enable this module to use one of the following sensors: SensorMHZ19
+#define MODULE_MHZ19 0
+// Enable this module to use one of the following sensors: SensorAM2320    
+#define MODULE_AM2320 0
+// Enable this module to use one of the following sensors: SensorTSL2561    
+#define MODULE_TSL2561 0
+// Enable this module to use one of the following sensors: SensorPT100
+#define MODULE_PT100 0
+// Enable this module to use one of the following sensors: SensorDimmer
+#define MODULE_DIMMER 0
+// Enable this module to use one of the following sensors: SensorRainGauge, SensorPowerMeter, SensorWaterMeter
+#define MODULE_PULSE_METER 1
+
+/***********************************
+ * Load NodeManager Library
+ */
+ 
+#include "NodeManagerLibrary.h"
 NodeManager node;
+
+/***********************************
+ * Add here your sensors
+ */
+
+//SensorBattery battery(node);
+SensorConfiguration configuration(node);
+//SensorSignal signal(node);
+//PowerManager power(5,6);
+
 //SensorAnalogInput analog(node,A0);
 //SensorLDR ldr(node,A0);
 //SensorRain rain(node,A0);
@@ -59,45 +238,30 @@ NodeManager node;
 //SensorPowerMeter powerMeter(node,3);
 SensorWaterMeter waterMeter(node,3);
 
-
-
-
-//PowerManager power(5,6);
-//SensorBattery battery(node);
-SensorConfiguration configuration(node);
-//SensorSignal signal(node);
+/***********************************
+ * Main Sketch
+ */
 
 // before
 void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);
-//  battery.setReportIntervalSeconds(10);
+
+  /***********************************
+ * Configure your sensors below
+ */
+
   node.setReportIntervalSeconds(20);
+  //battery.setReportIntervalSeconds(10);
   //node.setSleepSeconds(20);
   
   //node.setPowerManager(power);
   //battery.setReportIntervalSeconds(10);
-//sht.children.get(1)->child_id = 5;
-//node.sensors.get(0)->setPin(5);
-//node.sensors.get(0)->children.get(0).child_id = 5;
+  //sht.children.get(1)->child_id = 5;
 
-
-
-  /*
-   * Register below your sensors
-  */
-  /*
-      pinMode(4, OUTPUT);
-    digitalWrite(4, HIGH);
-    pinMode(5, OUTPUT);
-    digitalWrite(5, LOW);
-    */
-  //node.setReportIntervalSeconds(20);
-  
-  
   
   /*
-   * Register above your sensors
+   * Configure your sensors above
   */
   node.before();
 }
@@ -131,4 +295,3 @@ void receiveTime(unsigned long ts) {
   // call NodeManager receiveTime routine
   node.receiveTime(ts);
 }
-
diff --git a/NodeManagerLibrary.h b/NodeManagerLibrary.h
new file mode 100644
index 0000000..454cdee
--- /dev/null
+++ b/NodeManagerLibrary.h
@@ -0,0 +1,1477 @@
+/*
+ * NodeManager Library
+ */
+ 
+#ifndef NodeManager_h
+#define NodeManager_h
+
+#include <Arduino.h>
+
+// define NodeManager version
+#define VERSION "1.7-dev"
+
+/***********************************
+   Constants
+*/
+// define board status
+#define AWAKE 0
+#define SLEEP 1
+
+// define time unit
+#define SECONDS 0
+#define MINUTES 1
+#define HOURS 2
+#define DAYS 3
+
+// define on/off
+#define OFF 0
+#define ON 1
+
+// define value type
+#define TYPE_INTEGER 0
+#define TYPE_FLOAT 1
+#define TYPE_STRING 2
+#define TYPE_DOUBLE 2
+
+// define interrupt pins
+#define INTERRUPT_PIN_1 3
+#define INTERRUPT_PIN_2 2
+
+// define eeprom addresses
+#define EEPROM_SLEEP_SAVED 0
+#define EEPROM_SLEEP_1 5
+#define EEPROM_SLEEP_2 6
+#define EEPROM_SLEEP_3 7
+#define EEPROM_USER_START 100
+
+/***********************************
+   Default configuration settings
+*/
+// if enabled, enable debug messages on serial port
+#ifndef DEBUG
+  #define DEBUG 1
+#endif
+
+// if enabled, allow modifying the configuration remotely by interacting with the configuration child id
+// the child id used to allow remote configuration
+#ifndef CONFIGURATION_CHILD_ID
+  #define CONFIGURATION_CHILD_ID 200
+#endif
+// the child id used to report the battery voltage to the controller
+#ifndef BATTERY_CHILD_ID
+  #define BATTERY_CHILD_ID 201
+#endif
+// the child id used to report the rssi level to the controller
+#ifndef SIGNAL_CHILD_ID
+  #define SIGNAL_CHILD_ID 202
+#endif
+// define default sketch name and version
+#ifndef SKETCH_NAME
+  #define SKETCH_NAME "NodeManager"
+#endif
+#ifndef SKETCH_VERSION
+  #define SKETCH_VERSION "1.0"
+#endif
+
+/***********************************
+  Libraries
+*/
+
+// include supporting libraries
+#ifdef MY_USE_UDP
+    #include <WiFiUdp.h>
+#endif
+#ifdef MY_GATEWAY_ESP8266
+  #include <ESP8266WiFi.h>
+#endif
+// load MySensors library
+#include <MySensors.h>
+
+// include third party libraries
+#if MODULE_DHT == 1
+  #include <DHT.h>
+#endif
+#if MODULE_SHT21 == 1
+  #include <Wire.h>
+  #include <Sodaq_SHT2x.h>
+#endif
+#if MODULE_DS18B20 == 1
+  #include <OneWire.h>
+  #include <DallasTemperature.h>
+#endif
+#if MODULE_BH1750 == 1
+  #include <BH1750.h>
+  #include <Wire.h>
+#endif
+#if MODULE_MLX90614 == 1
+  #include <Wire.h>
+  #include <Adafruit_MLX90614.h>
+#endif
+#if MODULE_BME280 == 1
+  #include <Wire.h>
+  #include <SPI.h>
+  #include <Adafruit_Sensor.h>
+  #include <Adafruit_BME280.h>
+#endif
+#if MODULE_SONOFF == 1
+  #include <Bounce2.h>
+#endif
+#if MODULE_BMP085 == 1
+  #include <Wire.h>
+  #include <Adafruit_BMP085.h>
+#endif
+#if MODULE_HCSR04 == 1
+  #include <NewPing.h>
+#endif
+#if MODULE_MCP9808 == 1
+  #include <Wire.h>
+  #include "Adafruit_MCP9808.h"
+#endif
+#if MODULE_MHZ19 == 1
+  #include <SoftwareSerial.h>
+#endif
+#if MODULE_AM2320 == 1
+  #include <Wire.h>
+  #include <AM2320.h>
+#endif
+#if MODULE_TSL2561 == 1
+  #include <TSL2561.h>
+  #include <Wire.h>
+#endif
+#if MODULE_PT100 == 1
+  #include <DFRobotHighTemperatureSensor.h>
+#endif
+#if MODULE_BMP280 == 1
+  #include <Wire.h>
+  #include <Adafruit_Sensor.h>
+  #include <Adafruit_BMP280.h>
+#endif
+#if MODULE_DIMMER == 1
+  #include <math.h>
+#endif
+
+/*******************************************************************
+   Classes
+*/
+class NodeManager;
+class Sensor;
+
+/*
+ * List
+ */
+template<typename T> class List {
+public:
+  typedef T* iterator;
+  List() {
+    _internalArray = NULL;
+    _endPosition = 0;
+    _allocBlocks = 0;
+    _preAllocBlocks = 0;
+  }
+  ~List() {
+    delete[] _internalArray;
+    _internalArray = NULL;
+    _endPosition = 0;
+    _allocBlocks = 0;
+    _preAllocBlocks = 0;
+  }
+  void push(T item) {
+    if (_endPosition == _allocBlocks) _AllocOneBlock(false);
+    _internalArray[_endPosition] = item;
+    ++_endPosition;
+  }
+  void pop() {
+    if (_endPosition == 0) return;
+    --_endPosition;
+    if (_allocBlocks > _preAllocBlocks) _DeAllocOneBlock(false);
+  }
+  T get(int position) {
+    position = position -1;
+    if (position > _endPosition) position = _endPosition;
+    return _internalArray[position];
+  }
+  inline iterator begin() { return _internalArray; }
+  inline iterator end() { return _internalArray + _endPosition; }
+  inline bool empty() { return (_endPosition == 0); }
+  inline unsigned int size() { return _endPosition; }
+private:
+  T* _internalArray;
+  int _endPosition;
+  int _allocBlocks;
+  int _preAllocBlocks;
+  void _AllocOneBlock(bool shiftItems) {
+    ++_allocBlocks;
+    T* newArray = new T[_allocBlocks];
+    for (int i = 0; i < _endPosition; ++i) newArray[shiftItems ? (i + 1) : i] = _internalArray[i];
+    delete[] _internalArray;
+    _internalArray = newArray;
+  }
+  void _DeAllocOneBlock(bool shiftItems) {
+    --_allocBlocks;
+    if (_allocBlocks == 0) {
+      delete[] _internalArray;
+      _internalArray = NULL;
+      return;
+    }
+    T* newArray = new T[_allocBlocks];
+    for (int i = 0; i < _endPosition; ++i) newArray[i] = _internalArray[shiftItems ? (i + 1) : i];
+    delete[] _internalArray;
+    _internalArray = newArray;
+  }
+};
+
+/*
+   PowerManager
+*/
+
+class PowerManager {
+  public:
+    PowerManager(int ground_pin, int vcc_pin, int wait_time = 50);
+    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
+    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // if enabled the pins will be automatically powered on while awake and off during sleeping
+    // turns the power pins on
+    void powerOn();
+    // turns the power pins on
+    void powerOff();
+  private:
+    int _vcc_pin = -1;
+    int _ground_pin = -1;
+    long _wait = 0;
+};
+
+/*
+   Timer
+*/
+
+class Timer {
+  public:
+    Timer(NodeManager* node_manager);
+    // start the timer which will be over when the configured target passes by
+    void start(int target, int unit);
+    void start();
+    // stop the timer
+    void stop();
+    // reset the timer
+    void reset();
+    // reset the timer and start over
+    void restart();
+    // set the timer configuration but do not start it
+    void set(int target, int unit);
+    void unset();
+    // update the timer. To be called at every cycle
+    void update();
+    // return true if the time is over
+    bool isOver();
+    // return true if the timer is running
+    bool isRunning();
+    // return true if the timer has been configured
+    bool isConfigured();
+    // return true if this is the first time the timer runs
+    bool isFirstRun();
+    // return the current elapsed time
+    float getElapsed();
+   private:
+    NodeManager* _node;
+    int _target = 0;
+    long _elapsed = 0;
+    long _last_millis = 0;
+    bool _is_running = false;
+    bool _is_configured = false;
+    bool _first_run = true;
+};
+
+/*
+   Request
+*/
+
+class Request {
+  public:
+    Request(int child_id, const char* string);
+    // return the child id the message has been requested to
+    int getRecipientChildId();
+    // return the child id the request is for
+    int getChildId();
+    // return the parsed function
+    int getFunction();
+    // return the value as an int
+    int getValueInt();
+    // return the value as a float
+    float getValueFloat();
+   private:
+    int _function = -1;
+    int _child_id = -1;
+    int _recipient_child_id = -1;
+    float _value;
+};
+
+/***************************************
+   Child: child class
+*/
+
+class Child {
+  public:
+    Child();
+    Child(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    int child_id;
+    int presentation = S_CUSTOM;
+    int type = V_CUSTOM;
+    char* description = "";
+    Timer* force_update_timer;
+    virtual void sendValue();
+    virtual bool isNewValue();
+  protected:
+    int _samples = 0;
+    Sensor* _sensor;
+};
+
+class ChildInt: public Child {
+  public:
+    ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueInt(int value);
+    int getValueInt();
+    void sendValue();
+    bool isNewValue();
+  private:
+    int _value;
+    int _last_value;
+    int _total = 0;
+};
+
+class ChildFloat: public Child {
+  public:
+    ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueFloat(float value);
+    float getValueFloat();
+    void sendValue();
+    bool isNewValue();
+  private:
+    float _value;
+    float _last_value;
+    float _total = 0;
+};
+
+class ChildDouble: public Child {
+  public:
+    ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueDouble(double value);
+    double getValueDouble();
+    void sendValue();
+    bool isNewValue();
+  private:
+    double _value;
+    double _last_value;
+    double _total = 0;
+};
+
+class ChildString: public Child {
+  public:
+    ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description);
+    void setValueString(char* value);
+    char* getValueString();
+    void sendValue();
+    bool isNewValue();
+  private:
+    char* _value = "";
+    char* _last_value = "";
+};
+
+/***************************************
+   Sensor: generic sensor class
+*/
+
+class Sensor {
+  public:
+    Sensor();
+    Sensor(const NodeManager& node_manager, int pin);
+    // return the name of the sensor
+    char* getName();
+    // [1] where the sensor is attached to (default: not set)
+    void setPin(int value);
+    int getPin();
+    // [5] For some sensors, the measurement can be queried multiple times and an average is returned (default: 1)
+    void setSamples(int value);
+    // [6] If more then one sample has to be taken, set the interval in milliseconds between measurements (default: 0)
+    void setSamplesInterval(int value);
+    // [7] if true will report the measure only if different than the previous one (default: false)
+    void setTrackLastValue(bool value);
+    // [9] if track last value is enabled, force to send an update after the configured number of minutes
+    void setForceUpdateMinutes(int value);
+    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
+    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // [13] manually turn the power on
+    void powerOn();
+    // [14] manually turn the power off
+    void powerOff();
+    // [17] After how many minutes the sensor will report back its measure (default: 10 minutes)
+    void setReportIntervalSeconds(int value);
+    // [16] After how many minutes the sensor will report back its measure (default: 10 minutes)
+    void setReportIntervalMinutes(int value);
+    // [19] After how many hours the sensor will report back its measure (default: 10 minutes)
+    void setReportIntervalHours(int value);
+    // [20] After how many days the sensor will report back its measure (default: 10 minutes)
+    void setReportIntervalDays(int value);
+    // return true if the report interval has been already configured
+    bool isReportIntervalConfigured();
+    // return the pin the interrupt is attached to
+    int getInterruptPin();
+    // listen for interrupts on the given pin so interrupt() will be called when occurring
+    void setInterrupt(int pin, int mode, int initial);
+    // define what to do at each stage of the sketch
+    void before();
+    void presentation();
+    void setup();
+    void loop(MyMessage* message);
+    void interrupt();
+    void receive(const MyMessage & message);
+    // abstract functions, subclasses need to implement
+    virtual void onBefore();
+    virtual void onSetup();
+    virtual void onLoop(Child* child);
+    virtual void onReceive(MyMessage* message);
+    virtual void onInterrupt();
+    List<Child*> children;
+    Child* getChild(int child_id);
+    // register a child
+    void registerChild(Child* child);
+    void setPowerManager(const PowerManager& powerManager);
+    NodeManager* _node;
+  protected:
+    const char* _name = "";
+    int _pin = -1;
+    int _samples = 1;
+    int _samples_interval = 0;
+    bool _track_last_value = false;
+    int _interrupt_pin = -1;
+    PowerManager* _powerManager = nullptr;
+    Timer* _report_timer;
+};
+
+/*
+   SensorBattery: report battery level
+*/
+class SensorBattery: public Sensor {
+  public:
+    SensorBattery(const NodeManager& nodeManager);
+      // [11] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
+      void setMinVoltage(float value);
+      // [12] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
+      void setMaxVoltage(float value);
+      // [15] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
+      void setBatteryInternalVcc(bool value);
+      // [16] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
+      void setBatteryPin(int value);
+      // [17] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
+      void setBatteryVoltsPerBit(float value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+      float _battery_min = 2.6;
+      float _battery_max = 3.3;
+      bool _battery_internal_vcc = true;
+      int _battery_pin = -1;
+      float _battery_volts_per_bit = 0.003363075;
+};
+
+/*
+   SensorSignal: report RSSI signal strength from the radio
+*/
+class SensorSignal: public Sensor {
+  public:
+    SensorSignal(const NodeManager& nodeManager);
+    // [101] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
+    void setSignalCommand(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    int _signal_command = SR_RX_RSSI;
+};
+
+/*
+   SensorConfiguration: allow remote configuration of the board and any configured sensor
+*/
+class SensorConfiguration: public Sensor {
+  public:
+    SensorConfiguration(const NodeManager& nodeManager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+};
+
+#if MODULE_ANALOG_INPUT == 1
+/*
+   SensorAnalogInput: read the analog input of a configured pin
+*/
+class SensorAnalogInput: public Sensor {
+  public:
+    SensorAnalogInput(const NodeManager& node_manager, int pin);
+    // [101] the analog reference to use (default: not set, can be either INTERNAL or DEFAULT)
+    void setReference(int value);
+    // [102] reverse the value or the percentage (e.g. 70% -> 30%) (default: false)
+    void setReverse(bool value);
+    // [103] when true returns the value as a percentage (default: true)
+    void setOutputPercentage(bool value);
+    // [104] minimum value for calculating the percentage (default: 0)
+    void setRangeMin(int value);
+    // [105] maximum value for calculating the percentage (default: 1024)
+    void setRangeMax(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    int _reference = -1;
+    bool _reverse = false;
+    bool _output_percentage = true;
+    int _range_min = 0;
+    int _range_max = 1024;
+    int _getPercentage(int value);
+    int _getAnalogRead();
+};
+
+/*
+   SensorLDR: return the percentage of light from a Light dependent resistor
+*/
+class SensorLDR: public SensorAnalogInput {
+  public:
+    SensorLDR(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+};
+
+/*
+   SensorRain
+*/
+class SensorRain: public SensorAnalogInput {
+  public:
+    SensorRain(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+};
+
+/*
+   SensorSoilMoisture
+*/
+class SensorSoilMoisture: public SensorAnalogInput {
+  public:
+    SensorSoilMoisture(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+};
+#endif
+
+#if MODULE_THERMISTOR == 1
+/*
+   SensorThermistor: read the temperature from a thermistor
+*/
+class SensorThermistor: public Sensor {
+  public:
+    SensorThermistor(const NodeManager& node_manager, int pin);
+    // [101] resistance at 25 degrees C (default: 10000)
+    void setNominalResistor(long value);
+    // [102] temperature for nominal resistance (default: 25)
+    void setNominalTemperature(int value);
+    // [103] The beta coefficient of the thermistor (default: 3950)
+    void setBCoefficient(int value);
+    // [104] the value of the resistor in series with the thermistor (default: 10000)
+    void setSeriesResistor(long value);
+    // [105] set a temperature offset
+    void setOffset(float value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    long _nominal_resistor = 10000;
+    int _nominal_temperature = 25;
+    int _b_coefficient = 3950;
+    long _series_resistor = 10000;
+    float _offset = 0;
+};
+#endif
+
+#if MODULE_ML8511 == 1
+/*
+    SensorML8511
+*/
+
+class SensorML8511: public Sensor {
+  public:
+    SensorML8511(const NodeManager& node_Manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    float _mapfloat(float x, float in_min, float in_max, float out_min, float out_max);
+};
+#endif
+
+#if MODULE_ACS712 == 1
+/*
+    SensorACS712
+*/
+
+class SensorACS712: public Sensor {
+  public:
+    SensorACS712(const NodeManager& node_manager, int pin);
+    // [101] set how many mV are equivalent to 1 Amp. The value depends on the module (100 for 20A Module, 66 for 30A Module) (default: 185);
+    void setmVPerAmp(int value);
+    // [102] set ACS offset (default: 2500);
+    void setOffset(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    int _ACS_offset = 2500;
+    int _mv_per_amp = 185;
+};
+#endif
+
+#if MODULE_DIGITAL_INPUT == 1
+/*
+   SensorDigitalInput: read the digital input of the configured pin
+*/
+class SensorDigitalInput: public Sensor {
+  public:
+    SensorDigitalInput(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+};
+#endif
+
+#if MODULE_DIGITAL_OUTPUT == 1
+/*
+   SensorDigitalOutput: control a digital output of the configured pin
+*/
+class SensorDigitalOutput: public Sensor {
+  public:
+    SensorDigitalOutput(const NodeManager& node_manager, int pin);
+    // [103] define which value to set to the output when set to on (default: HIGH)
+    void setOnValue(int value);
+    // [104] when legacy mode is enabled expect a REQ message to trigger, otherwise the default SET (default: false)
+    void setLegacyMode(bool value);
+    // [105] automatically turn the output off after the given number of minutes
+    void setSafeguard(int value);
+    // [106] if true the input value becomes a duration in minutes after which the output will be automatically turned off (default: false)
+    void setInputIsElapsed(bool value);
+    // [107] optionally wait for the given number of milliseconds after changing the status (default: 0)
+    void setWaitAfterSet(int value);
+    // manually switch the output to the provided value
+    void setStatus(Child* child, int value);
+    // get the current state
+    int getStatus();
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    int _on_value = HIGH;
+    int _status = OFF;
+    bool _legacy_mode = false;
+    bool _input_is_elapsed = false;
+    int _wait_after_set = 0;
+    Timer* _safeguard_timer;
+    void _setupPin(Child* child, int pin);
+    virtual void _setStatus(Child* child, int value);
+    int _getValueToWrite(int value);
+};
+
+/*
+   SensorRelay
+*/
+class SensorRelay: public SensorDigitalOutput {
+  public:
+    SensorRelay(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+};
+
+/*
+   SensorLatchingRelay
+*/
+class SensorLatchingRelay: public SensorRelay {
+  public:
+    SensorLatchingRelay(const NodeManager& node_manager, int pin);
+    // [201] set the duration of the pulse to send in ms to activate the relay (default: 50)
+    void setPulseWidth(int value);
+    // [202] set the pin which turns the relay off (default: the pin provided while registering the sensor)
+    void setPinOff(int value);
+    // [203] set the pin which turns the relay on (default: the pin provided while registering the sensor + 1)
+    void setPinOn(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+  protected:
+    int _pin_on;
+    int _pin_off;
+    int _pulse_width = 50;
+    void _setStatus(Child* child, int value);
+};
+#endif
+
+/*
+   SensorDHT
+*/
+#if MODULE_DHT == 1
+class SensorDHT: public Sensor {
+  public:
+    SensorDHT(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    DHT* _dht;
+    int _dht_type;
+    float _offset = 0;
+};
+
+/*
+   SensorDHT11
+*/
+class SensorDHT11: public SensorDHT {
+  public:
+    SensorDHT11(const NodeManager& node_manager, int pin);
+};
+
+/*
+   SensorDHT22
+*/
+class SensorDHT22: public SensorDHT {
+  public:
+    SensorDHT22(const NodeManager& node_manager, int pin);
+};
+#endif
+
+/*
+   SensorSHT21: temperature and humidity sensor
+*/
+#if MODULE_SHT21 == 1
+class SensorSHT21: public Sensor {
+  public:
+    SensorSHT21(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+};
+
+/*
+   SensorHTU21D: temperature and humidity sensor
+*/
+
+class SensorHTU21D: public SensorSHT21 {
+  public:
+    SensorHTU21D(NodeManager& nodeManager);
+};
+#endif
+
+/*
+ * SensorSwitch
+ */
+#if MODULE_SWITCH == 1
+class SensorSwitch: public Sensor {
+  public:
+    SensorSwitch(const NodeManager& node_manager, int pin);
+    // [101] set the interrupt mode. Can be CHANGE, RISING, FALLING (default: CHANGE)
+    void setMode(int value);
+    // [102] milliseconds to wait before reading the input (default: 0)
+    void setDebounce(int value);
+    // [103] time to wait in milliseconds after a change is detected to allow the signal to be restored to its normal value (default: 0)
+    void setTriggerTime(int value);
+    // [104] Set initial value on the interrupt pin (default: HIGH)
+    void setInitial(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    int _debounce = 0;
+    int _trigger_time = 0;
+    int _mode = CHANGE;
+    int _initial = HIGH;
+};
+
+/*
+ * SensorDoor
+ */
+class SensorDoor: public SensorSwitch {
+  public:
+    SensorDoor(const NodeManager& node_manager, int pin);
+    void onBefore();
+};
+
+/*
+ * SensorMotion
+ */
+class SensorMotion: public SensorSwitch {
+  public:
+    SensorMotion(const NodeManager& node_manager, int pin);
+    void onBefore();
+    void onSetup();
+};
+#endif
+/*
+   SensorDs18b20
+*/
+#if MODULE_DS18B20 == 1
+class SensorDs18b20: public Sensor {
+  public:
+    SensorDs18b20(const NodeManager& node_manager, int pin);
+    // returns the sensor's resolution in bits
+    int getResolution();
+    // [101] set the sensor's resolution in bits
+    void setResolution(int value);
+    // [102] sleep while DS18B20 calculates temperature (default: false)
+    void setSleepDuringConversion(bool value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    bool _sleep_during_conversion = false;
+    DallasTemperature* _sensors;
+};
+#endif
+
+/*
+   SensorBH1750
+*/
+#if MODULE_BH1750 == 1
+class SensorBH1750: public Sensor {
+  public:
+    SensorBH1750(const NodeManager& node_manager);
+    // [101] set sensor reading mode, e.g. BH1750_ONE_TIME_HIGH_RES_MODE
+    void setMode(uint8_t mode);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    BH1750* _lightSensor;
+};
+#endif
+
+/*
+   SensorMLX90614
+*/
+#if MODULE_MLX90614 == 1
+class SensorMLX90614: public Sensor {
+  public:
+    SensorMLX90614(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+    // constants
+    const static int TEMPERATURE_AMBIENT = 0;
+    const static int TEMPERATURE_OBJECT = 1;
+  protected:
+    Adafruit_MLX90614* _mlx;
+    int _sensor_type;
+};
+#endif
+
+
+/*
+ * SensorBosch
+*/
+
+#if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
+class SensorBosch: public Sensor {
+  public:
+    SensorBosch(const NodeManager& node_manager);
+    // [101] define how many pressure samples to keep track of for calculating the forecast (default: 5)
+    void setForecastSamplesCount(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+    static uint8_t GetI2CAddress(uint8_t chip_id);
+  protected:
+    char* _weather[6] = { "stable", "sunny", "cloudy", "unstable", "thunderstorm", "unknown" };
+    int _forecast_samples_count = 5;
+    float* _forecast_samples;
+    int _minute_count = 0;
+    float _pressure_avg;
+    float _pressure_avg2;
+    float _dP_dt;
+    bool _first_round = true;
+    float _getLastPressureSamplesAverage();
+    char* _forecast(float pressure);
+};
+#endif
+
+/*
+   SensorBME280
+*/
+#if MODULE_BME280 == 1
+class SensorBME280: public SensorBosch {
+  public:
+    SensorBME280(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onLoop(Child* child);
+  protected:
+    Adafruit_BME280* _bm;
+};
+#endif
+
+/*
+   SensorBMP085
+*/
+#if MODULE_BMP085 == 1
+class SensorBMP085: public SensorBosch {
+  public:
+    SensorBMP085(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onLoop(Child* child);
+  protected:
+    Adafruit_BMP085* _bm;
+};
+#endif
+
+/*
+   SensorBMP280
+*/
+#if MODULE_BMP280 == 1
+class SensorBMP280: public SensorBosch {
+  public:
+    SensorBMP280(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onLoop(Child* child);
+  protected:
+    Adafruit_BMP280* _bm;
+};
+#endif
+
+/*
+   SensorSonoff
+*/
+#if MODULE_SONOFF == 1
+class SensorSonoff: public Sensor {
+  public:
+    SensorSonoff(const NodeManager& node_manager);
+    // [101] set the button's pin (default: 0)
+    void setButtonPin(int value);
+    // [102] set the relay's pin (default: 12)
+    void setRelayPin(int value);
+    // [103] set the led's pin (default: 13)
+    void setLedPin(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    Bounce _debouncer = Bounce();
+    int _button_pin = 0;
+    int _relay_pin = 12;
+    int _led_pin = 13;
+    int _old_value = 0;
+    bool _state = false;
+    int _relay_on = 1;
+    int _relay_off = 0;
+    int _led_on = 0;
+    int _led_off = 1;
+    void _blink();
+    void _toggle(Child* child);
+};
+#endif
+
+/*
+   SensorHCSR04
+*/
+#if MODULE_HCSR04 == 1
+class SensorHCSR04: public Sensor {
+  public:
+    SensorHCSR04(const NodeManager& node_manager, int pin);
+    // [101] Arduino pin tied to trigger pin on the ultrasonic sensor (default: the pin set while registering the sensor)
+    void setTriggerPin(int value);
+    // [102] Arduino pin tied to echo pin on the ultrasonic sensor (default: the pin set while registering the sensor)
+    void setEchoPin(int value);
+    // [103] Maximum distance we want to ping for (in centimeters) (default: 300)
+    void setMaxDistance(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onProcess(Request & request);
+    void onInterrupt();
+  protected:
+    int _trigger_pin;
+    int _echo_pin;
+    int _max_distance = 300;
+    NewPing* _sonar;
+};
+#endif
+
+/*
+   SensorMCP9808
+*/
+#if MODULE_MCP9808 == 1
+class SensorMCP9808: public Sensor {
+  public:
+    SensorMCP9808(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    Adafruit_MCP9808* _mcp;
+};
+#endif
+
+/*
+    SensorMQ
+ */
+ #if MODULE_MQ == 1
+class SensorMQ: public Sensor {
+  public:
+    SensorMQ(const NodeManager& node_manager, int pin);
+    // [101] define the target gas whose ppm has to be returned. 0: LPG, 1: CO, 2: Smoke (default: 1);
+    void setTargetGas(int value);
+    // [102] define the load resistance on the board, in kilo ohms (default: 1);
+    void setRlValue(float value);
+    // [103] define the Ro resistance on the board (default: 10000);
+    void setRoValue(float value);
+    // [104] Sensor resistance in clean air (default: 9.83);
+    void setCleanAirFactor(float value);
+    // [105] define how many samples you are going to take in the calibration phase (default: 50);
+    void setCalibrationSampleTimes(int value);
+    // [106] define the time interal(in milisecond) between each samples in the cablibration phase (default: 500);
+    void setCalibrationSampleInterval(int value);
+    // [107] define how many samples you are going to take in normal operation (default: 50);
+    void setReadSampleTimes(int value);
+    // [108] define the time interal(in milisecond) between each samples in the normal operations (default: 5);
+    void setReadSampleInterval(int value);
+    // set the LPGCurve array (default: {2.3,0.21,-0.47})
+    void setLPGCurve(float *value);
+    // set the COCurve array (default: {2.3,0.72,-0.34})
+    void setCOCurve(float *value);
+    // set the SmokeCurve array (default: {2.3,0.53,-0.44})
+    void setSmokeCurve(float *value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    float _rl_value = 1.0;
+    float _ro_clean_air_factor = 9.83;
+    int _calibration_sample_times = 50;
+    int _calibration_sample_interval = 500;
+    int _read_sample_interval = 50;
+    int _read_sample_times = 5;
+    float _ro = 10000.0;
+    static float _default_LPGCurve[3];
+    static float _default_COCurve[3];
+    static float _default_SmokeCurve[3];
+    float *_LPGCurve;
+    float *_COCurve;
+    float *_SmokeCurve;
+    float _MQResistanceCalculation(int raw_adc);
+    float _MQCalibration();
+    float _MQRead();
+    int _MQGetGasPercentage(float rs_ro_ratio, int gas_id);
+    int  _MQGetPercentage(float rs_ro_ratio, float *pcurve);
+    const static int _gas_lpg = 0;
+    const static int _gas_co = 1;
+    const static int _gas_smoke = 2;
+    int _target_gas = _gas_co;
+};
+#endif
+
+/*
+   SensorMHZ19
+*/
+#if MODULE_MHZ19 == 1
+class SensorMHZ19: public Sensor {
+  public:
+    SensorMHZ19(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    int _readCO2();
+    SoftwareSerial* _ser;
+    int _tx_pin = 6;
+    int _rx_pin = 7;
+};
+#endif
+
+/*
+   SensorAM2320
+*/
+#if MODULE_AM2320 == 1
+class SensorAM2320: public Sensor {
+  public:
+    SensorAM2320(const NodeManager& node_manager);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    AM2320* _th;
+};
+#endif
+
+/*
+   SensorTSL2561
+*/
+#if MODULE_TSL2561 == 1
+class SensorTSL2561: public Sensor {
+  public:
+    SensorTSL2561(const NodeManager& node_manager);
+    // [101] set the gain, possible values are SensorTSL2561::GAIN_0X (0), SensorTSL2561::GAIN_16X (1) (default 16x)
+    void setGain(int value);
+    // [102] set the timing, possible values are SensorTSL2561::INTEGRATIONTIME_13MS (0), SensorTSL2561::INTEGRATIONTIME_101MS (1), SensorTSL2561::INTEGRATIONTIME_402MS (2) (default: 13ms)
+    void setTiming(int value);
+    // [103] set the spectrum, possible values are SensorTSL2561::VISIBLE (0), SensorTSL2561::FULLSPECTRUM (1), SensorTSL2561::INFRARED (2), SensorTSL2561::FULL (3) (default: visible)
+    void setSpectrum(int value);
+    // [104] set the i2c address values are SensorTSL2561::ADDR_FLOAT, SensorTSL2561::ADDR_LOW, SensorTSL2561::ADDR_HIGH
+    void setAddress(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onProcess(Request & request);
+    void onInterrupt();
+    // constants
+    const static int ADDR_FLOAT = 0;
+    const static int ADDR_LOW = 1;
+    const static int ADDR_HIGH = 2;
+    const static int GAIN_0X = 0;
+    const static int GAIN_16X = 1;
+    const static int INTEGRATIONTIME_13MS = 0;
+    const static int INTEGRATIONTIME_101MS = 1;
+    const static int INTEGRATIONTIME_402MS = 2;
+    const static int VISIBLE = 0;
+    const static int FULLSPECTRUM = 1;
+    const static int INFRARED = 2;
+    const static int FULL = 3;
+  protected:
+    TSL2561* _tsl;
+    int _tsl_address = 0;
+    int _tsl_gain = 1;
+    int _tsl_timing = 0;
+    int _tsl_spectrum = 0;
+};
+#endif
+
+/*
+    SensorPT100
+*/
+#if MODULE_PT100 == 1
+class SensorPT100: public Sensor {
+  public:
+    SensorPT100(const NodeManager& node_manager, int pin);
+    // [101] set the voltageRef used to compare with analog measures
+    void setVoltageRef(float value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    DFRobotHighTemperature* _PT100;
+    float _voltageRef = 3.3;
+};
+#endif
+
+/*
+    SensorPT100
+*/
+#if MODULE_DIMMER == 1
+class SensorDimmer: public Sensor {
+  public:
+    SensorDimmer(const NodeManager& node_manager, int pin);
+    // [101] set the effect to use for a smooth transition, can be one of SensorDimmer::EASE_LINEAR, SensorDimmer::EASE_INSINE, SensorDimmer::EASE_OUTSINE, SensorDimmer::EASE_INOUTSINE (default: EASE_LINEAR)
+    void setEasing(int value);
+    // [102] the duration of entire the transition in seconds (default: 1)
+    void setDuration(int value);
+    // [103] the duration of a single step of the transition in milliseconds (default: 100)
+    void setStepDuration(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onInterrupt();
+  protected:
+    // fade the output from the current value to the target provided in the range 0-100
+    void _fadeTo(Child* child, int value);
+    enum _easing_list {
+      EASE_LINEAR,
+      EASE_INSINE,
+      EASE_OUTSINE,
+      EASE_INOUTSINE,
+    };
+    int _percentage = 0;
+    int _easing = EASE_LINEAR;
+    int _duration = 1000;
+    int _step_duration = 100;
+    float _getEasing(float t, float b, float c, float d);
+};
+#endif
+
+/*
+    SensorPulseMeter
+*/
+#if MODULE_PULSE_METER == 1
+class SensorPulseMeter: public Sensor {
+  public:
+    SensorPulseMeter(const NodeManager& node_manager, int pin);
+    // [102] set how many pulses for each unit (e.g. 1000 pulses for 1 kwh of power, 9 pulses for 1 mm of rain, etc.)
+    void setPulseFactor(float value);
+    // set initial value - internal pull up (default: HIGH)
+    void setInitialValue(int value);
+    // set the interrupt mode to attach to (default: FALLING)
+    void setInterruptMode(int value);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+    void onProcess(Request & request);
+    void onInterrupt();
+  protected:
+    long _count = 20;
+    float _pulse_factor;
+    int _initial_value = HIGH;
+    int _interrupt_mode = FALLING;
+    virtual void _reportTotal(Child* child);
+};
+
+/*
+    SensorRainGauge
+*/
+class SensorRainGauge: public SensorPulseMeter {
+  public:
+    SensorRainGauge(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+};
+
+/*
+    SensorPowerMeter
+*/
+class SensorPowerMeter: public SensorPulseMeter {
+  public:
+    SensorPowerMeter(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+  protected:
+    void _reportTotal(Child* child);
+};
+
+/*
+    SensorWaterMeter
+*/
+class SensorWaterMeter: public SensorPulseMeter {
+  public:
+    SensorWaterMeter(const NodeManager& node_manager, int pin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+  protected:
+    void _reportTotal(Child* child);
+};
+#endif
+
+/***************************************
+   NodeManager: manages all the aspects of the node
+*/
+class NodeManager {
+  public:
+    NodeManager();
+    // [10] send the same service message multiple times (default: 1)
+    void setRetries(int value);
+    int getRetries();
+    // [3] set the duration (in seconds) of a sleep cycle
+    void setSleepSeconds(int value);
+    long getSleepSeconds();
+    // [4] set the duration (in minutes) of a sleep cycle
+    void setSleepMinutes(int value);
+    // [5] set the duration (in hours) of a sleep cycle
+    void setSleepHours(int value);
+    // [29] set the duration (in days) of a sleep cycle
+    void setSleepDays(int value);
+    // [19] if enabled, when waking up from the interrupt, the board stops sleeping. Disable it when attaching e.g. a motion sensor (default: true)
+    void setSleepInterruptPin(int value);
+    // configure the interrupt pin and mode. Mode can be CHANGE, RISING, FALLING (default: MODE_NOT_DEFINED)
+    void setInterrupt(int pin, int mode, int initial = -1);
+    // [28] ignore two consecutive interrupts if happening within this timeframe in milliseconds (default: 100)
+    void setInterruptMinDelta(long value);
+    // [20] optionally sleep interval in milliseconds before sending each message to the radio network (default: 0)
+    void setSleepBetweenSend(int value);
+    int getSleepBetweenSend();
+    // register a sensor
+    void registerSensor(Sensor* sensor);
+    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
+    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // [24] manually turn the power on
+    void powerOn();
+    // [25] manually turn the power off
+    void powerOff();
+    // [21] set this to true if you want destination node to send ack back to this node (default: false)
+    void setAck(bool value);
+    bool getAck();
+    // request and return the current timestamp from the controller
+    long getTimestamp();
+    // Request the controller's configuration on startup (default: true)
+    void setGetControllerConfig(bool value);
+    // [22] Manually set isMetric setting
+    void setIsMetric(bool value);
+    bool getIsMetric();
+    // Convert a temperature from celsius to fahrenheit depending on how isMetric is set
+    float celsiusToFahrenheit(float temperature);
+    // return true if sleep or wait is configured and hence this is a sleeping node
+    bool isSleepingNode();
+    // [1] Send a hello message back to the controller
+    void hello();
+    // [6] reboot the board
+    void reboot();
+    // [7] clear the EEPROM
+    void clearEeprom();
+    // [9] wake up the board
+    void wakeup();
+    // return the value stored at the requested index from the EEPROM
+    int loadFromMemory(int index);
+    // [27] save the given index of the EEPROM the provided value
+    void saveToMemory(int index, int value);
+    // return vcc in V
+    float getVcc();
+    // setup the configured interrupt pins
+    void setupInterrupts();
+    // return the pin from which the last interrupt came
+    int getLastInterruptPin();
+    // [36] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
+    void setReportIntervalSeconds(int value);
+    // [37] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
+    void setReportIntervalMinutes(int value);
+    // [38] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
+    void setReportIntervalHours(int value);
+    // [39] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
+    void setReportIntervalDays(int value);
+    // [30] if set and when the board is battery powered, sleep() is always called instead of wait() (default: true)
+    void setSleepOrWait(bool value);
+    // sleep if the node is a battery powered or wait if it is not for the given number of milliseconds 
+    void sleepOrWait(long value);
+    // [31] set which pin is connected to RST of the board to reboot the board when requested. If not set the software reboot is used instead (default: -1)
+    void setRebootPin(int value);
+    // [32] turn the ADC off so to save 0.2 mA
+    void setADCOff();
+    // [30] if set save the sleep settings in memory, also when changed remotely (default: false)
+    void setSaveSleepSettings(bool value);
+    // hook into the main sketch functions
+    void before();
+    void presentation();
+    void setup();
+    void loop();
+    void receive(const MyMessage & msg);
+    void receiveTime(unsigned long ts);
+    // handle interrupts
+    static void _onInterrupt_1();
+    static void _onInterrupt_2();
+    // send a message by providing the source child, type of the message and value
+	  void sendMessage(int child_id, int type, int value);
+    void sendMessage(int child_id, int type, float value);
+    void sendMessage(int child_id, int type, double value);
+    void sendMessage(int child_id, int type, const char* value);
+    void setPowerManager(const PowerManager& powerManager);
+    int getAvailableChildId();
+    List<Sensor*> sensors;
+    Child* getChild(int child_id);
+    Sensor* getSensorWithChild(int child_id);
+  private:
+    PowerManager* _powerManager = nullptr;
+    MyMessage _message;
+    void _sendMessage(int child_id, int type);
+    int _status = AWAKE;
+    long _sleep_time = 0;
+    int _sleep_interrupt_pin = -1;
+    int _sleep_between_send = 0;
+    int _retries = 1;
+    int _interrupt_1_mode = MODE_NOT_DEFINED;
+    int _interrupt_2_mode = MODE_NOT_DEFINED;
+    int _interrupt_1_initial = -1;
+    int _interrupt_2_initial = -1;
+    static int _last_interrupt_pin;
+    static long _interrupt_min_delta;
+    static long _last_interrupt_1;
+    static long _last_interrupt_2;
+    long _timestamp = -1;
+    bool _ack = false;
+    void _sleep();
+    void _present(int child_id, int type);
+    bool _get_controller_config = true;
+    int _is_metric = 1;
+    int _report_interval_seconds = 10*60;
+    bool _sleep_or_wait = true;
+    int _reboot_pin = -1;
+    bool _save_sleep_settings = false;
+    void _loadSleepSettings();
+    void _saveSleepSettings();
+};
+
+#endif
\ No newline at end of file
diff --git a/NodeManagerLibrary.ino b/NodeManagerLibrary.ino
new file mode 100644
index 0000000..b919f14
--- /dev/null
+++ b/NodeManagerLibrary.ino
@@ -0,0 +1,4192 @@
+/*
+ * NodeManager Library
+ */
+ 
+/***************************************
+   PowerManager
+*/
+
+PowerManager::PowerManager(int ground_pin, int vcc_pin, int wait_time) {
+  setPowerPins(ground_pin, vcc_pin, wait_time);
+}
+
+// set the vcc and ground pin the sensor is connected to
+void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
+  _ground_pin = ground_pin;
+  _vcc_pin = vcc_pin;
+  #if DEBUG == 1
+    Serial.print(F("PWR G="));
+    Serial.print(_ground_pin);
+    Serial.print(F(" V="));
+    Serial.println(_vcc_pin);
+  #endif
+  if (_ground_pin > 0) {
+    // configure the ground pin as output and initialize to low
+    pinMode(_ground_pin, OUTPUT);
+    digitalWrite(_ground_pin, LOW);
+  }
+  if (_vcc_pin > 0) {
+    // configure the vcc pin as output and initialize to high (power on)
+    pinMode(_vcc_pin, OUTPUT);
+    digitalWrite(_vcc_pin, HIGH);
+  }
+  // save wait time
+  _wait = wait_time;
+}
+
+// turn on the sensor by activating its power pins
+void PowerManager::powerOn() {
+  if (_vcc_pin == -1) return;
+  #if DEBUG == 1
+    Serial.print(F("ON P="));
+    Serial.println(_vcc_pin);
+  #endif
+  // power on the sensor by turning high the vcc pin
+  digitalWrite(_vcc_pin, HIGH);
+  // wait a bit for the device to settle down
+  if (_wait > 0) wait(_wait);
+}
+
+// turn off the sensor
+void PowerManager::powerOff() {
+  if (_vcc_pin == -1) return;
+  #if DEBUG == 1
+    Serial.print(F("OFF P="));
+    Serial.println(_vcc_pin);
+  #endif
+  // power off the sensor by turning low the vcc pin
+  digitalWrite(_vcc_pin, LOW);
+}
+
+/******************************************
+    Timer
+*/
+
+Timer::Timer(NodeManager* node_manager) {
+  _node = node_manager;
+}
+
+// start the timer
+void Timer::start(int target, int unit) {
+  set(target,unit);
+  start();
+}
+void Timer::start() {
+  if (_is_configured) _is_running = true;
+}
+
+// stop the timer
+void Timer::stop() {
+  _is_running = false;
+}
+
+// reset the timer
+void Timer::reset() {
+  // reset the timer
+  _elapsed = 0;
+  _last_millis = 0;
+}
+
+// restart the timer
+void Timer::restart() {
+  if (! isRunning()) return;
+  stop();
+  reset();
+  // if using millis(), keep track of the current timestamp for calculating the difference
+  if (! _node->isSleepingNode()) _last_millis = millis();
+  start();
+}
+
+// setup the timer
+void Timer::set(int target, int unit) {
+  reset();
+  // save the settings
+  _target = target;
+  if (unit == MINUTES) _target = _target * 60;
+  else if (unit == HOURS) _target = _target * 60 *60;
+  else if (unit == DAYS) _target = _target * 60 * 60 *24;
+  _is_running = false;
+  _is_configured = true;
+}
+
+// unset the timer
+void Timer::unset() {
+  stop();
+  _is_configured = true;
+}
+
+// update the timer at every cycle
+void Timer::update() {
+  if (! isRunning()) return;
+  if (_node->isSleepingNode()) {
+    // millis() is not reliable while sleeping so calculate how long a sleep cycle would last in seconds and update the elapsed time
+    _elapsed += _node->getSleepSeconds();
+  } else {
+    // use millis() to calculate the elapsed time in seconds
+    _elapsed = (long)((millis() - _last_millis)/1000);
+  }
+  _first_run = false;
+}
+
+// return true if the time is over
+bool Timer::isOver() {
+  if (! isRunning()) return false;
+  // time has elapsed
+  if (_elapsed >= _target) return true;
+  // millis has started over
+  if (_elapsed < 0 ) return true;
+  return false;
+}
+
+// return true if the timer is running
+bool Timer::isRunning() {
+  if (! isConfigured()) return false;
+  return _is_running;
+}
+
+// return true if the time is configured
+bool Timer::isConfigured() {
+  return _is_configured;
+}
+
+// return true if this is the first time the timer runs
+bool Timer::isFirstRun() {
+  return _first_run;
+}
+
+// return elapsed seconds so far
+float Timer::getElapsed() {
+  return _elapsed;
+}
+
+
+/******************************************
+    Request
+*/
+
+// contructor, tokenize a request in the format "child_id,function,value"
+Request::Request(int recipient_child_id, const char* string) {
+  _recipient_child_id = recipient_child_id;
+  char* ptr;
+  // tokenize the string and get child id
+  _child_id = atoi(strtok_r(string, ",", &ptr));
+  // tokenize the string and get function id
+  _function = atoi(strtok_r(NULL, ",", &ptr));
+  // tokenize the string and get the value
+  _value = atof(strtok_r(NULL, ",", &ptr));
+  #if DEBUG == 1
+    Serial.print(F("REQ C="));
+    Serial.print(_child_id);
+    Serial.print(F(" F="));
+    Serial.print(_function);
+    Serial.print(F(" V="));
+    Serial.println(_value);
+  #endif
+}
+
+// return the child id
+int Request::getRecipientChildId() {
+  return _recipient_child_id;
+}
+
+// return the child id
+int Request::getChildId() {
+  return _child_id;
+}
+
+// return the parsed function
+int Request::getFunction() {
+  return _function;
+}
+
+// return the value as an int
+int Request::getValueInt() {
+  return (int)_value;
+  
+}
+
+// return the value as a float
+float Request::getValueFloat() {
+  return _value;
+}
+
+/******************************************
+    Sensors
+*/
+
+/*
+ Child class
+ */
+
+Child::Child() {
+
+}
+
+// constructor
+Child::Child(Sensor* __sensor, int _child_id, int _presentation, int _type, char* _description = "") {
+  child_id = _child_id;
+  presentation = _presentation;
+  type = _type;
+  description = _description;
+  _sensor = __sensor;
+  _sensor->registerChild(this);
+  force_update_timer = new Timer(_sensor->_node);
+}
+// set a value, implemented by the subclasses
+void Child::sendValue() {
+}
+
+// check if it is an updated value, implemented by the subclasses
+bool Child::isNewValue() {
+}
+
+/*
+ ChildInt class
+*/
+
+// ChildInt class
+ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+}
+
+// store a new value and update the total
+void ChildInt::setValueInt(int value) {
+  _total = _total + value;
+  _samples++;
+  _value = (int) (_total / _samples);
+}
+
+// return the value
+int ChildInt::getValueInt() {
+  return _value;
+}
+
+// send the value back to the controller
+void ChildInt::sendValue() {
+  if (_samples == 0) return;
+  _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
+  _total = 0;
+  _samples = 0;
+}
+
+// check if it is an updated value
+bool ChildInt::isNewValue() {
+  return _last_value != _value;
+}
+
+/*
+ ChildFloat class
+*/
+
+// ChildFloat class
+ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+}
+
+// store a new value and update the total
+void ChildFloat::setValueFloat(float value) {
+  _total = _total + value;
+  _samples++;
+  _value = _total / _samples;
+}
+
+// return the value
+float ChildFloat::getValueFloat() {
+  return _value;
+}
+
+// send the value back to the controller
+void ChildFloat::sendValue() {
+  if (_samples == 0) return;
+  _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
+  _total = 0;
+  _samples = 0;
+}
+
+// check if it is an updated value
+bool ChildFloat::isNewValue() {
+  return _last_value != _value;
+}
+
+/*
+ ChildDouble class
+*/
+
+// ChildDouble class
+ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+}
+
+// store a new value and update the total
+void ChildDouble::setValueDouble(double value) {
+  _total = _total + value;
+  _samples++;
+  _value = _total / _samples;
+}
+
+// return the value
+double ChildDouble::getValueDouble() {
+  return _value;
+}
+
+// send the value back to the controller
+void ChildDouble::sendValue() {
+  if (_samples == 0) return;
+  _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
+  _total = 0;
+  _samples = 0;
+}
+
+// check if it is an updated value
+bool ChildDouble::isNewValue() {
+  return _last_value != _value;
+}
+
+/*
+ ChildString class
+*/
+
+// ChildString class
+ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
+}
+
+// store a new value and update the total
+void ChildString::setValueString(char* value) {
+  _value = value;
+}
+
+// return the value
+char* ChildString::getValueString() {
+  return _value;
+}
+
+// send the value back to the controller
+void ChildString::sendValue() {
+  _sensor->_node->sendMessage(child_id,type,_value);
+  _last_value = _value;
+  _value = "";
+}
+
+// check if it is an updated value
+bool ChildString::isNewValue() {
+  return strcmp(_value, _last_value) != 0;
+}
+
+/*
+   Sensor class
+*/
+// constructor
+Sensor::Sensor() {  
+}
+Sensor::Sensor(const NodeManager& node_manager, int pin = -1) {
+  _node = &node_manager;
+  _pin = pin;
+  _report_timer = new Timer(_node);
+  _node->registerSensor(this);
+}
+
+// return the name of the sensor
+char* Sensor::getName() {
+  return _name;
+}
+
+// setter/getter
+void Sensor::setPin(int value) {
+  _pin = value;
+}
+int Sensor::getPin() {
+  return _pin;
+}
+void Sensor::setSamples(int value) {
+  _samples = value;
+}
+void Sensor::setSamplesInterval(int value) {
+  _samples_interval = value;
+}
+void Sensor::setTrackLastValue(bool value) {
+  _track_last_value = value;
+}
+void Sensor::setForceUpdateMinutes(int value) {
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
+    child->force_update_timer->start(value,MINUTES);
+  }
+}
+void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
+  if (_powerManager == nullptr) return;
+  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
+}
+void Sensor::powerOn() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOn();
+}
+void Sensor::powerOff() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOff();
+}
+int Sensor::getInterruptPin() {
+  return _interrupt_pin;
+}
+
+// After how many seconds the sensor will report back its measure
+void Sensor::setReportIntervalSeconds(int value) {
+  _report_timer->start(value,SECONDS);
+}
+
+// After how many minutes the sensor will report back its measure 
+void Sensor::setReportIntervalMinutes(int value) {
+  _report_timer->start(value,MINUTES);
+}
+
+// After how many minutes the sensor will report back its measure 
+void Sensor::setReportIntervalHours(int value) {
+  _report_timer->start(value,HOURS);
+}
+
+// After how many minutes the sensor will report back its measure 
+void Sensor::setReportIntervalDays(int value) {
+  _report_timer->start(value,DAYS);
+}
+
+
+// return true if the report interval has been already configured
+bool Sensor::isReportIntervalConfigured() {
+  return _report_timer->isConfigured();
+}
+
+// listen for interrupts on the given pin so interrupt() will be called when occurring
+void Sensor::setInterrupt(int pin, int mode, int initial) {
+  _interrupt_pin = pin;
+  _node->setInterrupt(pin,mode,initial);
+}
+
+// register a child
+void Sensor::registerChild(Child* child) {
+  children.push(child);
+}
+
+// present the sensor to the gateway and controller
+void Sensor::presentation() {
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
+    #if DEBUG == 1
+      Serial.print(F("PRES I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(child->presentation);
+    #endif
+    present(child->child_id, child->presentation,child->description,_node->getAck());
+  }
+
+}
+
+// call the sensor-specific implementation of before
+void Sensor::before() {
+  onBefore();
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" P="));
+      Serial.print(child->presentation);
+      Serial.print(F(" T="));
+      Serial.println(child->type);
+    #endif
+  }
+}
+
+// call the sensor-specific implementation of setup
+void Sensor::setup() {
+  onSetup();
+}
+
+// call the sensor-specific implementation of loop
+void Sensor::loop(MyMessage* message) {
+  // update the timers if within a loop cycle
+  if (message == nullptr) {
+    if (_report_timer->isRunning()) {
+      // keep track if it is the first time
+      bool first_run = _report_timer->isFirstRun();
+      // update the timer
+      _report_timer->update();
+      // if it is not the time yet to report a new measure, just return (unless it is the first time)
+      if (! _report_timer->isOver() && ! first_run) return;
+    }
+  }
+  // turn the sensor on
+  powerOn();
+  // iterates over all the children
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
+    // update the force update timer if running
+    if (child->force_update_timer->isRunning()) child->force_update_timer->update();
+    // if a specific child is requested, skip all the others
+    if (message != nullptr && message->sensor != child->child_id) continue;
+    // collect multiple samples if needed
+    for (int i = 0; i < _samples; i++) {
+      // we've been called from receive(), pass the message along
+      if (message != nullptr) onReceive(message);
+      // we'be been called from loop()
+      else onLoop(child);
+      // wait between samples
+      if (_samples_interval > 0) _node->sleepOrWait(_samples_interval);
+    }
+    // process the result and send a response back if 1) is not a loop 2) not tracking last value 3) tracking last value and there is a new value 4) tracking last value and timer is over
+    if (
+      message != nullptr || 
+      ! _track_last_value || 
+      _track_last_value && child->isNewValue() || 
+      _track_last_value && child->force_update_timer->isRunning() && child->force_update_timer->isOver()) 
+        child->sendValue();
+  }
+  // turn the sensor off
+  powerOff();
+  // if called from loop(), restart the report timer if over
+  if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
+}
+
+// receive and handle an interrupt
+void Sensor::interrupt() {
+  // call the implementation of onInterrupt()
+  onInterrupt();
+}
+
+// receive a message from the radio network
+void Sensor::receive(const MyMessage &message) {
+  // a request would make the sensor executing its main task passing along the message
+  loop(&message);
+}
+
+// return the requested child 
+Child* Sensor::getChild(int child_id) {
+  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
+    Child* child = *itr;
+    if (child->child_id == child_id) return child;
+  }
+  return nullptr;
+}
+
+void Sensor::setPowerManager(const PowerManager& powerManager) {
+  _powerManager = &powerManager;
+}
+
+
+// virtual functions
+void Sensor::onBefore() {}
+void Sensor::onSetup(){}
+void Sensor::onLoop(Child* child){}
+void Sensor::onReceive(MyMessage* message){}
+void Sensor::onInterrupt(){}
+
+/*
+   SensorBattery
+*/
+// contructor
+SensorBattery::SensorBattery(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "BAT";
+  // report battery level every 60 minutes by default
+  setReportIntervalMinutes(60);
+}
+void SensorBattery::setMinVoltage(float value) {
+  _battery_min = value;
+}
+void SensorBattery::setMaxVoltage(float value) {
+  _battery_max = value;
+}
+void SensorBattery::setBatteryInternalVcc(bool value) {
+  _battery_internal_vcc = value;
+}
+void SensorBattery::setBatteryPin(int value) {
+  _battery_pin = value;
+}
+void SensorBattery::setBatteryVoltsPerBit(float value) {
+  _battery_volts_per_bit = value;
+}
+
+// what to do during before
+void SensorBattery::onBefore() {
+  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);
+}
+
+// what to do during setup
+void SensorBattery::onSetup() {
+  // when measuring the battery from a pin, analog reference must be internal
+  if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
+}
+
+// what to do during loop
+void SensorBattery::onLoop(Child* child) {
+  // measure the board vcc
+  float volt = 0;
+  if (_battery_internal_vcc || _battery_pin == -1) volt = _node->getVcc();
+  else volt = analogRead(_battery_pin) * _battery_volts_per_bit;
+  // calculate the percentage
+  int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
+  if (percentage > 100) percentage = 100;
+  if (percentage < 0) percentage = 0;
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" V="));
+    Serial.print(volt);
+    Serial.print(F(" %="));
+    Serial.println(percentage);
+  #endif
+  ((ChildFloat*)child)->setValueFloat(volt);
+  // report battery level percentage
+  sendBatteryLevel(percentage);
+}
+
+// what to do as the main task when receiving a message
+void SensorBattery::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorBattery::onInterrupt() {
+}
+
+/*
+   SensorSignal
+*/
+// contructor
+SensorSignal::SensorSignal(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "SIG";
+  // report signal level every 60 minutes by default
+  setReportIntervalMinutes(60);
+}
+// setter/getter
+void SensorSignal::setSignalCommand(int value) {
+  _signal_command = value;
+}
+
+// what to do during before
+void SensorSignal::onBefore() {
+  new ChildInt(this,SIGNAL_CHILD_ID,S_SOUND,V_LEVEL);
+}
+
+// what to do during setup
+void SensorSignal::onSetup() {
+
+}
+
+// what to do during loop
+void SensorSignal::onLoop(Child* child) {
+  int16_t value = transportGetSignalReport(_signal_command);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" V="));
+    Serial.println(value);
+  #endif
+  ((ChildInt*)child)->setValueInt(value);
+}
+
+// what to do as the main task when receiving a message
+void SensorSignal::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorSignal::onInterrupt() {
+}
+
+/*
+   SensorConfiguration
+*/
+// contructor
+SensorConfiguration::SensorConfiguration(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "CONF";
+}
+
+// what to do during before
+void SensorConfiguration::onBefore() {
+  new ChildInt(this,CONFIGURATION_CHILD_ID,S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorConfiguration::onSetup() {
+
+}
+
+// what to do during loop
+void SensorConfiguration::onLoop(Child* child) {
+}
+
+// what to do as the main task when receiving a message
+void SensorConfiguration::onReceive(MyMessage* message) {
+  // expect a REQ, V_CUSTOM message
+  if (message->getCommand() != C_REQ && message->type != V_CUSTOM) return;
+  // parse the request
+  Request request = Request(message->sensor,message->getString());
+  int function = request.getFunction();
+  int child_id = request.getChildId();
+  // if the message is for the board itself
+  if (child_id == 0) {
+    switch(function) {
+      case 1: _node->hello(); break;
+      case 3: _node->setSleepSeconds(request.getValueInt()); break;
+      case 4: _node->setSleepMinutes(request.getValueInt()); break;
+      case 5: _node->setSleepHours(request.getValueInt()); break;
+      case 29: _node->setSleepDays(request.getValueInt()); break;
+      #ifndef MY_GATEWAY_ESP8266
+        case 6: _node->reboot(); return;
+      #endif
+      case 7: _node->clearEeprom(); break;
+      case 8: _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,VERSION); return;
+      case 9: _node->wakeup(); break;
+      case 10: _node->setRetries(request.getValueInt()); break;
+      case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
+      case 20: _node->setSleepBetweenSend(request.getValueInt()); break;
+      case 21: _node->setAck(request.getValueInt()); break;
+      case 22: _node->setIsMetric(request.getValueInt()); break;
+      case 24: _node->powerOn(); break;
+      case 25: _node->powerOff(); break;
+      case 27: _node->saveToMemory(0,request.getValueInt()); break;
+      case 28: _node->setInterruptMinDelta(request.getValueInt()); break;
+      case 30: _node->setSleepOrWait(request.getValueInt()); break;
+      case 31: _node->setRebootPin(request.getValueInt()); break;
+      case 32: _node->setADCOff(); break;
+      case 36: _node->setReportIntervalSeconds(request.getValueInt()); break;
+      case 37: _node->setReportIntervalMinutes(request.getValueInt()); break;
+      case 38: _node->setReportIntervalHours(request.getValueInt()); break;
+      case 39: _node->setReportIntervalDays(request.getValueInt()); break;
+      default: return; 
+    }
+  // the request is for a sensor
+  } else {
+    // retrieve the sensor the child is belonging to
+    Sensor* sensor = _node->getSensorWithChild(child_id);
+    if (sensor == nullptr) return;
+    // if the message is for a function common to all the sensors
+    if (request.getFunction() < 100) {
+      switch(function) {
+        case 1: sensor->setPin(request.getValueInt()); break;
+        case 5: sensor->setSamples(request.getValueInt()); break;
+        case 6: sensor->setSamplesInterval(request.getValueInt()); break;
+        case 7: sensor->setTrackLastValue(request.getValueInt()); break;
+        case 9: sensor->setForceUpdateMinutes(request.getValueInt()); break;
+        case 13: sensor->powerOn(); break;
+        case 14: sensor->powerOff(); break;
+        case 16: sensor->setReportIntervalMinutes(request.getValueInt()); break;
+        case 17: sensor->setReportIntervalSeconds(request.getValueInt()); break;
+        case 19: sensor->setReportIntervalHours(request.getValueInt()); break;
+        case 20: sensor->setReportIntervalDays(request.getValueInt()); break;
+        default: return;
+      }
+    } else {
+      // the message is for a function specific to a sensor
+      if (strcmp(sensor->getName(),"BAT") == 0) {
+        SensorBattery* custom_sensor = (SensorBattery*)sensor;
+        switch(function) {
+          case 102: custom_sensor->setMinVoltage(request.getValueFloat()); break;
+          case 103: custom_sensor->setMaxVoltage(request.getValueFloat()); break;
+          case 104: custom_sensor->setBatteryInternalVcc(request.getValueInt()); break;
+          case 105: custom_sensor->setBatteryPin(request.getValueInt()); break;
+          case 106: custom_sensor->setBatteryVoltsPerBit(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      if (strcmp(sensor->getName(),"SIG") == 0) {
+        SensorSignal* custom_sensor = (SensorSignal*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setSignalCommand(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #if MODULE_SHT21 == 1
+      if (strcmp(sensor->getName(),"SHT21") == 0 || strcmp(sensor->getName(),"HTU21") == 0) {
+        SensorSHT21* custom_sensor = (SensorSHT21*)sensor;
+        switch(function) {
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_ANALOG_INPUT == 1
+      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0 || strcmp(sensor->getName(),"RAIN") == 0 || strcmp(sensor->getName(),"SOIL") == 0) {
+        SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setReference(request.getValueInt()); break;
+          case 102: custom_sensor->setReverse(request.getValueInt()); break;
+          case 103: custom_sensor->setOutputPercentage(request.getValueInt()); break;
+          case 104: custom_sensor->setRangeMin(request.getValueInt()); break;
+          case 105: custom_sensor->setRangeMax(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_THERMISTOR == 1
+      if (strcmp(sensor->getName(),"THER") == 0) {
+        SensorThermistor* custom_sensor = (SensorThermistor*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setNominalResistor((long)request.getValueInt()); break;
+          case 102: custom_sensor->setNominalTemperature(request.getValueInt()); break;
+          case 103: custom_sensor->setBCoefficient(request.getValueInt()); break;
+          case 104: custom_sensor->setSeriesResistor((long)request.getValueInt()); break;
+          case 105: custom_sensor->setOffset(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_ACS712 == 1
+      if (strcmp(sensor->getName(),"ACS") == 0) {
+        SensorACS712* custom_sensor = (SensorACS712*)sensor;
+        switch(function) {
+          case 100: custom_sensor->setmVPerAmp(request.getValueInt()); break;
+          case 102: custom_sensor->setOffset(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_DIGITAL_OUTPUT == 1
+      if (strcmp(sensor->getName(),"DOUT") == 0 || strcmp(sensor->getName(),"REL") == 0 || strcmp(sensor->getName(),"LATC") == 0) {
+        SensorDigitalOutput* custom_sensor = (SensorDigitalOutput*)sensor;
+        switch(function) {
+            case 103: custom_sensor->setOnValue(request.getValueInt()); break;
+            case 104: custom_sensor->setLegacyMode(request.getValueInt()); break;
+            case 105: custom_sensor->setSafeguard(request.getValueInt()); break;
+            case 106: custom_sensor->setInputIsElapsed(request.getValueInt()); break;
+            case 107: custom_sensor->setWaitAfterSet(request.getValueInt()); break;
+          default: return;
+        }
+        if (function > 200 && strcmp(sensor->getName(),"LATC") == 0) {
+          SensorLatchingRelay* custom_sensor_2 = (SensorLatchingRelay*)sensor;
+          switch(function) {
+            case 201: custom_sensor_2->setPulseWidth(request.getValueInt()); break;
+            case 202: custom_sensor_2->setPinOff(request.getValueInt()); break;
+            case 203: custom_sensor_2->setPinOn(request.getValueInt()); break;
+          default: return;
+        }
+        }
+      }
+      #endif
+      #if MODULE_SWITCH == 1
+      if (strcmp(sensor->getName(),"SWITCH") == 0 || strcmp(sensor->getName(),"DOOR") == 0 || strcmp(sensor->getName(),"MOTION") == 0) {
+        SensorSwitch* custom_sensor = (SensorSwitch*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setMode(request.getValueInt()); break;
+          case 102: custom_sensor->setDebounce(request.getValueInt()); break;
+          case 103: custom_sensor->setTriggerTime(request.getValueInt()); break;
+          case 104: custom_sensor->setInitial(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_DS18B20 == 1
+      if (strcmp(sensor->getName(),"DS18B20") == 0) {
+        SensorDs18b20* custom_sensor = (SensorDs18b20*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setResolution(request.getValueInt()); break;
+          case 102: custom_sensor->setSleepDuringConversion(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_BH1750 == 1
+      if (strcmp(sensor->getName(),"BH1750") == 0) {
+        SensorBH1750* custom_sensor = (SensorBH1750*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setMode(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
+      if (strcmp(sensor->getName(),"BME280") == 0) {
+        SensorBosch* custom_sensor = (SensorBosch*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setForecastSamplesCount(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_SONOFF == 1
+      if (strcmp(sensor->getName(),"SONOFF") == 0) {
+        SensorSonoff* custom_sensor = (SensorSonoff*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setButtonPin(request.getValueInt()); break;
+          case 102: custom_sensor->setRelayPin(request.getValueInt()); break;
+          case 103: custom_sensor->setLedPin(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_HCSR04 == 1
+      if (strcmp(sensor->getName(),"HCSR04") == 0) {
+        SensorHCSR04* custom_sensor = (SensorHCSR04*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setTriggerPin(request.getValueInt()); break;
+          case 102: custom_sensor->setEchoPin(request.getValueInt()); break;
+          case 103: custom_sensor->setMaxDistance(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_MQ == 1
+      if (strcmp(sensor->getName(),"MQ") == 0) {
+        SensorMQ* custom_sensor = (SensorMQ*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setTargetGas(request.getValueInt()); break;
+          case 102: custom_sensor->setRlValue(request.getValueFloat()); break;
+          case 103: custom_sensor->setRoValue(request.getValueFloat()); break;
+          case 104: custom_sensor->setCleanAirFactor(request.getValueFloat()); break;
+          case 105: custom_sensor->setCalibrationSampleTimes(request.getValueInt()); break;
+          case 106: custom_sensor->setCalibrationSampleInterval(request.getValueInt()); break;
+          case 107: custom_sensor->setReadSampleTimes(request.getValueInt()); break;
+          case 108: custom_sensor->setReadSampleInterval(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_TSL2561 == 1
+      if (strcmp(sensor->getName(),"TSL2561") == 0) {
+        SensorTSL2561* custom_sensor = (SensorTSL2561*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setGain(request.getValueInt()); break;
+          case 102: custom_sensor->setTiming(request.getValueInt()); break;
+          case 103: custom_sensor->setSpectrum(request.getValueInt()); break;
+          case 104: custom_sensor->setAddress(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if MODULE_PT100 == 1
+      if (strcmp(sensor->getName(),"PT100") == 0) {
+        SensorPT100* custom_sensor = (SensorPT100*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setVoltageRef(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      #endif
+    }
+  }
+  _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
+}
+
+// what to do when receiving an interrupt
+void SensorConfiguration::onInterrupt() {
+}
+
+
+#if MODULE_ANALOG_INPUT == 1
+/*
+   SensorAnalogInput
+*/
+
+// contructor
+SensorAnalogInput::SensorAnalogInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "A-IN";
+}
+
+// setter/getter
+void SensorAnalogInput::setReference(int value) {
+  _reference = value;
+}
+void SensorAnalogInput::setReverse(bool value) {
+  _reverse = value;
+}
+void SensorAnalogInput::setOutputPercentage(bool value) {
+  _output_percentage = value;
+}
+void SensorAnalogInput::setRangeMin(int value) {
+  _range_min = value;
+}
+void SensorAnalogInput::setRangeMax(int value) {
+  _range_max = value;
+}
+
+// what to do during before
+void SensorAnalogInput::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorAnalogInput::onSetup() {
+  // prepare the pin for input
+  pinMode(_pin, INPUT);
+}
+
+// what to do during loop
+void SensorAnalogInput::onLoop(Child* child) {
+  // read the input
+  int adc = _getAnalogRead();
+  // calculate the percentage
+  int percentage = 0;
+  if (_output_percentage) percentage = _getPercentage(adc);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.print(adc);
+    Serial.print(F(" %="));
+    Serial.println(percentage);
+  #endif
+  // store the result
+  ((ChildInt*)child)->setValueInt(_output_percentage ? percentage : adc);
+}
+
+// what to do during loop
+void SensorAnalogInput::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorAnalogInput::onInterrupt() {
+}
+
+// read the analog input
+int SensorAnalogInput::_getAnalogRead() {
+  #ifndef MY_GATEWAY_ESP8266
+    // set the reference
+    if (_reference != -1) {
+      analogReference(_reference);
+      wait(100);
+    }
+  #endif
+  // read and return the value
+  int value = analogRead(_pin);
+  if (_reverse) value = _range_max - value;
+  return value;
+}
+
+// return a percentage from an analog value
+int SensorAnalogInput::_getPercentage(int adc) {
+  float value = (float)adc;
+  // restore the original value
+  if (_reverse) value = 1024 - value;
+  // scale the percentage based on the range provided
+  float percentage = ((value - _range_min) / (_range_max - _range_min)) * 100;
+  if (_reverse) percentage = 100 - percentage;
+  if (percentage > 100) percentage = 100;
+  if (percentage < 0) percentage = 0;
+  return (int)percentage;
+}
+
+/*
+   SensorLDR
+*/
+
+// contructor
+SensorLDR::SensorLDR(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "LDR";
+}
+
+// what to do during before
+void SensorLDR::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
+}
+
+// what to do during setup
+void SensorLDR::onSetup() {
+  setReverse(true);
+}
+
+/*
+   SensorRain
+*/
+
+// contructor
+SensorRain::SensorRain(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "RAIN";
+}
+
+// what to do during before
+void SensorRain::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_RAIN,V_RAINRATE);
+}
+
+// what to do during setup
+void SensorRain::onSetup() {
+  setReference(DEFAULT);
+  setOutputPercentage(true);
+  setReverse(true);
+  setRangeMin(100);
+}
+
+/*
+   SensorSoilMoisture
+*/
+
+// contructor
+SensorSoilMoisture::SensorSoilMoisture(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "SOIL";
+}
+
+// what to do during before
+void SensorSoilMoisture::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_MOISTURE,V_LEVEL);
+}
+
+// what to do during setup
+void SensorSoilMoisture::onSetup() {
+  setReverse(true);
+  setReference(DEFAULT);
+  setOutputPercentage(true);
+  setReverse(true);
+  setRangeMin(100);
+}
+#endif
+
+#if MODULE_THERMISTOR == 1
+/*
+   SensorThermistor
+*/
+
+// contructor
+SensorThermistor::SensorThermistor(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "THER";
+}
+
+// setter/getter
+void SensorThermistor::setNominalResistor(long value) {
+  _nominal_resistor = value;
+}
+void SensorThermistor::setNominalTemperature(int value) {
+  _nominal_temperature = value;
+}
+void SensorThermistor::setBCoefficient(int value) {
+  _b_coefficient = value;
+}
+void SensorThermistor::setSeriesResistor(long value) {
+  _series_resistor = value;
+}
+void SensorThermistor::setOffset(float value) {
+  _offset = value;
+}
+
+// what to do during before
+void SensorThermistor::onBefore() {
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+}
+
+// what to do during setup
+void SensorThermistor::onSetup() {
+  // set the pin as input
+  pinMode(_pin, INPUT);
+}
+
+// what to do during loop
+void SensorThermistor::onLoop(Child* child) {
+  // read the voltage across the thermistor
+  float adc = analogRead(_pin);
+  // calculate the temperature
+  float reading = (1023 / adc)  - 1;
+  reading = _series_resistor / reading;
+  float temperature;
+  temperature = reading / _nominal_resistor;     // (R/Ro)
+  temperature = log(temperature);                  // ln(R/Ro)
+  temperature /= _b_coefficient;                   // 1/B * ln(R/Ro)
+  temperature += 1.0 / (_nominal_temperature + 273.15); // + (1/To)
+  temperature = 1.0 / temperature;                 // Invert
+  temperature -= 273.15;                         // convert to C
+  temperature = _node->celsiusToFahrenheit(temperature);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.print(adc);
+    Serial.print(F(" T="));
+    Serial.println(temperature);
+  #endif
+  // store the value
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+}
+
+// what to do as the main task when receiving a message
+void SensorThermistor::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorThermistor::onInterrupt() {
+}
+#endif
+
+#if MODULE_ML8511 == 1
+/*
+   SensorML8511
+*/
+
+// contructor
+SensorML8511::SensorML8511(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "UV";
+}
+
+// what to do during before
+void SensorML8511::onBefore() {
+  new ChildFloat(this,_node->getAvailableChildId(),S_UV,V_UV);
+}
+
+// what to do during setup
+void SensorML8511::onSetup() {
+  // set the pin as input
+  pinMode(_pin, INPUT);
+}
+
+// what to do during loop
+void SensorML8511::onLoop(Child* child) {
+  // read the voltage 
+  int uvLevel = analogRead(_pin);
+  int refLevel = _node->getVcc()*1024/3.3;
+  //Use the 3.3V power pin as a reference to get a very accurate output value from sensor
+  float outputVoltage = 3.3 / refLevel * uvLevel;
+  //Convert the voltage to a UV intensity level
+  float uvIntensity = _mapfloat(outputVoltage, 0.99, 2.8, 0.0, 15.0); 
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.print(outputVoltage);
+    Serial.print(F(" I="));
+    Serial.println(uvIntensity);
+  #endif
+  // store the value
+  ((ChildFloat*)child)->setValueFloat(uvIntensity);
+}
+
+// what to do as the main task when receiving a message
+void SensorML8511::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorML8511::onInterrupt() {
+}
+
+// The Arduino Map function but for floats
+float SensorML8511::_mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+#endif
+
+#if MODULE_ACS712 == 1
+/*
+   SensorACS712
+*/
+
+// contructor
+SensorACS712::SensorACS712(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "ACS";
+}
+
+// setter/getter
+void SensorACS712::setmVPerAmp(int value) {
+  _mv_per_amp = value;
+}
+void SensorACS712::setOffset(int value) {
+  _ACS_offset = value;
+}
+
+// what to do during before
+void SensorACS712::onBefore() {
+  new ChildFloat(this,_node->getAvailableChildId(),S_MULTIMETER,V_CURRENT);
+}
+
+// what to do during setup
+void SensorACS712::onSetup() {
+  // set the pin as input
+  pinMode(_pin, INPUT);
+}
+
+// what to do during loop
+void SensorACS712::onLoop(Child* child) {
+  int value = analogRead(_pin);
+  // convert the analog read in mV
+  double voltage = (value / 1024.0) * 5000; 
+  // convert voltage in amps
+  float value_float = ((voltage - _ACS_offset) / _mv_per_amp);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" A="));
+    Serial.println(value_float);
+  #endif
+  ((ChildFloat*)child)->setValueFloat(value_float);
+}
+
+// what to do as the main task when receiving a message
+void SensorACS712::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorACS712::onInterrupt() {
+}
+#endif
+
+#if MODULE_DIGITAL_INPUT == 1
+/*
+   SensorDigitalInput
+*/
+
+// contructor
+SensorDigitalInput::SensorDigitalInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "D-IN";
+}
+
+// what to do during before
+void SensorDigitalInput::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorDigitalInput::onSetup() {
+  // set the pin for input
+  pinMode(_pin, INPUT);
+}
+
+// what to do during loop
+void SensorDigitalInput::onLoop(Child* child) {
+  // read the value
+  int value = digitalRead(_pin);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" P="));
+    Serial.print(_pin);
+    Serial.print(F(" V="));
+    Serial.println(value);
+  #endif
+  // store the value
+  ((ChildInt*)child)->setValueInt(value);
+}
+
+// what to do as the main task when receiving a message
+void SensorDigitalInput::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorDigitalInput::onInterrupt() {
+}
+#endif
+
+
+#if MODULE_DIGITAL_OUTPUT == 1
+/*
+   SensorDigitalOutput
+*/
+
+SensorDigitalOutput::SensorDigitalOutput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DOUT";
+}
+
+// what to do during before
+void SensorDigitalOutput::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorDigitalOutput::onSetup() {
+  _setupPin(children.get(1), _pin);
+  _safeguard_timer = new Timer(_node);
+}
+
+// setter/getter
+void SensorDigitalOutput::setOnValue(int value) {
+  _on_value = value;
+}
+void SensorDigitalOutput::setLegacyMode(bool value) {
+  _legacy_mode = value;
+}
+void SensorDigitalOutput::setSafeguard(int value) {
+  _safeguard_timer->set(value,MINUTES);
+}
+int SensorDigitalOutput::getStatus() {
+  return _status;
+}
+void SensorDigitalOutput::setInputIsElapsed(bool value) {
+  _input_is_elapsed = value;
+}
+void SensorDigitalOutput::setWaitAfterSet(int value) {
+  _wait_after_set = value;
+}
+
+// main task
+void SensorDigitalOutput::onLoop(Child* child) {
+  // set the value to -1 so to avoid reporting to the gateway during loop
+  ((ChildInt*)child)->setValueInt(-1);
+  // if a safeguard is set, check if it is time for it
+  if (_safeguard_timer->isRunning()) {
+    // update the timer
+    _safeguard_timer->update();
+    // if the time is over, turn the output off
+    if (_safeguard_timer->isOver()) setStatus(child->child_id,OFF);
+  }
+}
+
+// what to do as the main task when receiving a message
+void SensorDigitalOutput::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  // by default handle a SET message but when legacy mode is set when a REQ message is expected instead
+  if ( (message->getCommand() == C_SET && ! _legacy_mode) || (message->getCommand() == C_REQ && _legacy_mode)) {
+    // switch the output
+    setStatus(child, message->getInt());
+  }
+  if (message->getCommand() == C_REQ && ! _legacy_mode) {
+    // just return the current status
+    ((ChildInt*)child)->setValueInt(_status);
+  }
+}
+
+// what to do when receiving an interrupt
+void SensorDigitalOutput::onInterrupt() {
+}
+
+// write the value to the output
+void SensorDigitalOutput::setStatus(Child* child, int value) {
+  // pre-process the input value
+  if (_input_is_elapsed) {
+    // the input provided is an elapsed time
+    if (value == OFF) {
+      // turning it off, no need for a safeguard anymore, stop the timer
+      _safeguard_timer->stop();
+    } 
+    else if (value == ON) {
+      // configure and start the timer
+      _safeguard_timer->start(value,MINUTES);
+      // if the input is an elapsed time, unless the value is OFF, the output will be always ON
+      value = ON;
+    }
+  } else {
+    // if turning the output on and a safeguard timer is configured, start it
+    if (value == ON && _safeguard_timer->isConfigured() && ! _safeguard_timer->isRunning()) _safeguard_timer->start();
+  }
+  _setStatus(child, value);
+  // wait if needed for relay drawing a lot of current
+  if (_wait_after_set > 0) _node->sleepOrWait(_wait_after_set);
+  // store the new status so it will be sent to the controller
+  _status = value;
+  ((ChildInt*)child)->setValueInt(value);
+}
+
+// setup the provided pin for output
+void SensorDigitalOutput::_setupPin(Child* child, int pin) {
+  // set the pin as output and initialize it accordingly
+  pinMode(pin, OUTPUT);
+  // setup the pin in a off status
+  _status = ! _on_value;
+  digitalWrite(pin, _status);
+  // the initial value is now the current value
+  ((ChildInt*)child)->setValueInt(_status);
+}
+
+// switch to the requested status
+void SensorDigitalOutput::_setStatus(Child* child, int value) {
+  int value_to_write = _getValueToWrite(value);
+  // set the value to the pin
+  digitalWrite(_pin, value_to_write);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" P="));
+    Serial.print(_pin);
+    Serial.print(F(" V="));
+    Serial.println(value_to_write);
+  #endif
+}
+
+// reverse the value if needed based on the _on_value
+int SensorDigitalOutput::_getValueToWrite(int value) {
+  int value_to_write = value;
+  if (_on_value == LOW) {
+    // if the "on" value is LOW, reverse the value
+    if (value == ON) value_to_write = LOW;
+    if (value == OFF) value_to_write = HIGH;
+  }
+  return value_to_write;
+}
+
+/*
+   SensorRelay
+*/
+
+// contructor
+SensorRelay::SensorRelay(const NodeManager& node_manager, int pin): SensorDigitalOutput(node_manager, pin) {
+  _name = "REL";
+}
+
+// what to do during before
+void SensorRelay::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
+}
+
+/*
+   SensorLatchingRelay
+*/
+
+// contructor
+SensorLatchingRelay::SensorLatchingRelay(const NodeManager& node_manager, int pin): SensorRelay(node_manager, pin) {
+  // set the "off" pin to the provided pin and the "on" pin to the provided pin + 1
+  _pin_on = pin;
+  _pin_off = pin + 1;
+}
+
+// setter/getter
+void SensorLatchingRelay::setPulseWidth(int value) {
+  _pulse_width = value;
+}
+void SensorLatchingRelay::setPinOn(int value) {
+  _pin_on = value;
+}
+void SensorLatchingRelay::setPinOff(int value) {
+  _pin_off = value;
+}
+
+// what to do during before
+void SensorLatchingRelay::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
+}
+
+// what to do during setup
+void SensorLatchingRelay::onSetup() {
+  _setupPin(children.get(1),_pin_on);
+  _setupPin(children.get(1),_pin_off);
+}
+
+// switch to the requested status
+void SensorLatchingRelay::_setStatus(Child* child, int value) {
+  // select the right pin to send the pulse to
+  int pin = value == OFF ? _pin_off : _pin_on;
+  // set the value
+  digitalWrite(pin, _on_value);
+  // wait for the given time before restoring the value to the original value after the pulse
+  _node->sleepOrWait(_pulse_width);
+  digitalWrite(pin, ! _on_value);
+  #if DEBUG == 1
+    Serial.print(F("LAT I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" P="));
+    Serial.print(pin);
+    Serial.print(F(" S="));
+    Serial.print(value);
+    Serial.print(F(" V="));
+    Serial.print(_on_value);
+    Serial.print(F(" P="));
+    Serial.println(_pulse_width);
+  #endif
+}
+
+#endif
+
+#if MODULE_DHT == 1
+/*
+   SensorDHT
+*/
+
+// contructor
+SensorDHT::SensorDHT(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DHT";
+  _dht_type = DHT::DHT11;
+}
+
+// what to do during before
+void SensorDHT::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+}
+
+// what to do during setup
+void SensorDHT::onSetup() {
+  // store the dht object
+  _dht = new DHT();
+  // initialize the dht library
+  _dht->setup(_pin,_dht_type);
+}
+
+// what to do during loop
+void SensorDHT::onLoop(Child* child) {
+  _node->sleepOrWait(_dht->getMinimumSamplingPeriod());
+  _dht->readSensor(true);
+  // temperature sensor
+  if (child->type == V_TEMP) {
+    // read the temperature
+    float temperature = _dht->getTemperature();
+    if (! _node->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  }
+  // humidity sensor
+  else if (child->type == V_HUM) {
+    // read humidity
+    float humidity = _dht->getHumidity();
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" H="));
+      Serial.println(humidity);
+    #endif
+    // store the value
+    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+  }
+}
+
+// what to do as the main task when receiving a message
+void SensorDHT::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorDHT::onInterrupt() {
+}
+
+/*
+   SensorDHT11
+*/
+
+// contructor
+SensorDHT11::SensorDHT11(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
+  _name = "DHT11";
+  _dht_type = DHT::DHT11;
+}
+
+/*
+   SensorDHT11
+*/
+
+// contructor
+SensorDHT22::SensorDHT22(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
+  _name = "DHT22";
+  _dht_type = DHT::DHT22;
+}
+#endif
+
+/*
+   SensorSHT21
+*/
+#if MODULE_SHT21 == 1
+// contructor
+SensorSHT21::SensorSHT21(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "SHT21";
+}
+
+// what to do during before
+void SensorSHT21::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+}
+
+// what to do during setup
+void SensorSHT21::onSetup() {
+  // initialize the library
+  Wire.begin();
+}
+
+// what to do during loop
+void SensorSHT21::onLoop(Child* child) {
+  // temperature sensor
+  if (child->type == V_TEMP) {
+    // read the temperature
+    float temperature = SHT2x.GetTemperature();
+    // convert it
+    temperature = _node->celsiusToFahrenheit(temperature);
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  }
+  // Humidity Sensor
+  else if (child->type == V_HUM) {
+    // read humidity
+    float humidity = SHT2x.GetHumidity();
+    if (isnan(humidity)) return;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" H="));
+      Serial.println(humidity);
+    #endif
+    // store the value
+   if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+  }
+}
+
+// what to do as the main task when receiving a message
+void SensorSHT21::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorSHT21::onInterrupt() {
+}
+
+/*
+ * SensorHTU21D
+ */
+ // constructor
+SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
+  _name = "HTU21";
+}
+#endif 
+
+#if MODULE_SWITCH == 1
+/*
+ * SensorSwitch
+ */
+SensorSwitch::SensorSwitch(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "SWITCH";
+}
+
+// setter/getter
+void SensorSwitch::setMode(int value) {
+  _mode = value;
+}
+void SensorSwitch::setDebounce(int value) {
+  _debounce = value;
+}
+void SensorSwitch::setTriggerTime(int value) {
+  _trigger_time = value;
+}
+void SensorSwitch::setInitial(int value) {
+  _initial = value;
+}
+
+// what to do during before
+void SensorSwitch::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_TRIPPED);
+}
+
+// what to do during setup
+void SensorSwitch::onSetup() {
+  // set the interrupt pin so it will be called only when waking up from that interrupt
+  setInterrupt(_pin,_mode,_initial);
+  // report immediately
+  _report_timer->unset();
+}
+
+// what to do during loop
+void SensorSwitch::onLoop(Child* child) {
+}
+
+// what to do as the main task when receiving a message
+void SensorSwitch::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == V_STATUS) {
+    // return current status
+    ((ChildInt*)child)->setValueInt(digitalRead(_pin));
+  }
+}
+
+// what to do when receiving an interrupt
+void SensorSwitch::onInterrupt() {
+  Child* child = children.get(1);
+  // wait to ensure the the input is not floating
+  if (_debounce > 0) _node->sleepOrWait(_debounce);
+  // read the value of the pin
+  int value = digitalRead(_pin);
+  // process the value
+  if ( (_mode == RISING && value == HIGH ) || (_mode == FALLING && value == LOW) || (_mode == CHANGE) )  {
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" P="));
+      Serial.print(_pin);
+      Serial.print(F(" V="));
+      Serial.println(value);
+    #endif
+    ((ChildInt*)child)->setValueInt(value);
+    // allow the signal to be restored to its normal value
+    if (_trigger_time > 0) _node->sleepOrWait(_trigger_time);
+  } else {
+    // invalid
+    ((ChildInt*)child)->setValueInt(-1);
+  }
+}
+
+/*
+ * SensorDoor
+ */
+SensorDoor::SensorDoor(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
+  _name = "DOOR";
+}
+
+// what to do during before
+void SensorDoor::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_DOOR,V_TRIPPED);
+}
+
+/*
+ * SensorMotion
+ */
+SensorMotion::SensorMotion(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
+  _name = "MOTION";
+}
+
+// what to do during before
+void SensorMotion::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_MOTION,V_TRIPPED);
+}
+
+// what to do during setup
+void SensorMotion::onSetup() {
+  // set initial value to LOW
+  setInitial(LOW);
+}
+#endif
+
+/*
+   SensorDs18b20
+*/
+#if MODULE_DS18B20 == 1
+// contructor
+SensorDs18b20::SensorDs18b20(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DS18B20";
+}
+
+// what to do during before
+void SensorDs18b20::onBefore() {
+  // initialize the library
+  OneWire* oneWire = new OneWire(_pin);
+  DallasTemperature* _sensors = new DallasTemperature(oneWire);
+  // initialize the sensors
+  _sensors->begin();
+  // register a new child for each sensor on the bus
+  for(int i = 0; i < _sensors->getDeviceCount(); i++) {
+    new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  }
+}
+
+// what to do during setup
+void SensorDs18b20::onSetup() {
+}
+
+// what to do during loop
+void SensorDs18b20::onLoop(Child* child) {
+  int index = -1;
+  // get the index of the requested child
+  for (int i = 1; i <= children.size(); i++) {
+    if (children.get(i) == child) index = i-1;
+  }
+  // do not wait for conversion, will sleep manually during it
+  if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
+  // request the temperature
+  _sensors->requestTemperatures();
+  if (_sleep_during_conversion) {
+    // calculate conversion time and sleep
+    int16_t conversion_time = _sensors->millisToWaitForConversion(_sensors->getResolution());
+    sleep(conversion_time);
+  }
+  // read the temperature
+  float temperature = _sensors->getTempCByIndex(index);
+  // convert it
+  temperature = _node->celsiusToFahrenheit(temperature);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" T="));
+    Serial.println(temperature);
+  #endif
+  // store the value
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+}
+
+// what to do as the main task when receiving a message
+void SensorDs18b20::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorDs18b20::onInterrupt() {
+}
+
+// returns the sensor's resolution in bits
+int SensorDs18b20::getResolution() {
+  return _sensors->getResolution();
+}
+
+// set the sensor's resolution in bits
+void SensorDs18b20::setResolution(int value) {
+  _sensors->setResolution(value);
+}
+
+// sleep while DS18B20 calculates temperature
+void SensorDs18b20::setSleepDuringConversion(bool value) {
+   _sleep_during_conversion = value;
+}
+
+#endif
+
+/*
+   SensorBH1750
+*/
+#if MODULE_BH1750 == 1
+// contructor
+SensorBH1750::SensorBH1750(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "BH1750";
+}
+// setter/getter
+void SensorBH1750::setMode(uint8_t mode) {
+  _lightSensor->configure(mode);
+}
+
+// what to do during before
+void SensorBH1750::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
+}
+
+// what to do during setup
+void SensorBH1750::onSetup() {
+  _lightSensor = new BH1750();
+  _lightSensor->begin();
+}
+
+// what to do during loop
+void SensorBH1750::onLoop(Child* child) {
+  // request the light level
+  int value = _lightSensor->readLightLevel();
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" L="));
+    Serial.println(value);
+  #endif
+  ((ChildInt*)child)->setValueInt(value);
+}
+
+// what to do as the main task when receiving a message
+void SensorBH1750::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorBH1750::onInterrupt() {
+}
+#endif
+
+/*
+   SensorMLX90614
+*/
+#if MODULE_MLX90614 == 1
+// contructor
+SensorMLX90614::SensorMLX90614(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "MLX90614";
+}
+
+// what to do during before
+void SensorMLX90614::onBefore() {
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+}
+
+// what to do during setup
+void SensorMLX90614::onSetup() {
+  // initialize the library
+  _mlx = new Adafruit_MLX90614();
+  _mlx->begin();
+}
+
+// what to do during loop
+void SensorMLX90614::onLoop(Child* child) {
+  float temperature;
+  // the first child is the ambient temperature, the second the object temperature
+  if (children.get(1) == child) temperature = _mlx->readAmbientTempC();
+  else temperature = _mlx->readObjectTempC();
+  // convert it
+  temperature = _node->celsiusToFahrenheit(temperature);
+  #if DEBUG == 1
+    Serial.print(F("MLX I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" T="));
+    Serial.println(temperature);
+  #endif
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+}
+
+// what to do as the main task when receiving a message
+void SensorMLX90614::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorMLX90614::onInterrupt() {
+}
+#endif
+
+
+/*
+   SensorBosch
+*/
+#if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
+// contructor
+SensorBosch::SensorBosch(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "BOSH";
+}
+
+// setter/getter
+void SensorBosch::setForecastSamplesCount(int value) {
+  _forecast_samples_count = value;
+}
+
+// what to do during before
+void SensorBosch::onBefore() {
+}
+
+// what to do during setup
+void SensorBosch::onSetup() {
+  // initialize the forecast samples array
+  _forecast_samples = new float[_forecast_samples_count];
+}
+
+// what to do during loop
+void SensorBosch::onLoop(Child* child) {
+}
+
+// what to do as the main task when receiving a message
+void SensorBosch::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorBosch::onInterrupt() {
+}
+
+// calculate and send the forecast back
+char* SensorBosch::_forecast(float pressure) {
+  if (isnan(pressure)) return;
+  // Calculate the average of the last n minutes.
+  int index = _minute_count % _forecast_samples_count;
+  _forecast_samples[index] = pressure;
+  _minute_count++;
+  if (_minute_count > 185) _minute_count = 6;
+  if (_minute_count == 5) _pressure_avg = _getLastPressureSamplesAverage();
+  else if (_minute_count == 35) {
+    float last_pressure_avg = _getLastPressureSamplesAverage();
+    float change = (last_pressure_avg - _pressure_avg) * 0.1;
+    // first time initial 3 hour
+    if (_first_round) _dP_dt = change * 2; // note this is for t = 0.5hour
+    else _dP_dt = change / 1.5; // divide by 1.5 as this is the difference in time from 0 value.
+  }
+  else if (_minute_count == 65) {
+    float last_pressure_avg = _getLastPressureSamplesAverage();
+    float change = (last_pressure_avg - _pressure_avg) * 0.1;
+    //first time initial 3 hour
+    if (_first_round) _dP_dt = change; //note this is for t = 1 hour
+    else _dP_dt = change / 2; //divide by 2 as this is the difference in time from 0 value
+  }
+  else if (_minute_count == 95) {
+    float last_pressure_avg = _getLastPressureSamplesAverage();
+    float change = (last_pressure_avg - _pressure_avg) * 0.1;
+    // first time initial 3 hour
+    if (_first_round)_dP_dt = change / 1.5; // note this is for t = 1.5 hour
+    else _dP_dt = change / 2.5; // divide by 2.5 as this is the difference in time from 0 value
+  }
+  else if (_minute_count == 125) {
+    float last_pressure_avg = _getLastPressureSamplesAverage();
+    // store for later use.
+    _pressure_avg2 = last_pressure_avg; 
+    float change = (last_pressure_avg - _pressure_avg) * 0.1;
+    if (_first_round) _dP_dt = change / 2; // note this is for t = 2 hour
+    else _dP_dt = change / 3; // divide by 3 as this is the difference in time from 0 value
+  }
+  else if (_minute_count == 155) {
+    float last_pressure_avg = _getLastPressureSamplesAverage();
+    float change = (last_pressure_avg - _pressure_avg) * 0.1;
+    if (_first_round) _dP_dt = change / 2.5; // note this is for t = 2.5 hour
+    else _dP_dt = change / 3.5; // divide by 3.5 as this is the difference in time from 0 value
+  }
+  else if (_minute_count == 185) {
+    float last_pressure_avg = _getLastPressureSamplesAverage();
+    float change = (last_pressure_avg - _pressure_avg) * 0.1;
+    if (_first_round) _dP_dt = change / 3; // note this is for t = 3 hour
+    else _dP_dt = change / 4; // divide by 4 as this is the difference in time from 0 value
+  }
+  // Equating the pressure at 0 to the pressure at 2 hour after 3 hours have past.
+  _pressure_avg = _pressure_avg2; 
+  // flag to let you know that this is on the past 3 hour mark. Initialized to 0 outside main loop.
+  _first_round = false; 
+  // calculate the forecast (STABLE = 0, SUNNY = 1, CLOUDY = 2, UNSTABLE = 3, THUNDERSTORM = 4, UNKNOWN = 5)
+  int forecast = 5;
+  //if time is less than 35 min on the first 3 hour interval.
+  if (_minute_count < 35 && _first_round) forecast = 5;
+  else if (_dP_dt < (-0.25)) forecast = 5;
+  else if (_dP_dt > 0.25) forecast = 4;
+  else if ((_dP_dt > (-0.25)) && (_dP_dt < (-0.05))) forecast = 2;
+  else if ((_dP_dt > 0.05) && (_dP_dt < 0.25)) forecast = 1;
+  else if ((_dP_dt >(-0.05)) && (_dP_dt < 0.05)) forecast = 0;
+  else forecast = 5;
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" M="));
+    Serial.print(_minute_count);
+    Serial.print(F(" dP="));
+    Serial.print(_dP_dt);
+    Serial.print(F(" F="));
+    Serial.println(_weather[forecast]);
+  #endif
+  return _weather[forecast];
+}
+
+// returns the average of the latest pressure samples
+float SensorBosch::_getLastPressureSamplesAverage() {
+  float avg = 0;
+  for (int i = 0; i < _forecast_samples_count; i++) avg += _forecast_samples[i];
+  avg /= _forecast_samples_count;
+  return avg;
+}
+
+// search for a given chip on i2c bus
+uint8_t SensorBosch::GetI2CAddress(uint8_t chip_id) {
+  uint8_t addresses[] = {0x77, 0x76};
+  uint8_t register_address = 0xD0;
+  for (int i = 0; i <= sizeof(addresses); i++) { 
+    uint8_t i2c_address = addresses[i];
+    uint8_t value;
+    Wire.beginTransmission((uint8_t)i2c_address);
+    Wire.write((uint8_t)register_address);
+    Wire.endTransmission();
+    Wire.requestFrom((uint8_t)i2c_address, (byte)1);
+    value = Wire.read();
+    if (value == chip_id) {
+      #if DEBUG == 1
+        Serial.print(F("I2C=")); 
+        Serial.println(i2c_address);
+      #endif
+      return i2c_address;
+    }
+  }
+  return addresses[0]; 
+}
+#endif
+
+/*
+ * SensorBME280
+ */
+#if MODULE_BME280 == 1
+SensorBME280::SensorBME280(const NodeManager& node_manager): SensorBosch(node_manager) {
+  _name = "BME280";
+}
+
+// what to do during before
+void SensorBME280::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
+}
+
+void SensorBME280::onLoop(Child* child) {
+  // temperature sensor
+  if (child->type == V_TEMP) {
+    // read the temperature
+    float temperature = _bm->readTemperature();
+    // convert it
+    temperature = _node->celsiusToFahrenheit(temperature);
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  }
+  // Humidity Sensor
+  else if (child->type == V_HUM) {
+    // read humidity
+    float humidity = _bm->readHumidity();
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" H="));
+      Serial.println(humidity);
+    #endif
+    // store the value
+    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+  }
+  // Pressure Sensor
+  else if (child->type == V_PRESSURE) {
+    // read pressure
+    float pressure = _bm->readPressure() / 100.0F;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" P="));
+      Serial.println(pressure);
+    #endif
+    // store the value
+    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
+  }
+  // Forecast Sensor
+  else if (child->type == V_FORECAST) {
+    float pressure = _bm->readPressure() / 100.0F;
+    _forecast(pressure);
+  }
+}
+#endif
+
+/*
+   SensorBMP085
+*/
+#if MODULE_BMP085 == 1
+// contructor
+SensorBMP085::SensorBMP085(const NodeManager& node_manager): SensorBosch(node_manager) {
+  _name = "BMP085";
+}
+
+// what to do during before
+void SensorBMP085::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
+}
+
+// what to do during loop
+void SensorBMP085::onLoop(Child* child) {
+  // temperature sensor
+  if (child->type == V_TEMP) {
+    // read the temperature
+    float temperature = _bm->readTemperature();
+    // convert it
+    temperature = _node->celsiusToFahrenheit(temperature);
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  }
+  // Pressure Sensor
+  else if (child->type == V_PRESSURE) {
+    // read pressure
+    float pressure = _bm->readPressure() / 100.0F;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" P="));
+      Serial.println(pressure);
+    #endif
+    // store the value
+    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
+  }
+  // Forecast Sensor
+  else if (child->type == V_FORECAST) {
+    float pressure = _bm->readPressure() / 100.0F;
+    _forecast(pressure);
+  }
+}
+#endif
+
+/*
+ * SensorBMP280
+ */
+#if MODULE_BMP280 == 1
+SensorBMP280::SensorBMP280(const NodeManager& node_manager): SensorBosch(node_manager) {
+  _name = "BMP280";
+}
+
+  // what to do during before
+void SensorBMP280::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
+  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
+}
+
+void SensorBMP280::onLoop(Child* child) {
+  // temperature sensor
+  if (child->type == V_TEMP) {
+    // read the temperature
+    float temperature = _bm->readTemperature();
+    // convert it
+    temperature = _node->celsiusToFahrenheit(temperature);
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  }
+  // Pressure Sensor
+  else if (child->type == V_PRESSURE) {
+    // read pressure
+    float pressure = _bm->readPressure() / 100.0F;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" P="));
+      Serial.println(pressure);
+    #endif
+    // store the value
+    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
+  }
+  // Forecast Sensor
+  else if (child->type == V_FORECAST) {
+    float pressure = _bm->readPressure() / 100.0F;
+    _forecast(pressure);
+  }
+}
+#endif
+
+/*
+   SensorSonoff
+*/
+#if MODULE_SONOFF == 1
+// contructor
+SensorSonoff::SensorSonoff(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "SONOFF";
+} 
+
+// setter/getter
+void SensorSonoff::setButtonPin(int value) {
+    _button_pin = value;
+}
+void SensorSonoff::setRelayPin(int value) {
+    _relay_pin = value;
+}
+void SensorSonoff::setLedPin(int value) {
+    _led_pin = value;
+}
+
+// what to do during before
+void SensorSonoff::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
+}
+
+// what to do during setup
+void SensorSonoff::onSetup() {
+  // Setup the button
+  pinMode(_button_pin, INPUT_PULLUP);
+  // After setting up the button, setup debouncer
+  _debouncer.attach(_button_pin);
+  _debouncer.interval(5);
+  // Make sure relays and LED are off when starting up
+  digitalWrite(_relay_pin, _relay_off);
+  digitalWrite(_led_pin, _led_off);
+  // Then set relay pins in output mode
+  pinMode(_relay_pin, OUTPUT);
+  pinMode(_led_pin, OUTPUT);
+  _blink();
+}
+
+// what to do during loop
+void SensorSonoff::onLoop(Child* child) {
+  _debouncer.update();
+  // Get the update value from the button
+  int value = _debouncer.read();
+  if (value != _old_value && value == 0) {
+    // button pressed, toggle the state
+    _toggle(child);
+  }
+  _old_value = value;
+}
+
+// what to do as the main task when receiving a message
+void SensorSonoff::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_SET) {
+    // retrieve from the message the value to set
+    int value = message->getInt();
+    if (value != 0 && value != 1 || value == _state) return;
+    // toggle the state
+    _toggle(child);
+  }
+  if (message->getCommand() == C_REQ) {
+    // return the current state
+    ((ChildInt*)child)->setValueInt(_state);
+  }
+}
+
+// what to do when receiving an interrupt
+void SensorSonoff::onInterrupt() {
+}
+
+// toggle the state
+void SensorSonoff::_toggle(Child* child) {
+  // toggle the state
+  _state = _state ? false : true;
+  // Change relay state
+  digitalWrite(_relay_pin, _state? _relay_on: _relay_off);
+  // Change LED state
+  digitalWrite(_led_pin, _state? _led_on: _led_off);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.println(_state);
+  #endif
+  ((ChildInt*)child)->setValueInt(_state);
+}
+
+// blink the led
+void SensorSonoff::_blink() {
+  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
+  wait(200);
+  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
+  wait(200);
+  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
+  wait(200);
+  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
+}
+#endif
+
+/*
+   SensorHCSR04
+*/
+#if MODULE_HCSR04 == 1
+// contructor
+SensorHCSR04::SensorHCSR04(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "HCSR04";
+  _trigger_pin = pin;
+  _echo_pin = pin;
+}
+
+// setter/getter
+void SensorHCSR04::setTriggerPin(int value) {
+  _trigger_pin = value;
+}
+void SensorHCSR04::setEchoPin(int value) {
+  _echo_pin = value;
+}
+void SensorHCSR04::setMaxDistance(int value) {
+  _max_distance = value;
+}
+
+// what to do during before
+void SensorHCSR04::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_DISTANCE,V_DISTANCE);
+}
+
+// what to do during setup
+void SensorHCSR04::onSetup() {
+  // initialize the library
+  _sonar = new NewPing(_trigger_pin,_echo_pin,_max_distance);
+}
+
+// what to do during loop
+void SensorHCSR04::onLoop(Child* child) {
+  int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" D="));
+    Serial.println(distance);
+  #endif
+  ((ChildInt*)child)->setValueInt(distance);
+}
+
+// what to do as the main task when receiving a message
+void SensorHCSR04::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorHCSR04::onInterrupt() {
+}
+#endif
+
+/*
+   SensorMCP9808
+*/
+#if MODULE_MCP9808 == 1
+// contructor
+SensorMCP9808::SensorMCP9808(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "MCP9808";
+}
+
+// what to do during before
+void SensorMCP9808::onBefore() {
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+}
+
+// what to do during setup
+void SensorMCP9808::onSetup() {
+  _mcp = new Adafruit_MCP9808();
+}
+
+// what to do during loop
+void SensorMCP9808::onLoop(Child* child) {
+  float temperature = _mcp->readTempC();
+  // convert it
+  temperature = _node->celsiusToFahrenheit(temperature);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" T="));
+    Serial.println(temperature);
+  #endif
+  // store the value
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+}
+
+// what to do as the main task when receiving a message
+void SensorMCP9808::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorMCP9808::onInterrupt() {
+}
+#endif
+
+
+/*
+ * SensorMQ
+ */
+#if MODULE_MQ == 1
+
+static float SensorMQ::_default_LPGCurve[3] = {2.3,0.21,-0.47};
+static float SensorMQ::_default_COCurve[3] = {2.3,0.72,-0.34};
+static float SensorMQ::_default_SmokeCurve[3] = {2.3,0.53,-0.44};
+
+SensorMQ::SensorMQ(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "MQ";
+  _LPGCurve = SensorMQ::_default_LPGCurve;
+  _COCurve = SensorMQ::_default_COCurve;
+  _SmokeCurve = SensorMQ::_default_SmokeCurve;
+}
+
+//setter/getter
+void SensorMQ::setTargetGas(int value) {
+  _target_gas = value;
+}
+void SensorMQ::setRlValue(float value) {
+  _rl_value = value;
+}
+void SensorMQ::setRoValue(float value) {
+  _ro = value;
+}
+void SensorMQ::setCleanAirFactor(float value) {
+  _ro_clean_air_factor = value;
+}
+void SensorMQ::setCalibrationSampleTimes(int value) {
+  _calibration_sample_times = value;
+}
+void SensorMQ::setCalibrationSampleInterval(int value){
+  _calibration_sample_interval = value;
+}
+void SensorMQ::setReadSampleTimes(int value) {
+  _read_sample_times = value;
+}
+void SensorMQ::setReadSampleInterval(int value) {
+  _read_sample_interval = value;
+}
+void SensorMQ::setLPGCurve(float *value) {
+  _LPGCurve = value;
+}
+void SensorMQ::setCOCurve(float *value) {
+  _COCurve = value;
+}
+void SensorMQ::setSmokeCurve(float *value) {
+  _SmokeCurve = value;
+}
+
+// what to do during before
+void SensorMQ::onBefore() {
+  // prepare the pin for input
+  pinMode(_pin, INPUT);
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
+}
+
+// what to do during setup
+void SensorMQ::onSetup() {
+  _ro = _MQCalibration();
+}
+
+// what to do during loop
+void SensorMQ::onLoop(Child* child) {
+  // calculate rs/ro
+  float mq = _MQRead()/_ro;
+  // calculate the ppm
+  float lpg = _MQGetGasPercentage(mq,_gas_lpg);
+  float co = _MQGetGasPercentage(mq,_gas_co);
+  float smoke = _MQGetGasPercentage(mq,_gas_smoke);
+  // assign to the value the requested gas
+  uint16_t value;
+  if (_target_gas == _gas_lpg) value = lpg;
+  if (_target_gas == _gas_co) value = co;
+  if (_target_gas == _gas_smoke) value = smoke;
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.print(value);
+    Serial.print(F(" LPG="));
+    Serial.print(lpg);
+    Serial.print(F(" CO="));
+    Serial.print(co);
+    Serial.print(F(" SMOKE="));
+    Serial.println(smoke);
+  #endif
+  // store the value
+  ((ChildInt*)child)->setValueInt((int16_t)ceil(value));
+}
+
+// what to do as the main task when receiving a message
+void SensorMQ::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorMQ::onInterrupt() {
+}
+
+// returns the calculated sensor resistance
+float SensorMQ::_MQResistanceCalculation(int raw_adc) {
+  return ( ((float)_rl_value*(1023-raw_adc)/raw_adc));
+}
+
+//  This function assumes that the sensor is in clean air
+float SensorMQ::_MQCalibration() {
+  int i;
+  float val=0;
+  //take multiple samples
+  for (i=0; i< _calibration_sample_times; i++) {  
+    val += _MQResistanceCalculation(analogRead(_pin));
+    wait(_calibration_sample_interval);
+  }
+  //calculate the average value
+  val = val/_calibration_sample_times;                   
+  //divided by RO_CLEAN_AIR_FACTOR yields the Ro
+  val = val/_ro_clean_air_factor;
+  //according to the chart in the datasheet
+  return val;
+}
+
+// This function use MQResistanceCalculation to caculate the sensor resistenc (Rs).
+float SensorMQ::_MQRead() {
+  int i;
+  float rs=0;
+  for (i=0; i<_read_sample_times; i++) {
+    rs += _MQResistanceCalculation(analogRead(_pin));
+    wait(_read_sample_interval);
+  }
+  rs = rs/_read_sample_times;
+  return rs;
+}
+
+// This function passes different curves to the MQGetPercentage function which calculates the ppm (parts per million) of the target gas.
+int SensorMQ::_MQGetGasPercentage(float rs_ro_ratio, int gas_id) {
+  if ( gas_id == _gas_lpg ) {
+    return _MQGetPercentage(rs_ro_ratio,_LPGCurve);
+  } else if ( gas_id == _gas_co) {
+    return _MQGetPercentage(rs_ro_ratio,_COCurve);
+  } else if ( gas_id == _gas_smoke) {
+    return _MQGetPercentage(rs_ro_ratio,_SmokeCurve);
+  }
+  return 0;
+}
+
+// returns ppm of the target gas
+int SensorMQ::_MQGetPercentage(float rs_ro_ratio, float *pcurve) {
+  return (pow(10,( ((log10(rs_ro_ratio)-pcurve[1])/pcurve[2]) + pcurve[0])));
+}
+#endif
+
+
+
+/*
+   SensorMHZ19
+*/
+#if MODULE_MHZ19 == 1
+// contructor
+SensorMHZ19::SensorMHZ19(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "MHZ19";
+  _rx_pin = pin;
+  _tx_pin = pin+1;
+}
+
+// what to do during before
+void SensorMHZ19::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
+}
+
+// what to do during setup
+void SensorMHZ19::onSetup() {
+  _ser = new SoftwareSerial(_rx_pin, _tx_pin);
+  _ser->begin(9600);
+  delay(2000);
+  // clear CO2 buffer
+  while (_ser->read()!=-1) {};  
+}
+
+// what to do during loop
+void SensorMHZ19::onLoop(Child* child) {
+  // Read the ppm value
+  int co2ppm = _readCO2(); 
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" ppm="));
+    Serial.println(co2ppm);
+  #endif
+  // store the value
+  ((ChildInt*)child)->setValueInt(co2ppm);
+}
+
+
+// what to do as the main task when receiving a message
+void SensorMHZ19::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorMHZ19::onInterrupt() {
+}
+
+// Read out the CO2 data
+int SensorMHZ19::_readCO2() {
+  while (_ser->read() != -1) {};  //clear serial buffer
+  unsigned char response[9]; // for answer
+  byte cmd[9] = {0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79};
+  // Command to ask for data.
+  _ser->write(cmd, 9); //request PPM CO2
+  // Then for 1 second listen for 9 bytes of data.
+  _ser->readBytes(response, 9);
+  #if DEBUG == 1
+  for (int i=0; i<9; i++) {
+    Serial.print(response[i], HEX);
+    Serial.print(F("-"));
+  }
+  Serial.println(F("END"));
+  #endif
+  if (response[0] != 0xFF) {
+    Serial.println(F("ERR byte"));
+    return -1;
+  }
+  if (response[1] != 0x86) {
+    Serial.println(F("ERR command"));
+    return -1;
+  }
+  int responseHigh = (int) response[2];
+  int responseLow = (int) response[3];
+  int ppm = (256 * responseHigh) + responseLow;
+  return ppm;
+}
+
+#endif
+
+/*
+   SensorAM2320
+*/
+#if MODULE_AM2320 == 1
+// constructor
+SensorAM2320::SensorAM2320(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "AM2320";
+}
+
+// what do to during before
+void SensorAM2320::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
+}
+
+// what do to during setup
+void SensorAM2320::onSetup() {
+  _th = new AM2320();
+}
+
+// what do to during loop
+void SensorAM2320::onLoop(Child* child) {
+  // read data from the sensor
+  int status = _th->Read();
+  if (status != 0) return;
+  // temperature sensor
+  if (child->type == V_TEMP) {
+    float temperature = _th->t;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(temperature);
+    #endif
+    // store the value
+    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+  }
+  // Humidity Sensor
+  else if (child->type == V_HUM) {
+    // read humidity
+    float humidity = _th->h;
+    #if DEBUG == 1
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" T="));
+      Serial.println(humidity);
+    #endif
+    // store the value
+    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
+  }
+}
+
+// what do to as the main task when receiving a message
+void SensorAM2320::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorAM2320::onInterrupt() {
+}
+#endif
+
+/*
+   SensorTSL2561
+*/
+#if MODULE_TSL2561 == 1
+// contructor
+SensorTSL2561::SensorTSL2561(const NodeManager& node_manager): Sensor(node_manager) {
+  _name = "TSL2561";
+}
+
+// setter/getter
+void SensorTSL2561::setGain(int value) {
+  _tsl_gain = value;
+}
+void SensorTSL2561::setTiming(int value) {
+  _tsl_timing = value;
+}
+void SensorTSL2561::setSpectrum(int value) {
+  _tsl_spectrum = value;
+}
+void SensorTSL2561::setAddress(int value) {
+  _tsl_address = value;
+}
+
+// what do to during before
+void SensorTSL2561::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
+}
+
+// what do to during setup
+void SensorTSL2561::onSetup() {
+   switch (_tsl_address) {
+    case SensorTSL2561::ADDR_FLOAT:
+      _tsl = new TSL2561(TSL2561_ADDR_FLOAT);
+      break;
+    case SensorTSL2561::ADDR_LOW:
+      _tsl = new TSL2561(TSL2561_ADDR_LOW);
+      break;   
+    case SensorTSL2561::ADDR_HIGH:
+      _tsl = new TSL2561(TSL2561_ADDR_HIGH);
+      break;   
+  }
+  if (_tsl->begin()) {
+    switch (_tsl_gain) {
+      case SensorTSL2561::GAIN_0X:
+        _tsl->setGain(TSL2561_GAIN_0X);
+        break; 
+      case SensorTSL2561::GAIN_16X:
+        _tsl->setGain(TSL2561_GAIN_16X);
+        break;      
+    }
+    switch (_tsl_timing) {
+      case SensorTSL2561::INTEGRATIONTIME_13MS:
+        _tsl->setTiming(TSL2561_INTEGRATIONTIME_13MS);
+        break; 
+      case SensorTSL2561::INTEGRATIONTIME_101MS:
+        _tsl->setTiming(TSL2561_INTEGRATIONTIME_101MS); 
+        break; 
+      case SensorTSL2561::INTEGRATIONTIME_402MS:
+        _tsl->setTiming(TSL2561_INTEGRATIONTIME_402MS); 
+        break;
+    }
+  }
+  else {
+    #if DEBUG == 1
+      Serial.println(F("ERROR"));
+    #endif
+  } 
+}
+
+// what do to during loop
+void SensorTSL2561::onLoop(Child* child) {
+  // request the light level
+   switch (_tsl_spectrum) {
+    case SensorTSL2561::VISIBLE:
+      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_VISIBLE));
+      break; 
+    case SensorTSL2561::FULLSPECTRUM:
+      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_FULLSPECTRUM));
+      break; 
+    case SensorTSL2561::INFRARED:
+      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_INFRARED));
+      break; 
+    case SensorTSL2561::FULL:
+      // request the full light level
+      uint32_t lum = _tsl->getFullLuminosity(); 
+      uint16_t ir, full;
+      ir = lum >> 16;
+      full = lum & 0xFFFF;
+      ((ChildInt*)child)->setValueInt(_tsl->calculateLux(full, ir));
+      #if DEBUG == 1
+        Serial.print(_name);
+        Serial.print(F(" I="));
+        Serial.print(child->child_id);
+        Serial.print(F(" LUX="));
+        Serial.print(((ChildInt*)child)->getValueInt());
+        Serial.print(F(" IR="));
+        Serial.print(ir);
+        Serial.print(F(" FULL="));
+        Serial.print(full);
+        Serial.print(F(" VIS="));
+        Serial.println(full-ir);
+      #endif
+      break; 
+  }
+  #if DEBUG == 1
+    if (_tsl_spectrum < 3) {
+      Serial.print(_name);
+      Serial.print(F(" I="));
+      Serial.print(child->child_id);
+      Serial.print(F(" L="));
+      Serial.println(((ChildInt*)child)->getValueInt());
+    }
+  #endif
+}
+
+// what do to as the main task when receiving a message
+void SensorTSL2561::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorTSL2561::onInterrupt() {
+}
+#endif
+
+/*
+   SensorPT100
+*/
+#if MODULE_PT100 == 1
+// contructor
+SensorPT100::SensorPT100(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "PT100";
+}
+
+// setter/getter
+void SensorPT100::setVoltageRef(float value) {
+   _voltageRef = value;
+}
+
+// what to do during before
+void SensorPT100::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+}
+
+// what to do during setup
+void SensorPT100::onSetup() {
+  _PT100 = new DFRobotHighTemperature(_voltageRef); 
+  // set the pin as input
+  pinMode(_pin, INPUT);
+
+}
+
+// what to do during loop
+void SensorPT100::onLoop(Child* child) {
+  // read the PT100 sensor
+  int temperature = _PT100->readTemperature(_pin);  
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" T="));
+    Serial.println(temperature);
+  #endif
+  // store the value
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+}
+
+// what to do as the main task when receiving a message
+void SensorPT100::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// what to do when receiving an interrupt
+void SensorPT100::onInterrupt() {
+}
+#endif
+
+/*
+   SensorDimmer
+*/
+
+#if MODULE_DIMMER == 1
+// contructor
+SensorDimmer::SensorDimmer(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DIMMER";
+}
+
+// setter/getter
+void SensorDimmer::setEasing(int value) {
+  _easing = value;
+}
+void SensorDimmer::setDuration(int value) {
+  _duration = value*1000;
+}
+void SensorDimmer::setStepDuration(int value) {
+  _duration = value;
+}
+
+// what to do during before
+void SensorDimmer::onBefore() {
+  // register the child
+  new ChildInt(this,_node->getAvailableChildId(),S_DIMMER,V_PERCENTAGE);
+}
+
+// what to do during setup
+void SensorDimmer::onSetup() {
+  pinMode(_pin, OUTPUT);
+}
+
+// what to do during loop
+void SensorDimmer::onLoop(Child* child) {
+}
+
+// what to do as the main task when receiving a message
+void SensorDimmer::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_SET && message->type == child->type) {
+    int percentage = message->getInt();
+    // normalize the provided percentage
+    if (percentage < 0) percentage = 0;
+    if (percentage > 100) percentage = 100;
+    _fadeTo(child,percentage);
+    ((ChildInt*)child)->setValueInt(_percentage);
+  }
+  if (message->getCommand() == C_REQ) {
+    // return the current status
+    ((ChildInt*)child)->setValueInt(_percentage);
+  }
+}
+
+// what to do when receiving an interrupt
+void SensorDimmer::onInterrupt() {
+}
+
+// fade to the provided value
+void SensorDimmer::_fadeTo(Child* child, int target_percentage) {
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.println(target_percentage);
+  #endif
+  // count how many steps we need to do
+  int steps = _duration / _step_duration;
+  // for each step
+  for (int current_step = 1; current_step <= steps; current_step++) {
+    // calculate the delta between the target value and the current
+    int delta = target_percentage - _percentage;
+    // calculate the smooth transition and adjust it in the 0-255 range
+    int value_to_write = (int)(_getEasing(current_step,_percentage,delta,steps) / 100. * 255);
+    // write to the PWM output
+    analogWrite(_pin,value_to_write);
+    // wait at the end of this step
+    wait(_step_duration);
+  }
+  _percentage = target_percentage;
+}
+
+// for smooth transitions. t: current time, b: beginning value, c: change in value, d: duration
+float SensorDimmer::_getEasing(float t, float b, float c, float d) {
+  if (_easing == EASE_INSINE) return -c * cos(t/d * (M_PI/2)) + c + b;
+  else if (_easing == EASE_OUTSINE) return c * sin(t/d * (M_PI/2)) + b;
+  else if (_easing == EASE_INOUTSINE) return -c/2 * (cos(M_PI*t/d) - 1) + b;
+  else return c*t/d + b;
+}
+#endif
+
+/*
+   SensorPulseMeter
+*/
+#if MODULE_PULSE_METER == 1
+// contructor
+SensorPulseMeter::SensorPulseMeter(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "PULSE";
+}
+
+// setter/getter
+void SensorPulseMeter::setPulseFactor(float value) {
+  _pulse_factor = value;
+}
+void SensorPulseMeter::setInitialValue(int value) {
+  _initial_value = value;
+}
+void SensorPulseMeter::setInterruptMode(int value) {
+  _interrupt_mode = value;
+}
+
+// what to do during before
+void SensorPulseMeter::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorPulseMeter::onSetup() {
+  // configure the interrupt pin so onInterrupt() will be called on tip
+  setInterrupt(_pin,_interrupt_mode,_initial_value);
+}
+
+// what to do during loop
+void SensorPulseMeter::onLoop(Child* child) {
+  // do not report anything if called by an interrupt
+  if (_node->getLastInterruptPin() == _interrupt_pin) return;
+  // time to report the rain so far
+  _reportTotal(child);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" T="));
+    Serial.println(((ChildFloat*)child)->getValueFloat());
+  #endif
+  // reset the counter
+  _count = 0;
+}
+
+// what to do as the main task when receiving a message
+void SensorPulseMeter::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) {
+    // report the total the last period
+    _reportTotal(child);
+  }
+}
+
+// what to do when receiving an interrupt
+void SensorPulseMeter::onInterrupt() {
+  // increase the counter
+  _count++;
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.println(F("+"));
+  #endif
+}
+
+// return the total based on the pulses counted
+void SensorPulseMeter::_reportTotal(Child* child) {
+  ((ChildFloat*)child)->setValueFloat(_count / _pulse_factor);
+}
+
+/*
+   SensorRainGauge
+*/
+// contructor
+SensorRainGauge::SensorRainGauge(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "RAING";
+}
+
+// what to do during before
+void SensorRainGauge::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_RAIN,V_RAIN);
+  setPulseFactor(9.09);
+}
+
+/*
+   SensorPowerMeter
+*/
+// contructor
+SensorPowerMeter::SensorPowerMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "POWER";
+}
+
+// what to do during before
+void SensorPowerMeter::onBefore() {
+  // register the child
+  new ChildDouble(this,_node->getAvailableChildId(),S_POWER,V_KWH);
+  setPulseFactor(1000);
+}
+
+// return the total based on the pulses counted
+void SensorPowerMeter::_reportTotal(Child* child) {
+  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
+}
+
+/*
+   SensorWaterMeter
+*/
+// contructor
+SensorWaterMeter::SensorWaterMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "WATER";
+}
+
+// what to do during before
+void SensorWaterMeter::onBefore() {
+  // register the child
+  new ChildDouble(this,_node->getAvailableChildId(),S_WATER,V_VOLUME);
+  setPulseFactor(1000);
+}
+
+// return the total based on the pulses counted
+void SensorWaterMeter::_reportTotal(Child* child) {
+  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
+}
+#endif
+
+/*******************************************
+   NodeManager
+*/
+
+// initialize the node manager
+NodeManager::NodeManager() {
+  // setup the message container
+  _message = MyMessage();
+}
+
+int NodeManager::_last_interrupt_pin = -1;
+long NodeManager::_last_interrupt_1 = millis();
+long NodeManager::_last_interrupt_2 = millis();
+long NodeManager::_interrupt_min_delta = 100;
+
+// setter/getter
+void NodeManager::setRetries(int value) {
+  _retries = value;
+}
+int NodeManager::getRetries() {
+  return _retries;
+}
+
+void NodeManager::setSleepSeconds(int value) {
+  // set the status to AWAKE if the time provided is 0, SLEEP otherwise
+  if (value == 0) _status = AWAKE;
+  else _status = SLEEP;
+  // store the time
+  _sleep_time = value;
+  // save sleep settings to eeprom
+  if (_save_sleep_settings) _saveSleepSettings();
+}
+void NodeManager::setSleepMinutes(int value) {
+  setSleepSeconds(value*60);
+}
+void NodeManager::setSleepHours(int value) {
+  setSleepMinutes(value*60);
+}
+void NodeManager::setSleepDays(int value) {
+  setSleepHours(value*24);
+}
+long NodeManager::getSleepSeconds() {
+  return _sleep_time;
+}
+void NodeManager::setSleepInterruptPin(int value) {
+  _sleep_interrupt_pin = value;
+}
+void NodeManager::setInterrupt(int pin, int mode, int initial) {
+  if (pin == INTERRUPT_PIN_1) {
+    _interrupt_1_mode = mode;
+    _interrupt_1_initial = initial;
+  }
+  if (pin == INTERRUPT_PIN_2) { 
+    _interrupt_2_mode = mode;
+    _interrupt_2_initial = initial;
+  }
+}
+void NodeManager::setInterruptMinDelta(long value) {
+  _interrupt_min_delta = value;
+}
+void NodeManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
+  if (_powerManager == nullptr) return;
+  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
+}
+void NodeManager::powerOn() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOn();
+}
+void NodeManager::powerOff() {
+  if (_powerManager == nullptr) return;
+  _powerManager->powerOff();
+}
+void NodeManager::setSleepBetweenSend(int value) {
+  _sleep_between_send = value;
+}
+int NodeManager::getSleepBetweenSend() {
+  return _sleep_between_send;
+}
+void NodeManager::setAck(bool value) {
+    _ack = value;
+}
+bool NodeManager::getAck() {
+    return _ack;
+}
+void NodeManager::setGetControllerConfig(bool value) {
+  _get_controller_config = value;
+}
+void NodeManager::setIsMetric(bool value) {
+  _is_metric = value;
+}
+bool NodeManager::getIsMetric() {
+  return _is_metric;
+}
+void NodeManager::setSaveSleepSettings(bool value) {
+  _save_sleep_settings = value;
+}
+
+// Convert a temperature from celsius to fahrenheit depending on how isMetric is set
+float NodeManager::celsiusToFahrenheit(float temperature) {
+  if (_is_metric) return temperature;
+  // convert the temperature from C to F
+  return temperature * 1.8 + 32;
+}
+
+// return true if sleep or wait is configured and hence this is a sleeping node
+bool NodeManager::isSleepingNode() {
+  if (_status == SLEEP) return true;
+  return false;
+}
+
+/*
+// register a sensor to this manager
+int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
+  // get a child_id if not provided by the user
+  if (child_id < 0) child_id = _getAvailableChildId();
+  // based on the given sensor type instantiate the appropriate class
+  if (sensor_type < 0) return -1;
+  #if MODULE_ANALOG_INPUT == 1
+    else if (sensor_type == SENSOR_ANALOG_INPUT) return registerSensor(new SensorAnalogInput(this,child_id, pin));
+    else if (sensor_type == SENSOR_LDR) return registerSensor(new SensorLDR(this,child_id, pin));
+    else if (sensor_type == SENSOR_THERMISTOR) return registerSensor(new SensorThermistor(this,child_id, pin));
+    else if (sensor_type == SENSOR_ML8511) return registerSensor(new SensorML8511(this,child_id, pin));
+    else if (sensor_type == SENSOR_ACS712) return registerSensor(new SensorACS712(this,child_id, pin));
+    else if (sensor_type == SENSOR_RAIN) return registerSensor(new SensorRain(this,child_id, pin));
+    else if (sensor_type == SENSOR_SOIL_MOISTURE) return registerSensor(new SensorSoilMoisture(this,child_id, pin));
+  #endif
+  #if MODULE_DIGITAL_INPUT == 1
+    else if (sensor_type == SENSOR_DIGITAL_INPUT) return registerSensor(new SensorDigitalInput(this,child_id, pin));
+  #endif
+  #if MODULE_DIGITAL_OUTPUT == 1
+    else if (sensor_type == SENSOR_DIGITAL_OUTPUT) return registerSensor(new SensorDigitalOutput(this,child_id, pin));
+    else if (sensor_type == SENSOR_RELAY) return registerSensor(new SensorRelay(this,child_id, pin));
+    else if (sensor_type == SENSOR_LATCHING_RELAY) return registerSensor(new SensorLatchingRelay(this,child_id, pin));
+  #endif
+  #if MODULE_DHT == 1
+    else if (sensor_type == SENSOR_DHT11 || sensor_type == SENSOR_DHT22) {
+      int dht_type;
+      if (sensor_type == SENSOR_DHT11) dht_type = DHT::DHT11;
+      else if (sensor_type == SENSOR_DHT22) dht_type = DHT::DHT22;
+      DHT* dht = new DHT();
+      // register temperature sensor
+      registerSensor(new SensorDHT(this,child_id,pin,dht,SensorDHT::TEMPERATURE,dht_type));
+      // register humidity sensor
+      child_id = _getAvailableChildId();
+      return registerSensor(new SensorDHT(this,child_id,pin,dht,SensorDHT::HUMIDITY,dht_type));
+    }
+  #endif
+  #if MODULE_SHT21 == 1
+    else if (sensor_type == SENSOR_SHT21) {
+      // register temperature sensor
+      //registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
+      // register humidity sensor
+      //child_id = _getAvailableChildId();
+      //return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
+    }
+    else if (sensor_type == SENSOR_HTU21D) {
+      // register temperature sensor
+      //registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::TEMPERATURE));
+      // register humidity sensor
+      child_id = _getAvailableChildId();
+//      return registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::HUMIDITY));
+    }
+  #endif
+  #if MODULE_SWITCH == 1
+    else if (sensor_type == SENSOR_SWITCH || sensor_type == SENSOR_DOOR || sensor_type == SENSOR_MOTION) {
+      // ensure an interrupt pin is provided
+      if (pin != INTERRUPT_PIN_1 && pin != INTERRUPT_PIN_2) return -1;
+      // register the sensor
+      if (sensor_type == SENSOR_SWITCH) return registerSensor(new SensorSwitch(this,child_id, pin));
+      else if (sensor_type == SENSOR_DOOR) return registerSensor(new SensorDoor(this,child_id, pin));
+      else if (sensor_type == SENSOR_MOTION) return registerSensor(new SensorMotion(this,child_id, pin));
+    }
+  #endif
+  #if MODULE_DS18B20 == 1
+    else if (sensor_type == SENSOR_DS18B20) {
+      // initialize the library
+      OneWire* oneWire = new OneWire(pin);
+      DallasTemperature* sensors = new DallasTemperature(oneWire);
+      // initialize the sensors
+      sensors->begin();
+      int index = 0;
+      // register a new child for each sensor on the bus
+      for(int i = 0; i < sensors->getDeviceCount(); i++) {
+        if (i > 0) child_id = _getAvailableChildId();
+        index = registerSensor(new SensorDs18b20(this,child_id,pin,sensors,i));
+      }
+      return index;
+    }
+  #endif
+  #if MODULE_BH1750 == 1
+    else if (sensor_type == SENSOR_BH1750) return registerSensor(new SensorBH1750(this,child_id));
+  #endif
+  #if MODULE_MLX90614 == 1
+    else if (sensor_type == SENSOR_MLX90614) {
+      Adafruit_MLX90614* mlx = new Adafruit_MLX90614();
+      // register ambient temperature sensor
+      registerSensor(new SensorMLX90614(this,child_id,mlx,SensorMLX90614::TEMPERATURE_AMBIENT));
+      // register object temperature sensor
+      child_id = _getAvailableChildId();
+      return registerSensor(new SensorMLX90614(this,child_id,mlx,SensorMLX90614::TEMPERATURE_OBJECT));
+    }
+  #endif
+  #if MODULE_BME280 == 1
+    else if (sensor_type == SENSOR_BME280) {
+      Adafruit_BME280* bme = new Adafruit_BME280();
+      if (! bme->begin(SensorBosch::GetI2CAddress(0x60))) {
+        #if DEBUG == 1
+          Serial.println(F("NO BME"));
+        #endif
+        return -1;
+      }
+      // register temperature sensor
+      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::TEMPERATURE));
+      child_id = _getAvailableChildId();
+      // register humidity sensor
+      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::HUMIDITY));
+      // register pressure sensor
+      child_id = _getAvailableChildId();
+      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::PRESSURE));
+      // register forecast sensor
+      child_id = _getAvailableChildId();
+      return registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::FORECAST));
+    }
+  #endif
+  #if MODULE_BMP280 == 1
+    else if (sensor_type == SENSOR_BMP280) {
+      Adafruit_BMP280* bmp = new Adafruit_BMP280();
+      if (! bmp->begin(SensorBosch::GetI2CAddress(0x58))) {
+        #if DEBUG == 1
+          Serial.println(F("NO BMP"));
+        #endif
+        return -1;
+      }
+      // register temperature sensor
+      registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::TEMPERATURE));
+      child_id = _getAvailableChildId();
+      // register pressure sensor
+      child_id = _getAvailableChildId();
+      registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::PRESSURE));
+      // register forecast sensor
+      child_id = _getAvailableChildId();
+      return registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::FORECAST));
+    }
+  #endif
+  #if MODULE_SONOFF == 1
+    else if (sensor_type == SENSOR_SONOFF) return registerSensor(new SensorSonoff(this,child_id));
+  #endif
+  #if MODULE_BMP085 == 1
+    else if (sensor_type == SENSOR_BMP085) {
+      Adafruit_BMP085* bmp = new Adafruit_BMP085();
+      if (! bmp->begin(SensorBosch::GetI2CAddress(0x55))) {
+        #if DEBUG == 1
+          Serial.println(F("NO BMP"));
+        #endif
+        return -1;
+      }
+      // register temperature sensor
+      registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::TEMPERATURE));
+      // register pressure sensor
+      child_id = _getAvailableChildId();
+      registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::PRESSURE));
+      // register forecast sensor
+      child_id = _getAvailableChildId();
+      return registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::FORECAST));
+    }
+  #endif
+  #if MODULE_HCSR04 == 1
+    else if (sensor_type == SENSOR_HCSR04) return registerSensor(new SensorHCSR04(this,child_id, pin));
+  #endif
+  #if MODULE_MCP9808 == 1
+    else if (sensor_type == SENSOR_MCP9808) {
+      Adafruit_MCP9808 * mcp = new Adafruit_MCP9808();
+      if (! mcp->begin()) {
+        #if DEBUG == 1
+          Serial.println(F("NO MCP"));
+        #endif
+        return -1;
+      }
+      // register temperature sensor
+      registerSensor(new SensorMCP9808(this,child_id,mcp));
+    }
+  #endif
+  #if MODULE_MQ == 1
+    else if (sensor_type == SENSOR_MQ) return registerSensor(new SensorMQ(this,child_id, pin));
+  #endif
+  #if MODULE_MHZ19 == 1
+    else if (sensor_type == SENSOR_MHZ19) return registerSensor(new SensorMHZ19(this, child_id, pin));
+  #endif
+  #if MODULE_AM2320 == 1
+    else if (sensor_type == SENSOR_AM2320) {
+      AM2320* th = new AM2320();
+      // register temperature sensor
+      registerSensor(new SensorAM2320(this,child_id,th,SensorAM2320::TEMPERATURE));
+      // register humidity sensor
+      child_id = _getAvailableChildId();
+      return registerSensor(new SensorAM2320(this,child_id,th,SensorAM2320::HUMIDITY));
+    }
+  #endif
+  #if MODULE_TSL2561 == 1 
+    else if (sensor_type == SENSOR_TSL2561) return registerSensor(new SensorTSL2561(this,child_id));
+  #endif
+  #if MODULE_PT100 == 1 
+    else if (sensor_type == SENSOR_PT100) return registerSensor(new SensorPT100(this,child_id,pin));
+  #endif
+  #if MODULE_DIMMER == 1 
+    else if (sensor_type == SENSOR_DIMMER) return registerSensor(new SensorDimmer(this,child_id,pin));
+  #endif
+  #if MODULE_PULSE_METER == 1 
+    else if (sensor_type == SENSOR_RAIN_GAUGE) return registerSensor(new SensorRainGauge(this,child_id,pin));
+    else if (sensor_type == SENSOR_POWER_METER) return registerSensor(new SensorPowerMeter(this,child_id,pin));
+    else if (sensor_type == SENSOR_WATER_METER) return registerSensor(new SensorWaterMeter(this,child_id,pin));
+  #endif
+  else {
+    #if DEBUG == 1
+      Serial.print(F("INVALID "));
+      Serial.println(sensor_type);
+    #endif
+    return -1;
+  };
+}
+/*
+
+
+
+/*
+// attach a built-in or custom sensor to this manager
+int NodeManager::registerSensorOLD(Sensor* sensor) {
+  if (sensor->getChildId() > MAX_SENSORS) return;
+  #if DEBUG == 1
+    Serial.print(F("REG I="));
+    Serial.print(sensor->getChildId());
+    Serial.print(F(" P="));
+    Serial.print(sensor->getPin());
+    Serial.print(F(" P="));
+    Serial.print(sensor->getPresentation());
+    Serial.print(F(" T="));
+    Serial.println(sensor->getType());
+  #endif
+  #if POWER_MANAGER == 1
+    // set auto power pin
+    sensor->setAutoPowerPins(_auto_power_pins);
+  #endif
+  // add the sensor to the array of registered sensors
+  _sensors[sensor->getChildId()] = sensor;
+  // return the child_id
+  return sensor->getChildId();
+}
+*/
+
+void NodeManager::registerSensor(Sensor* sensor) {
+  sensors.push(sensor);
+}
+
+// setup NodeManager
+void NodeManager::before() {
+  // print out the version
+  #if DEBUG == 1
+    Serial.print(F("NodeManager v"));
+    Serial.println(VERSION);
+  #endif
+  // setup the reboot pin if needed
+  if (_reboot_pin > -1) {
+    #if DEBUG == 1
+      Serial.print("REB P=");
+      Serial.println(_reboot_pin);
+    #endif
+    pinMode(_reboot_pin, OUTPUT);
+    digitalWrite(_reboot_pin, HIGH);
+  }
+  // print out MySensors' library capabilities
+  #if DEBUG == 1
+    Serial.print(F("LIB V="));
+    Serial.print(MYSENSORS_LIBRARY_VERSION);
+    Serial.print(F(" R="));
+    Serial.print(MY_CAP_RADIO);
+    #ifdef MY_CAP_ENCR
+      Serial.print(F(" E="));
+      Serial.print(MY_CAP_ENCR);
+    #endif
+    Serial.print(F(" T="));
+    Serial.print(MY_CAP_TYPE);
+    Serial.print(F(" A="));
+    Serial.print(MY_CAP_ARCH);
+    Serial.print(F(" S="));
+    Serial.print(MY_CAP_SIGN);
+    Serial.print(F(" B="));
+    Serial.println(MY_CAP_RXBUF);
+  #endif
+  // restore the sleep settings saved in the eeprom
+  if (_save_sleep_settings) _loadSleepSettings();
+  // setup individual sensors
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
+    // configure reporting interval
+    if (! sensor->isReportIntervalConfigured()) sensor->setReportIntervalSeconds(_report_interval_seconds);
+    // call each sensor's before()
+    sensor->before();
+  }
+  // setup the interrupt pins
+  setupInterrupts();
+}
+
+// present NodeManager and its sensors
+void NodeManager::presentation() {
+  #if DEBUG == 1
+    Serial.println(F("RADIO OK"));
+  #endif
+  // Send the sketch version information to the gateway and Controller
+  if (_sleep_between_send > 0) sleep(_sleep_between_send);
+  sendSketchInfo(SKETCH_NAME,SKETCH_VERSION);
+  // present each sensor
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
+    // call each sensor's presentation()
+    if (_sleep_between_send > 0) sleep(_sleep_between_send);
+    sensor->presentation();
+  }
+  #if DEBUG == 1
+    Serial.println(F("READY"));
+    Serial.println("");
+  #endif
+}
+
+
+// setup NodeManager
+void NodeManager::setup() {
+  // retrieve and store isMetric from the controller
+  if (_get_controller_config) _is_metric = getControllerConfig().isMetric;
+  #if DEBUG == 1
+    Serial.print(F("MY I="));
+    Serial.print(getNodeId());
+    Serial.print(F(" M="));
+    Serial.println(_is_metric);
+  #endif
+  // run setup for all the registered sensors
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
+    // call each sensor's setup()
+    sensor->setup();
+  }
+}
+
+// run the main function for all the register sensors
+void NodeManager::loop() {
+  // turn on the pin powering all the sensors
+  powerOn();
+  // run loop for all the registered sensors
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
+    if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
+      // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
+      _message.clear();
+      sensor->interrupt();
+      sensor->loop(nullptr);
+        // reset the last interrupt pin
+      _last_interrupt_pin = -1;
+    }
+    else if (_last_interrupt_pin == -1) {
+      // if just at the end of a cycle, call the sensor's loop() 
+      _message.clear();
+      sensor->loop(nullptr);
+    }
+  }
+  // turn off the pin powering all the sensors
+  powerOff();
+  // continue/start sleeping as requested
+  if (isSleepingNode()) _sleep();
+}
+
+// dispacth inbound messages
+void NodeManager::receive(const MyMessage &message) {
+  #if DEBUG == 1
+    Serial.print(F("RECV S="));
+    Serial.print(message.sender);
+    Serial.print(F(" I="));
+    Serial.print(message.sensor);
+    Serial.print(F(" C="));
+    Serial.print(message.getCommand());
+    Serial.print(F(" T="));
+    Serial.print(message.type);
+    Serial.print(F(" P="));
+    Serial.println(message.getString());
+  #endif
+  // dispatch the message to the registered sensor
+  Sensor* sensor = getSensorWithChild(message.sensor);
+  if (sensor != nullptr) {
+    // turn on the pin powering all the sensors
+    powerOn();
+    // call the sensor's receive()
+    sensor->receive(message);
+    // turn off the pin powering all the sensors
+    powerOff();
+  }
+}
+
+// request and return the current timestamp from the controller
+long NodeManager::getTimestamp() {
+  int retries = 3;
+  _timestamp = -1;
+  while (_timestamp == -1 && retries > 0) {
+    #if DEBUG == 1
+      Serial.println(F("TIME"));
+    #endif
+    // request the time to the controller
+    requestTime();
+    // keep asking every 1 second
+    sleepOrWait(1000);
+    retries--;
+  }  
+  return _timestamp;
+}
+
+// receive the time from the controller and save it
+void NodeManager::receiveTime(unsigned long ts) {
+  _timestamp = ts;
+  #if DEBUG == 1
+    Serial.print(F("TIME T="));
+    Serial.print(_timestamp);
+  #endif
+}
+
+// Send a hello message back to the controller
+void NodeManager::hello() {
+  // do nothing, the request will be echoed back
+}
+
+// reboot the board
+void NodeManager::reboot() {
+  #if DEBUG == 1
+    Serial.println(F("REBOOT"));
+  #endif
+  if (_reboot_pin > -1) {
+    // reboot the board through the reboot pin which is connected to RST by setting it to low
+    digitalWrite(_reboot_pin, LOW);
+  } else {
+    // Software reboot with watchdog timer. Enter Watchdog Configuration mode:
+    WDTCSR |= (1<<WDCE) | (1<<WDE);
+    // Reset enable
+    WDTCSR= (1<<WDE);
+    // Infinite loop until watchdog reset after 16 ms
+    while(true){}
+  }
+}
+
+// clear the EEPROM
+void NodeManager::clearEeprom() {
+  #if DEBUG == 1
+    Serial.println(F("CLEAR"));
+  #endif
+  for (uint16_t i=0; i<EEPROM_LOCAL_CONFIG_ADDRESS; i++) saveState(i, 0xFF);
+}
+
+// wake up the board
+void NodeManager::wakeup() {
+  #if DEBUG == 1
+    Serial.println(F("WAKEUP"));
+  #endif
+  _status = AWAKE;
+}
+
+// return the value stored at the requested index from the EEPROM
+int NodeManager::loadFromMemory(int index) {
+  return loadState(index+EEPROM_USER_START);
+}
+
+// save the given index of the EEPROM the provided value
+void NodeManager::saveToMemory(int index, int value) {
+  saveState(index+EEPROM_USER_START, value);
+}
+
+// return vcc in V
+float NodeManager::getVcc() {
+  #ifndef MY_GATEWAY_ESP8266
+    // Measure Vcc against 1.1V Vref
+    #if defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+      ADMUX = (_BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1));
+    #elif defined (__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
+      ADMUX = (_BV(MUX5) | _BV(MUX0));
+    #elif defined (__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
+      ADMUX = (_BV(MUX3) | _BV(MUX2));
+    #else
+      ADMUX = (_BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1));
+    #endif
+    // Vref settle
+    wait(70);
+    // Do conversion
+    ADCSRA |= _BV(ADSC);
+    while (bit_is_set(ADCSRA, ADSC)) {};
+    // return Vcc in mV
+    return (float)((1125300UL) / ADC) / 1000;
+  #else
+    return (float)0;
+  #endif
+}
+
+// setup the interrupt pins
+void NodeManager::setupInterrupts() {
+  // configure wakeup pin if needed
+  if (_sleep_interrupt_pin > -1) {
+    // set the interrupt when the pin is connected to ground
+    setInterrupt(_sleep_interrupt_pin,FALLING,HIGH);
+  }
+  // setup the interrupt pins
+  if (_interrupt_1_mode != MODE_NOT_DEFINED) {
+    pinMode(INTERRUPT_PIN_1,INPUT);
+    if (_interrupt_1_initial > -1) digitalWrite(INTERRUPT_PIN_1,_interrupt_1_initial);
+    // for non sleeping nodes, we need to handle the interrupt by ourselves  
+    if (_status != SLEEP) attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN_1), _onInterrupt_1, _interrupt_1_mode);
+  }
+  if (_interrupt_2_mode != MODE_NOT_DEFINED) {
+    pinMode(INTERRUPT_PIN_2, INPUT);
+    if (_interrupt_2_initial > -1) digitalWrite(INTERRUPT_PIN_2,_interrupt_2_initial);
+    // for non sleeping nodes, we need to handle the interrupt by ourselves  
+    if (_status != SLEEP) attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN_2), _onInterrupt_2, _interrupt_2_mode);
+  }
+  #if DEBUG == 1
+    Serial.print(F("INT P="));
+    Serial.print(INTERRUPT_PIN_1);
+    Serial.print(F(" M="));
+    Serial.println(_interrupt_1_mode);
+    Serial.print(F("INT P="));
+    Serial.print(INTERRUPT_PIN_2);
+    Serial.print(F(" M="));
+    Serial.println(_interrupt_2_mode);
+  #endif
+}
+
+// return the pin from which the last interrupt came
+int NodeManager::getLastInterruptPin() {
+  return _last_interrupt_pin;
+}
+
+// set the default interval in seconds all the sensors will report their measures
+void NodeManager::setReportIntervalSeconds(int value) {
+  _report_interval_seconds = value;
+}
+
+// set the default interval in minutes all the sensors will report their measures
+void NodeManager::setReportIntervalMinutes(int value) {
+  _report_interval_seconds = value*60;
+}
+
+// set the default interval in hours all the sensors will report their measures
+void NodeManager::setReportIntervalHours(int value) {
+  _report_interval_seconds = value*60*60;
+}
+
+// set the default interval in days all the sensors will report their measures
+void NodeManager::setReportIntervalDays(int value) {
+  _report_interval_seconds = value*60*60*24;
+}
+
+// if set and when the board is battery powered, sleep() is always called instead of wait()
+void NodeManager::setSleepOrWait(bool value) {
+  _sleep_or_wait = value;
+}
+
+// set which pin is connected to RST of the board to reboot the board when requested. If not set the software reboot is used instead (default: -1)
+void NodeManager::setRebootPin(int value) {
+  _reboot_pin = value;
+}
+
+// turn the ADC off so to save 0.2 mA
+void NodeManager::setADCOff() {
+  // Disable the ADC by setting the ADEN bit (bit 7) to zero
+  ADCSRA = ADCSRA & B01111111;
+  // Disable the analog comparator by setting the ACD bit (bit 7) to one
+  ACSR = B10000000;
+}
+
+// sleep if the node is a battery powered or wait if it is not for the given number of milliseconds 
+void NodeManager::sleepOrWait(long value) {
+  // if the node is sleeping, sleep-or-wait is enabled and we need to sleep for a decent amount of time, call sleep() otherwise wait()
+  if (isSleepingNode() && _sleep_or_wait && value > 200) sleep(value);
+  else wait(value);
+}
+
+// return the next available child_id
+int NodeManager::getAvailableChildId() {
+  for (int i = 1; i < 255; i++) {
+    if (i == CONFIGURATION_CHILD_ID || i == BATTERY_CHILD_ID || i == SIGNAL_CHILD_ID) continue;
+    Child* child = getChild(i);
+    if (child == nullptr) return i;
+  }
+  return 254;
+}
+
+// handle an interrupt
+void NodeManager::_onInterrupt_1() {
+  long now = millis();
+  if ( (now - _last_interrupt_1 > _interrupt_min_delta) || (now < _last_interrupt_1) ) {
+    _last_interrupt_pin = INTERRUPT_PIN_1;
+    #if DEBUG == 1
+      Serial.print(F("INT P="));
+      Serial.println(INTERRUPT_PIN_1);
+    #endif
+    _last_interrupt_1 = now;
+  }
+}
+void NodeManager::_onInterrupt_2() {
+  long now = millis();
+  if ( (now - _last_interrupt_2 > _interrupt_min_delta) || (now < _last_interrupt_2) ) {
+    _last_interrupt_pin = INTERRUPT_PIN_2;
+    #if DEBUG == 1
+      Serial.print(F("INT P="));
+      Serial.println(INTERRUPT_PIN_2);
+    #endif
+    _last_interrupt_2 = now;
+  }
+}
+
+// send a message by providing the source child, type of the message and value
+void NodeManager::sendMessage(int child_id, int type, int value) {
+  _message.clear();
+  _message.set(value);
+  _sendMessage(child_id,type);
+}
+void NodeManager::sendMessage(int child_id, int type, float value) {
+  _message.clear();
+  _message.set(value,2);
+  _sendMessage(child_id,type);
+}
+void NodeManager::sendMessage(int child_id, int type, double value) {
+  _message.clear();
+  _message.set(value,4);
+  _sendMessage(child_id,type);
+}
+void NodeManager::sendMessage(int child_id, int type, const char* value) {
+  _message.clear();
+  _message.set(value);
+  _sendMessage(child_id,type);
+}
+
+// send a message to the network
+void NodeManager::_sendMessage(int child_id, int type) {
+  // prepare the message
+  _message.setSensor(child_id);
+  _message.setType(type);
+  // send the message, multiple times if requested
+  for (int i = 0; i < _retries; i++) {
+    // if configured, sleep beetween each send
+    if (_sleep_between_send > 0) sleep(_sleep_between_send);
+    #if DEBUG == 1
+      Serial.print(F("SEND D="));
+		  Serial.print(_message.destination);
+      Serial.print(F(" I="));
+		  Serial.print(_message.sensor);
+      Serial.print(F(" C="));
+		  Serial.print(_message.getCommand());
+      Serial.print(F(" T="));
+		  Serial.print(_message.type);
+      Serial.print(F(" S="));
+		  Serial.print(_message.getString());
+      Serial.print(F(" I="));
+		  Serial.print(_message.getInt());
+      Serial.print(F(" F="));
+		  Serial.println(_message.getFloat());
+    #endif
+		send(_message, _ack);
+  }
+}
+
+void NodeManager::setPowerManager(const PowerManager& powerManager) {
+  _powerManager = &powerManager;
+}
+
+// return the requested child 
+Child* NodeManager::getChild(int child_id) {
+  Sensor* sensor = getSensorWithChild(child_id);
+  if (sensor == nullptr) return nullptr;
+  return sensor->getChild(child_id);
+}
+
+// return the sensor with the requested child 
+Sensor* NodeManager::getSensorWithChild(int child_id) {
+  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
+    Sensor* sensor = *itr;
+    Child* child = sensor->getChild(child_id);
+    if (child != nullptr) return sensor;
+  }
+  return nullptr;  
+}
+
+// wrapper of smart sleep
+void NodeManager::_sleep() {
+  #if DEBUG == 1
+    Serial.print(F("SLEEP "));
+    Serial.print(_sleep_time);
+    Serial.println(F("s"));
+  #endif
+  #if DEBUG == 1
+    // print a new line to separate the different cycles
+    Serial.println("");
+  #endif
+  // go to sleep
+  int interrupt = -1;
+  // setup interrupt pins
+  int interrupt_1_pin = _interrupt_1_mode == MODE_NOT_DEFINED ? INTERRUPT_NOT_DEFINED  : digitalPinToInterrupt(INTERRUPT_PIN_1);
+  int interrupt_2_pin = _interrupt_2_mode == MODE_NOT_DEFINED ? INTERRUPT_NOT_DEFINED  : digitalPinToInterrupt(INTERRUPT_PIN_2);
+  // enter smart sleep for the requested sleep interval and with the configured interrupts
+  interrupt = sleep(interrupt_1_pin,_interrupt_1_mode,interrupt_2_pin,_interrupt_2_mode,_sleep_time*1000, true);
+  if (interrupt > -1) {
+    // woke up by an interrupt
+    int pin_number = -1;
+    int interrupt_mode = -1;
+    // map the interrupt to the pin
+    if (digitalPinToInterrupt(INTERRUPT_PIN_1) == interrupt) {
+      pin_number = INTERRUPT_PIN_1;
+      interrupt_mode = _interrupt_1_mode;
+    }
+    if (digitalPinToInterrupt(INTERRUPT_PIN_2) == interrupt) {
+      pin_number = INTERRUPT_PIN_2;
+      interrupt_mode = _interrupt_2_mode;
+    }
+    _last_interrupt_pin = pin_number;
+    #if DEBUG == 1
+      Serial.print(F("INT P="));
+      Serial.print(pin_number);
+      Serial.print(F(", M="));
+      Serial.println(interrupt_mode);
+    #endif
+    // when waking up from an interrupt on the wakup pin, stop sleeping
+    if (_sleep_interrupt_pin == pin_number) _status = AWAKE;
+  }
+  // coming out of sleep
+  #if DEBUG == 1
+    Serial.println(F("AWAKE"));
+  #endif
+}
+
+// present the service
+void NodeManager::_present(int child_id, int type) {
+  #if DEBUG == 1
+    Serial.print(F("PRES I="));
+    Serial.print(child_id);
+    Serial.print(F(", T="));
+    Serial.println(type);
+  #endif
+  if (_sleep_between_send > 0) sleep(_sleep_between_send);
+  present(child_id,type,"",_ack);
+}
+
+// load the configuration stored in the eeprom
+void NodeManager::_loadSleepSettings() {
+  if (loadState(EEPROM_SLEEP_SAVED) == 1) {
+    // load sleep settings
+    int bit_1 = loadState(EEPROM_SLEEP_1);
+    int bit_2 = loadState(EEPROM_SLEEP_2);
+    int bit_3 = loadState(EEPROM_SLEEP_3);
+    _sleep_time = bit_3*255*255 + bit_2*255 + bit_1;
+    #if DEBUG == 1
+      Serial.print(F("LOADSLP T="));
+      Serial.println(_sleep_time);
+    #endif
+  }
+}
+
+// save the configuration in the eeprom
+void NodeManager::_saveSleepSettings() {
+  if (_sleep_time == 0) return;
+  // encode the sleep time in 3 bits
+  int bit_1, bit_2, bit_3 = 0;
+  bit_1 = _sleep_time;
+  if (bit_1 >= 255) {
+    bit_2 = (int)bit_1/255;
+    bit_1 = bit_1 - bit_2*255;
+  }
+  if (bit_2 >= 255) {
+    bit_3 = (int)bit_2/255;
+    bit_2 = bit_2 - bit_3*255;
+  }
+  // save the 3 bits
+  saveState(EEPROM_SLEEP_SAVED,1);
+  saveState(EEPROM_SLEEP_1,bit_1);
+  saveState(EEPROM_SLEEP_2,bit_2);
+  saveState(EEPROM_SLEEP_3,bit_3);
+}

From 9624327b5cf59602c4d3503e9a83baa252922308 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 17 Dec 2017 15:30:29 +0100
Subject: [PATCH 48/51] Removed unused files

---
 NodeManager.cpp | 4195 -----------------------------------------------
 NodeManager.h   | 1489 -----------------
 config.h        |  168 --
 3 files changed, 5852 deletions(-)
 delete mode 100644 NodeManager.cpp
 delete mode 100644 NodeManager.h
 delete mode 100755 config.h

diff --git a/NodeManager.cpp b/NodeManager.cpp
deleted file mode 100644
index 979c417..0000000
--- a/NodeManager.cpp
+++ /dev/null
@@ -1,4195 +0,0 @@
-/*
- * NodeManager
- */
-
-#include "NodeManager.h"
-
-/***************************************
-   PowerManager
-*/
-
-PowerManager::PowerManager(int ground_pin, int vcc_pin, int wait_time) {
-  setPowerPins(ground_pin, vcc_pin, wait_time);
-}
-
-// set the vcc and ground pin the sensor is connected to
-void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
-  _ground_pin = ground_pin;
-  _vcc_pin = vcc_pin;
-  #if DEBUG == 1
-    Serial.print(F("PWR G="));
-    Serial.print(_ground_pin);
-    Serial.print(F(" V="));
-    Serial.println(_vcc_pin);
-  #endif
-  if (_ground_pin > 0) {
-    // configure the ground pin as output and initialize to low
-    pinMode(_ground_pin, OUTPUT);
-    digitalWrite(_ground_pin, LOW);
-  }
-  if (_vcc_pin > 0) {
-    // configure the vcc pin as output and initialize to high (power on)
-    pinMode(_vcc_pin, OUTPUT);
-    digitalWrite(_vcc_pin, HIGH);
-  }
-  // save wait time
-  _wait = wait_time;
-}
-
-// turn on the sensor by activating its power pins
-void PowerManager::powerOn() {
-  if (_vcc_pin == -1) return;
-  #if DEBUG == 1
-    Serial.print(F("ON P="));
-    Serial.println(_vcc_pin);
-  #endif
-  // power on the sensor by turning high the vcc pin
-  digitalWrite(_vcc_pin, HIGH);
-  // wait a bit for the device to settle down
-  if (_wait > 0) wait(_wait);
-}
-
-// turn off the sensor
-void PowerManager::powerOff() {
-  if (_vcc_pin == -1) return;
-  #if DEBUG == 1
-    Serial.print(F("OFF P="));
-    Serial.println(_vcc_pin);
-  #endif
-  // power off the sensor by turning low the vcc pin
-  digitalWrite(_vcc_pin, LOW);
-}
-
-/******************************************
-    Timer
-*/
-
-Timer::Timer(NodeManager* node_manager) {
-  _node = node_manager;
-}
-
-// start the timer
-void Timer::start(int target, int unit) {
-  set(target,unit);
-  start();
-}
-void Timer::start() {
-  if (_is_configured) _is_running = true;
-}
-
-// stop the timer
-void Timer::stop() {
-  _is_running = false;
-}
-
-// reset the timer
-void Timer::reset() {
-  // reset the timer
-  _elapsed = 0;
-  _last_millis = 0;
-}
-
-// restart the timer
-void Timer::restart() {
-  if (! isRunning()) return;
-  stop();
-  reset();
-  // if using millis(), keep track of the current timestamp for calculating the difference
-  if (! _node->isSleepingNode()) _last_millis = millis();
-  start();
-}
-
-// setup the timer
-void Timer::set(int target, int unit) {
-  reset();
-  // save the settings
-  _target = target;
-  if (unit == MINUTES) _target = _target * 60;
-  else if (unit == HOURS) _target = _target * 60 *60;
-  else if (unit == DAYS) _target = _target * 60 * 60 *24;
-  _is_running = false;
-  _is_configured = true;
-}
-
-// unset the timer
-void Timer::unset() {
-  stop();
-  _is_configured = true;
-}
-
-// update the timer at every cycle
-void Timer::update() {
-  if (! isRunning()) return;
-  if (_node->isSleepingNode()) {
-    // millis() is not reliable while sleeping so calculate how long a sleep cycle would last in seconds and update the elapsed time
-    _elapsed += _node->getSleepSeconds();
-  } else {
-    // use millis() to calculate the elapsed time in seconds
-    _elapsed = (long)((millis() - _last_millis)/1000);
-  }
-  _first_run = false;
-}
-
-// return true if the time is over
-bool Timer::isOver() {
-  if (! isRunning()) return false;
-  // time has elapsed
-  if (_elapsed >= _target) return true;
-  // millis has started over
-  if (_elapsed < 0 ) return true;
-  return false;
-}
-
-// return true if the timer is running
-bool Timer::isRunning() {
-  if (! isConfigured()) return false;
-  return _is_running;
-}
-
-// return true if the time is configured
-bool Timer::isConfigured() {
-  return _is_configured;
-}
-
-// return true if this is the first time the timer runs
-bool Timer::isFirstRun() {
-  return _first_run;
-}
-
-// return elapsed seconds so far
-float Timer::getElapsed() {
-  return _elapsed;
-}
-
-
-/******************************************
-    Request
-*/
-
-// contructor, tokenize a request in the format "child_id,function,value"
-Request::Request(int recipient_child_id, const char* string) {
-  _recipient_child_id = recipient_child_id;
-  char* ptr;
-  // tokenize the string and get child id
-  _child_id = atoi(strtok_r(string, ",", &ptr));
-  // tokenize the string and get function id
-  _function = atoi(strtok_r(NULL, ",", &ptr));
-  // tokenize the string and get the value
-  _value = atof(strtok_r(NULL, ",", &ptr));
-  #if DEBUG == 1
-    Serial.print(F("REQ C="));
-    Serial.print(_child_id);
-    Serial.print(F(" F="));
-    Serial.print(_function);
-    Serial.print(F(" V="));
-    Serial.println(_value);
-  #endif
-}
-
-// return the child id
-int Request::getRecipientChildId() {
-  return _recipient_child_id;
-}
-
-// return the child id
-int Request::getChildId() {
-  return _child_id;
-}
-
-// return the parsed function
-int Request::getFunction() {
-  return _function;
-}
-
-// return the value as an int
-int Request::getValueInt() {
-  return (int)_value;
-  
-}
-
-// return the value as a float
-float Request::getValueFloat() {
-  return _value;
-}
-
-/******************************************
-    Sensors
-*/
-
-/*
- Child class
- */
-
-Child::Child() {
-
-}
-
-// constructor
-Child::Child(Sensor* __sensor, int _child_id, int _presentation, int _type, char* _description = "") {
-  child_id = _child_id;
-  presentation = _presentation;
-  type = _type;
-  description = _description;
-  _sensor = __sensor;
-  _sensor->registerChild(this);
-  force_update_timer = new Timer(_sensor->_node);
-}
-// set a value, implemented by the subclasses
-void Child::sendValue() {
-}
-
-// check if it is an updated value, implemented by the subclasses
-bool Child::isNewValue() {
-}
-
-/*
- ChildInt class
-*/
-
-// ChildInt class
-ChildInt::ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
-}
-
-// store a new value and update the total
-void ChildInt::setValueInt(int value) {
-  _total = _total + value;
-  _samples++;
-  _value = (int) (_total / _samples);
-}
-
-// return the value
-int ChildInt::getValueInt() {
-  return _value;
-}
-
-// send the value back to the controller
-void ChildInt::sendValue() {
-  if (_samples == 0) return;
-  _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
-  _total = 0;
-  _samples = 0;
-}
-
-// check if it is an updated value
-bool ChildInt::isNewValue() {
-  return _last_value != _value;
-}
-
-/*
- ChildFloat class
-*/
-
-// ChildFloat class
-ChildFloat::ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
-}
-
-// store a new value and update the total
-void ChildFloat::setValueFloat(float value) {
-  _total = _total + value;
-  _samples++;
-  _value = _total / _samples;
-}
-
-// return the value
-float ChildFloat::getValueFloat() {
-  return _value;
-}
-
-// send the value back to the controller
-void ChildFloat::sendValue() {
-  if (_samples == 0) return;
-  _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
-  _total = 0;
-  _samples = 0;
-}
-
-// check if it is an updated value
-bool ChildFloat::isNewValue() {
-  return _last_value != _value;
-}
-
-/*
- ChildDouble class
-*/
-
-// ChildDouble class
-ChildDouble::ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
-}
-
-// store a new value and update the total
-void ChildDouble::setValueDouble(double value) {
-  _total = _total + value;
-  _samples++;
-  _value = _total / _samples;
-}
-
-// return the value
-double ChildDouble::getValueDouble() {
-  return _value;
-}
-
-// send the value back to the controller
-void ChildDouble::sendValue() {
-  if (_samples == 0) return;
-  _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
-  _total = 0;
-  _samples = 0;
-}
-
-// check if it is an updated value
-bool ChildDouble::isNewValue() {
-  return _last_value != _value;
-}
-
-/*
- ChildString class
-*/
-
-// ChildString class
-ChildString::ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description = ""): Child(sensor, child_id, presentation, type, description)  {
-}
-
-// store a new value and update the total
-void ChildString::setValueString(char* value) {
-  _value = value;
-}
-
-// return the value
-char* ChildString::getValueString() {
-  return _value;
-}
-
-// send the value back to the controller
-void ChildString::sendValue() {
-  _sensor->_node->sendMessage(child_id,type,_value);
-  _last_value = _value;
-  _value = "";
-}
-
-// check if it is an updated value
-bool ChildString::isNewValue() {
-  return strcmp(_value, _last_value) != 0;
-}
-
-/*
-   Sensor class
-*/
-// constructor
-Sensor::Sensor() {  
-}
-Sensor::Sensor(const NodeManager& node_manager, int pin = -1) {
-  _node = &node_manager;
-  _pin = pin;
-  _report_timer = new Timer(_node);
-  _node->registerSensor(this);
-}
-
-// return the name of the sensor
-char* Sensor::getName() {
-  return _name;
-}
-
-// setter/getter
-void Sensor::setPin(int value) {
-  _pin = value;
-}
-int Sensor::getPin() {
-  return _pin;
-}
-void Sensor::setSamples(int value) {
-  _samples = value;
-}
-void Sensor::setSamplesInterval(int value) {
-  _samples_interval = value;
-}
-void Sensor::setTrackLastValue(bool value) {
-  _track_last_value = value;
-}
-void Sensor::setForceUpdateMinutes(int value) {
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
-    child->force_update_timer->start(value,MINUTES);
-  }
-}
-void Sensor::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
-  if (_powerManager == nullptr) return;
-  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
-}
-void Sensor::powerOn() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOn();
-}
-void Sensor::powerOff() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOff();
-}
-int Sensor::getInterruptPin() {
-  return _interrupt_pin;
-}
-
-// After how many seconds the sensor will report back its measure
-void Sensor::setReportIntervalSeconds(int value) {
-  _report_timer->start(value,SECONDS);
-}
-
-// After how many minutes the sensor will report back its measure 
-void Sensor::setReportIntervalMinutes(int value) {
-  _report_timer->start(value,MINUTES);
-}
-
-// After how many minutes the sensor will report back its measure 
-void Sensor::setReportIntervalHours(int value) {
-  _report_timer->start(value,HOURS);
-}
-
-// After how many minutes the sensor will report back its measure 
-void Sensor::setReportIntervalDays(int value) {
-  _report_timer->start(value,DAYS);
-}
-
-
-// return true if the report interval has been already configured
-bool Sensor::isReportIntervalConfigured() {
-  return _report_timer->isConfigured();
-}
-
-// listen for interrupts on the given pin so interrupt() will be called when occurring
-void Sensor::setInterrupt(int pin, int mode, int initial) {
-  _interrupt_pin = pin;
-  _node->setInterrupt(pin,mode,initial);
-}
-
-// register a child
-void Sensor::registerChild(Child* child) {
-  children.push(child);
-}
-
-// present the sensor to the gateway and controller
-void Sensor::presentation() {
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
-    #if DEBUG == 1
-      Serial.print(F("PRES I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(child->presentation);
-    #endif
-    present(child->child_id, child->presentation,child->description,_node->getAck());
-  }
-
-}
-
-// call the sensor-specific implementation of before
-void Sensor::before() {
-  onBefore();
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" P="));
-      Serial.print(child->presentation);
-      Serial.print(F(" T="));
-      Serial.println(child->type);
-    #endif
-  }
-}
-
-// call the sensor-specific implementation of setup
-void Sensor::setup() {
-  onSetup();
-}
-
-// call the sensor-specific implementation of loop
-void Sensor::loop(MyMessage* message) {
-  // update the timers if within a loop cycle
-  if (message == nullptr) {
-    if (_report_timer->isRunning()) {
-      // keep track if it is the first time
-      bool first_run = _report_timer->isFirstRun();
-      // update the timer
-      _report_timer->update();
-      // if it is not the time yet to report a new measure, just return (unless it is the first time)
-      if (! _report_timer->isOver() && ! first_run) return;
-    }
-  }
-  // turn the sensor on
-  powerOn();
-  // iterates over all the children
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
-    // update the force update timer if running
-    if (child->force_update_timer->isRunning()) child->force_update_timer->update();
-    // if a specific child is requested, skip all the others
-    if (message != nullptr && message->sensor != child->child_id) continue;
-    // collect multiple samples if needed
-    for (int i = 0; i < _samples; i++) {
-      // we've been called from receive(), pass the message along
-      if (message != nullptr) onReceive(message);
-      // we'be been called from loop()
-      else onLoop(child);
-      // wait between samples
-      if (_samples_interval > 0) _node->sleepOrWait(_samples_interval);
-    }
-    // process the result and send a response back if 1) is not a loop 2) not tracking last value 3) tracking last value and there is a new value 4) tracking last value and timer is over
-    if (
-      message != nullptr || 
-      ! _track_last_value || 
-      _track_last_value && child->isNewValue() || 
-      _track_last_value && child->force_update_timer->isRunning() && child->force_update_timer->isOver()) 
-        child->sendValue();
-  }
-  // turn the sensor off
-  powerOff();
-  // if called from loop(), restart the report timer if over
-  if (message == nullptr && _report_timer->isRunning() && _report_timer->isOver()) _report_timer->restart();
-}
-
-// receive and handle an interrupt
-void Sensor::interrupt() {
-  // call the implementation of onInterrupt()
-  onInterrupt();
-}
-
-// receive a message from the radio network
-void Sensor::receive(const MyMessage &message) {
-  // a request would make the sensor executing its main task passing along the message
-  loop(&message);
-}
-
-// return the requested child 
-Child* Sensor::getChild(int child_id) {
-  for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
-    Child* child = *itr;
-    if (child->child_id == child_id) return child;
-  }
-  return nullptr;
-}
-
-void Sensor::setPowerManager(const PowerManager& powerManager) {
-  _powerManager = &powerManager;
-}
-
-
-// virtual functions
-void Sensor::onBefore() {}
-void Sensor::onSetup(){}
-void Sensor::onLoop(Child* child){}
-void Sensor::onReceive(MyMessage* message){}
-void Sensor::onInterrupt(){}
-
-/*
-   SensorBattery
-*/
-// contructor
-SensorBattery::SensorBattery(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "BAT";
-  // report battery level every 60 minutes by default
-  setReportIntervalMinutes(60);
-}
-void SensorBattery::setMinVoltage(float value) {
-  _battery_min = value;
-}
-void SensorBattery::setMaxVoltage(float value) {
-  _battery_max = value;
-}
-void SensorBattery::setBatteryInternalVcc(bool value) {
-  _battery_internal_vcc = value;
-}
-void SensorBattery::setBatteryPin(int value) {
-  _battery_pin = value;
-}
-void SensorBattery::setBatteryVoltsPerBit(float value) {
-  _battery_volts_per_bit = value;
-}
-
-// what to do during before
-void SensorBattery::onBefore() {
-  new ChildFloat(this,BATTERY_CHILD_ID,S_MULTIMETER,V_VOLTAGE);
-}
-
-// what to do during setup
-void SensorBattery::onSetup() {
-  // when measuring the battery from a pin, analog reference must be internal
-  if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
-}
-
-// what to do during loop
-void SensorBattery::onLoop(Child* child) {
-  // measure the board vcc
-  float volt = 0;
-  if (_battery_internal_vcc || _battery_pin == -1) volt = _node->getVcc();
-  else volt = analogRead(_battery_pin) * _battery_volts_per_bit;
-  // calculate the percentage
-  int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
-  if (percentage > 100) percentage = 100;
-  if (percentage < 0) percentage = 0;
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" V="));
-    Serial.print(volt);
-    Serial.print(F(" %="));
-    Serial.println(percentage);
-  #endif
-  ((ChildFloat*)child)->setValueFloat(volt);
-  // report battery level percentage
-  sendBatteryLevel(percentage);
-}
-
-// what to do as the main task when receiving a message
-void SensorBattery::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorBattery::onInterrupt() {
-}
-
-/*
-   SensorSignal
-*/
-// contructor
-SensorSignal::SensorSignal(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "SIG";
-  // report signal level every 60 minutes by default
-  setReportIntervalMinutes(60);
-}
-// setter/getter
-void SensorSignal::setSignalCommand(int value) {
-  _signal_command = value;
-}
-
-// what to do during before
-void SensorSignal::onBefore() {
-  new ChildInt(this,SIGNAL_CHILD_ID,S_SOUND,V_LEVEL);
-}
-
-// what to do during setup
-void SensorSignal::onSetup() {
-
-}
-
-// what to do during loop
-void SensorSignal::onLoop(Child* child) {
-  int16_t value = transportGetSignalReport(_signal_command);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" V="));
-    Serial.println(value);
-  #endif
-  ((ChildInt*)child)->setValueInt(value);
-}
-
-// what to do as the main task when receiving a message
-void SensorSignal::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorSignal::onInterrupt() {
-}
-
-/*
-   SensorConfiguration
-*/
-// contructor
-SensorConfiguration::SensorConfiguration(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "CONF";
-}
-
-// what to do during before
-void SensorConfiguration::onBefore() {
-  new ChildInt(this,CONFIGURATION_CHILD_ID,S_CUSTOM,V_CUSTOM);
-}
-
-// what to do during setup
-void SensorConfiguration::onSetup() {
-
-}
-
-// what to do during loop
-void SensorConfiguration::onLoop(Child* child) {
-}
-
-// what to do as the main task when receiving a message
-void SensorConfiguration::onReceive(MyMessage* message) {
-  // expect a REQ, V_CUSTOM message
-  if (message->getCommand() != C_REQ && message->type != V_CUSTOM) return;
-  // parse the request
-  Request request = Request(message->sensor,message->getString());
-  int function = request.getFunction();
-  int child_id = request.getChildId();
-  // if the message is for the board itself
-  if (child_id == 0) {
-    switch(function) {
-      case 1: _node->hello(); break;
-      case 3: _node->setSleepSeconds(request.getValueInt()); break;
-      case 4: _node->setSleepMinutes(request.getValueInt()); break;
-      case 5: _node->setSleepHours(request.getValueInt()); break;
-      case 29: _node->setSleepDays(request.getValueInt()); break;
-      #ifndef MY_GATEWAY_ESP8266
-        case 6: _node->reboot(); return;
-      #endif
-      case 7: _node->clearEeprom(); break;
-      case 8: _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,VERSION); return;
-      case 9: _node->wakeup(); break;
-      case 10: _node->setRetries(request.getValueInt()); break;
-      case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
-      case 20: _node->setSleepBetweenSend(request.getValueInt()); break;
-      case 21: _node->setAck(request.getValueInt()); break;
-      case 22: _node->setIsMetric(request.getValueInt()); break;
-      case 24: _node->powerOn(); break;
-      case 25: _node->powerOff(); break;
-      case 27: _node->saveToMemory(0,request.getValueInt()); break;
-      case 28: _node->setInterruptMinDelta(request.getValueInt()); break;
-      case 30: _node->setSleepOrWait(request.getValueInt()); break;
-      case 31: _node->setRebootPin(request.getValueInt()); break;
-      case 32: _node->setADCOff(); break;
-      case 36: _node->setReportIntervalSeconds(request.getValueInt()); break;
-      case 37: _node->setReportIntervalMinutes(request.getValueInt()); break;
-      case 38: _node->setReportIntervalHours(request.getValueInt()); break;
-      case 39: _node->setReportIntervalDays(request.getValueInt()); break;
-      default: return; 
-    }
-  // the request is for a sensor
-  } else {
-    // retrieve the sensor the child is belonging to
-    Sensor* sensor = _node->getSensorWithChild(child_id);
-    if (sensor == nullptr) return;
-    // if the message is for a function common to all the sensors
-    if (request.getFunction() < 100) {
-      switch(function) {
-        case 1: sensor->setPin(request.getValueInt()); break;
-        case 5: sensor->setSamples(request.getValueInt()); break;
-        case 6: sensor->setSamplesInterval(request.getValueInt()); break;
-        case 7: sensor->setTrackLastValue(request.getValueInt()); break;
-        case 9: sensor->setForceUpdateMinutes(request.getValueInt()); break;
-        case 13: sensor->powerOn(); break;
-        case 14: sensor->powerOff(); break;
-        case 16: sensor->setReportIntervalMinutes(request.getValueInt()); break;
-        case 17: sensor->setReportIntervalSeconds(request.getValueInt()); break;
-        case 19: sensor->setReportIntervalHours(request.getValueInt()); break;
-        case 20: sensor->setReportIntervalDays(request.getValueInt()); break;
-        default: return;
-      }
-    } else {
-      // the message is for a function specific to a sensor
-      if (strcmp(sensor->getName(),"BAT") == 0) {
-        SensorBattery* custom_sensor = (SensorBattery*)sensor;
-        switch(function) {
-          case 102: custom_sensor->setMinVoltage(request.getValueFloat()); break;
-          case 103: custom_sensor->setMaxVoltage(request.getValueFloat()); break;
-          case 104: custom_sensor->setBatteryInternalVcc(request.getValueInt()); break;
-          case 105: custom_sensor->setBatteryPin(request.getValueInt()); break;
-          case 106: custom_sensor->setBatteryVoltsPerBit(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      if (strcmp(sensor->getName(),"SIG") == 0) {
-        SensorSignal* custom_sensor = (SensorSignal*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setSignalCommand(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #if MODULE_SHT21 == 1
-      if (strcmp(sensor->getName(),"SHT21") == 0 || strcmp(sensor->getName(),"HTU21") == 0) {
-        SensorSHT21* custom_sensor = (SensorSHT21*)sensor;
-        switch(function) {
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_ANALOG_INPUT == 1
-      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0 || strcmp(sensor->getName(),"RAIN") == 0 || strcmp(sensor->getName(),"SOIL") == 0) {
-        SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setReference(request.getValueInt()); break;
-          case 102: custom_sensor->setReverse(request.getValueInt()); break;
-          case 103: custom_sensor->setOutputPercentage(request.getValueInt()); break;
-          case 104: custom_sensor->setRangeMin(request.getValueInt()); break;
-          case 105: custom_sensor->setRangeMax(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_THERMISTOR == 1
-      if (strcmp(sensor->getName(),"THER") == 0) {
-        SensorThermistor* custom_sensor = (SensorThermistor*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setNominalResistor((long)request.getValueInt()); break;
-          case 102: custom_sensor->setNominalTemperature(request.getValueInt()); break;
-          case 103: custom_sensor->setBCoefficient(request.getValueInt()); break;
-          case 104: custom_sensor->setSeriesResistor((long)request.getValueInt()); break;
-          case 105: custom_sensor->setOffset(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_ACS712 == 1
-      if (strcmp(sensor->getName(),"ACS") == 0) {
-        SensorACS712* custom_sensor = (SensorACS712*)sensor;
-        switch(function) {
-          case 100: custom_sensor->setmVPerAmp(request.getValueInt()); break;
-          case 102: custom_sensor->setOffset(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_DIGITAL_OUTPUT == 1
-      if (strcmp(sensor->getName(),"DOUT") == 0 || strcmp(sensor->getName(),"REL") == 0 || strcmp(sensor->getName(),"LATC") == 0) {
-        SensorDigitalOutput* custom_sensor = (SensorDigitalOutput*)sensor;
-        switch(function) {
-            case 103: custom_sensor->setOnValue(request.getValueInt()); break;
-            case 104: custom_sensor->setLegacyMode(request.getValueInt()); break;
-            case 105: custom_sensor->setSafeguard(request.getValueInt()); break;
-            case 106: custom_sensor->setInputIsElapsed(request.getValueInt()); break;
-            case 107: custom_sensor->setWaitAfterSet(request.getValueInt()); break;
-          default: return;
-        }
-        if (function > 200 && strcmp(sensor->getName(),"LATC") == 0) {
-          SensorLatchingRelay* custom_sensor_2 = (SensorLatchingRelay*)sensor;
-          switch(function) {
-            case 201: custom_sensor_2->setPulseWidth(request.getValueInt()); break;
-            case 202: custom_sensor_2->setPinOff(request.getValueInt()); break;
-            case 203: custom_sensor_2->setPinOn(request.getValueInt()); break;
-          default: return;
-        }
-        }
-      }
-      #endif
-      #if MODULE_SWITCH == 1
-      if (strcmp(sensor->getName(),"SWITCH") == 0 || strcmp(sensor->getName(),"DOOR") == 0 || strcmp(sensor->getName(),"MOTION") == 0) {
-        SensorSwitch* custom_sensor = (SensorSwitch*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setMode(request.getValueInt()); break;
-          case 102: custom_sensor->setDebounce(request.getValueInt()); break;
-          case 103: custom_sensor->setTriggerTime(request.getValueInt()); break;
-          case 104: custom_sensor->setInitial(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_DS18B20 == 1
-      if (strcmp(sensor->getName(),"DS18B20") == 0) {
-        SensorDs18b20* custom_sensor = (SensorDs18b20*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setResolution(request.getValueInt()); break;
-          case 102: custom_sensor->setSleepDuringConversion(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_BH1750 == 1
-      if (strcmp(sensor->getName(),"BH1750") == 0) {
-        SensorBH1750* custom_sensor = (SensorBH1750*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setMode(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
-      if (strcmp(sensor->getName(),"BME280") == 0) {
-        SensorBosch* custom_sensor = (SensorBosch*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setForecastSamplesCount(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_SONOFF == 1
-      if (strcmp(sensor->getName(),"SONOFF") == 0) {
-        SensorSonoff* custom_sensor = (SensorSonoff*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setButtonPin(request.getValueInt()); break;
-          case 102: custom_sensor->setRelayPin(request.getValueInt()); break;
-          case 103: custom_sensor->setLedPin(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_HCSR04 == 1
-      if (strcmp(sensor->getName(),"HCSR04") == 0) {
-        SensorHCSR04* custom_sensor = (SensorHCSR04*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setTriggerPin(request.getValueInt()); break;
-          case 102: custom_sensor->setEchoPin(request.getValueInt()); break;
-          case 103: custom_sensor->setMaxDistance(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_MQ == 1
-      if (strcmp(sensor->getName(),"MQ") == 0) {
-        SensorMQ* custom_sensor = (SensorMQ*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setTargetGas(request.getValueInt()); break;
-          case 102: custom_sensor->setRlValue(request.getValueFloat()); break;
-          case 103: custom_sensor->setRoValue(request.getValueFloat()); break;
-          case 104: custom_sensor->setCleanAirFactor(request.getValueFloat()); break;
-          case 105: custom_sensor->setCalibrationSampleTimes(request.getValueInt()); break;
-          case 106: custom_sensor->setCalibrationSampleInterval(request.getValueInt()); break;
-          case 107: custom_sensor->setReadSampleTimes(request.getValueInt()); break;
-          case 108: custom_sensor->setReadSampleInterval(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_TSL2561 == 1
-      if (strcmp(sensor->getName(),"TSL2561") == 0) {
-        SensorTSL2561* custom_sensor = (SensorTSL2561*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setGain(request.getValueInt()); break;
-          case 102: custom_sensor->setTiming(request.getValueInt()); break;
-          case 103: custom_sensor->setSpectrum(request.getValueInt()); break;
-          case 104: custom_sensor->setAddress(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_PT100 == 1
-      if (strcmp(sensor->getName(),"PT100") == 0) {
-        SensorPT100* custom_sensor = (SensorPT100*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setVoltageRef(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      #endif
-    }
-  }
-  _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
-}
-
-// what to do when receiving an interrupt
-void SensorConfiguration::onInterrupt() {
-}
-
-
-#if MODULE_ANALOG_INPUT == 1
-/*
-   SensorAnalogInput
-*/
-
-// contructor
-SensorAnalogInput::SensorAnalogInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "A-IN";
-}
-
-// setter/getter
-void SensorAnalogInput::setReference(int value) {
-  _reference = value;
-}
-void SensorAnalogInput::setReverse(bool value) {
-  _reverse = value;
-}
-void SensorAnalogInput::setOutputPercentage(bool value) {
-  _output_percentage = value;
-}
-void SensorAnalogInput::setRangeMin(int value) {
-  _range_min = value;
-}
-void SensorAnalogInput::setRangeMax(int value) {
-  _range_max = value;
-}
-
-// what to do during before
-void SensorAnalogInput::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
-}
-
-// what to do during setup
-void SensorAnalogInput::onSetup() {
-  // prepare the pin for input
-  pinMode(_pin, INPUT);
-}
-
-// what to do during loop
-void SensorAnalogInput::onLoop(Child* child) {
-  // read the input
-  int adc = _getAnalogRead();
-  // calculate the percentage
-  int percentage = 0;
-  if (_output_percentage) percentage = _getPercentage(adc);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.print(adc);
-    Serial.print(F(" %="));
-    Serial.println(percentage);
-  #endif
-  // store the result
-  ((ChildInt*)child)->setValueInt(_output_percentage ? percentage : adc);
-}
-
-// what to do during loop
-void SensorAnalogInput::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorAnalogInput::onInterrupt() {
-}
-
-// read the analog input
-int SensorAnalogInput::_getAnalogRead() {
-  #ifndef MY_GATEWAY_ESP8266
-    // set the reference
-    if (_reference != -1) {
-      analogReference(_reference);
-      wait(100);
-    }
-  #endif
-  // read and return the value
-  int value = analogRead(_pin);
-  if (_reverse) value = _range_max - value;
-  return value;
-}
-
-// return a percentage from an analog value
-int SensorAnalogInput::_getPercentage(int adc) {
-  float value = (float)adc;
-  // restore the original value
-  if (_reverse) value = 1024 - value;
-  // scale the percentage based on the range provided
-  float percentage = ((value - _range_min) / (_range_max - _range_min)) * 100;
-  if (_reverse) percentage = 100 - percentage;
-  if (percentage > 100) percentage = 100;
-  if (percentage < 0) percentage = 0;
-  return (int)percentage;
-}
-
-/*
-   SensorLDR
-*/
-
-// contructor
-SensorLDR::SensorLDR(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "LDR";
-}
-
-// what to do during before
-void SensorLDR::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
-}
-
-// what to do during setup
-void SensorLDR::onSetup() {
-  setReverse(true);
-}
-
-/*
-   SensorRain
-*/
-
-// contructor
-SensorRain::SensorRain(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "RAIN";
-}
-
-// what to do during before
-void SensorRain::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_RAIN,V_RAINRATE);
-}
-
-// what to do during setup
-void SensorRain::onSetup() {
-  setReference(DEFAULT);
-  setOutputPercentage(true);
-  setReverse(true);
-  setRangeMin(100);
-}
-
-/*
-   SensorSoilMoisture
-*/
-
-// contructor
-SensorSoilMoisture::SensorSoilMoisture(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "SOIL";
-}
-
-// what to do during before
-void SensorSoilMoisture::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_MOISTURE,V_LEVEL);
-}
-
-// what to do during setup
-void SensorSoilMoisture::onSetup() {
-  setReverse(true);
-  setReference(DEFAULT);
-  setOutputPercentage(true);
-  setReverse(true);
-  setRangeMin(100);
-}
-#endif
-
-#if MODULE_THERMISTOR == 1
-/*
-   SensorThermistor
-*/
-
-// contructor
-SensorThermistor::SensorThermistor(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "THER";
-}
-
-// setter/getter
-void SensorThermistor::setNominalResistor(long value) {
-  _nominal_resistor = value;
-}
-void SensorThermistor::setNominalTemperature(int value) {
-  _nominal_temperature = value;
-}
-void SensorThermistor::setBCoefficient(int value) {
-  _b_coefficient = value;
-}
-void SensorThermistor::setSeriesResistor(long value) {
-  _series_resistor = value;
-}
-void SensorThermistor::setOffset(float value) {
-  _offset = value;
-}
-
-// what to do during before
-void SensorThermistor::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-}
-
-// what to do during setup
-void SensorThermistor::onSetup() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
-}
-
-// what to do during loop
-void SensorThermistor::onLoop(Child* child) {
-  // read the voltage across the thermistor
-  float adc = analogRead(_pin);
-  // calculate the temperature
-  float reading = (1023 / adc)  - 1;
-  reading = _series_resistor / reading;
-  float temperature;
-  temperature = reading / _nominal_resistor;     // (R/Ro)
-  temperature = log(temperature);                  // ln(R/Ro)
-  temperature /= _b_coefficient;                   // 1/B * ln(R/Ro)
-  temperature += 1.0 / (_nominal_temperature + 273.15); // + (1/To)
-  temperature = 1.0 / temperature;                 // Invert
-  temperature -= 273.15;                         // convert to C
-  temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.print(adc);
-    Serial.print(F(" T="));
-    Serial.println(temperature);
-  #endif
-  // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-}
-
-// what to do as the main task when receiving a message
-void SensorThermistor::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorThermistor::onInterrupt() {
-}
-#endif
-
-#if MODULE_ML8511 == 1
-/*
-   SensorML8511
-*/
-
-// contructor
-SensorML8511::SensorML8511(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "UV";
-}
-
-// what to do during before
-void SensorML8511::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_UV,V_UV);
-}
-
-// what to do during setup
-void SensorML8511::onSetup() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
-}
-
-// what to do during loop
-void SensorML8511::onLoop(Child* child) {
-  // read the voltage 
-  int uvLevel = analogRead(_pin);
-  int refLevel = _node->getVcc()*1024/3.3;
-  //Use the 3.3V power pin as a reference to get a very accurate output value from sensor
-  float outputVoltage = 3.3 / refLevel * uvLevel;
-  //Convert the voltage to a UV intensity level
-  float uvIntensity = _mapfloat(outputVoltage, 0.99, 2.8, 0.0, 15.0); 
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.print(outputVoltage);
-    Serial.print(F(" I="));
-    Serial.println(uvIntensity);
-  #endif
-  // store the value
-  ((ChildFloat*)child)->setValueFloat(uvIntensity);
-}
-
-// what to do as the main task when receiving a message
-void SensorML8511::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorML8511::onInterrupt() {
-}
-
-// The Arduino Map function but for floats
-float SensorML8511::_mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-#endif
-
-#if MODULE_ACS712 == 1
-/*
-   SensorACS712
-*/
-
-// contructor
-SensorACS712::SensorACS712(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "ACS";
-}
-
-// setter/getter
-void SensorACS712::setmVPerAmp(int value) {
-  _mv_per_amp = value;
-}
-void SensorACS712::setOffset(int value) {
-  _ACS_offset = value;
-}
-
-// what to do during before
-void SensorACS712::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_MULTIMETER,V_CURRENT);
-}
-
-// what to do during setup
-void SensorACS712::onSetup() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
-}
-
-// what to do during loop
-void SensorACS712::onLoop(Child* child) {
-  int value = analogRead(_pin);
-  // convert the analog read in mV
-  double voltage = (value / 1024.0) * 5000; 
-  // convert voltage in amps
-  float value_float = ((voltage - _ACS_offset) / _mv_per_amp);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" A="));
-    Serial.println(value_float);
-  #endif
-  ((ChildFloat*)child)->setValueFloat(value_float);
-}
-
-// what to do as the main task when receiving a message
-void SensorACS712::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorACS712::onInterrupt() {
-}
-#endif
-
-#if MODULE_DIGITAL_INPUT == 1
-/*
-   SensorDigitalInput
-*/
-
-// contructor
-SensorDigitalInput::SensorDigitalInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "D-IN";
-}
-
-// what to do during before
-void SensorDigitalInput::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
-}
-
-// what to do during setup
-void SensorDigitalInput::onSetup() {
-  // set the pin for input
-  pinMode(_pin, INPUT);
-}
-
-// what to do during loop
-void SensorDigitalInput::onLoop(Child* child) {
-  // read the value
-  int value = digitalRead(_pin);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" P="));
-    Serial.print(_pin);
-    Serial.print(F(" V="));
-    Serial.println(value);
-  #endif
-  // store the value
-  ((ChildInt*)child)->setValueInt(value);
-}
-
-// what to do as the main task when receiving a message
-void SensorDigitalInput::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorDigitalInput::onInterrupt() {
-}
-#endif
-
-
-#if MODULE_DIGITAL_OUTPUT == 1
-/*
-   SensorDigitalOutput
-*/
-
-SensorDigitalOutput::SensorDigitalOutput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DOUT";
-}
-
-// what to do during before
-void SensorDigitalOutput::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
-}
-
-// what to do during setup
-void SensorDigitalOutput::onSetup() {
-  _setupPin(children.get(1), _pin);
-  _safeguard_timer = new Timer(_node);
-}
-
-// setter/getter
-void SensorDigitalOutput::setOnValue(int value) {
-  _on_value = value;
-}
-void SensorDigitalOutput::setLegacyMode(bool value) {
-  _legacy_mode = value;
-}
-void SensorDigitalOutput::setSafeguard(int value) {
-  _safeguard_timer->set(value,MINUTES);
-}
-int SensorDigitalOutput::getStatus() {
-  return _status;
-}
-void SensorDigitalOutput::setInputIsElapsed(bool value) {
-  _input_is_elapsed = value;
-}
-void SensorDigitalOutput::setWaitAfterSet(int value) {
-  _wait_after_set = value;
-}
-
-// main task
-void SensorDigitalOutput::onLoop(Child* child) {
-  // set the value to -1 so to avoid reporting to the gateway during loop
-  ((ChildInt*)child)->setValueInt(-1);
-  // if a safeguard is set, check if it is time for it
-  if (_safeguard_timer->isRunning()) {
-    // update the timer
-    _safeguard_timer->update();
-    // if the time is over, turn the output off
-    if (_safeguard_timer->isOver()) setStatus(child->child_id,OFF);
-  }
-}
-
-// what to do as the main task when receiving a message
-void SensorDigitalOutput::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  // by default handle a SET message but when legacy mode is set when a REQ message is expected instead
-  if ( (message->getCommand() == C_SET && ! _legacy_mode) || (message->getCommand() == C_REQ && _legacy_mode)) {
-    // switch the output
-    setStatus(child, message->getInt());
-  }
-  if (message->getCommand() == C_REQ && ! _legacy_mode) {
-    // just return the current status
-    ((ChildInt*)child)->setValueInt(_status);
-  }
-}
-
-// what to do when receiving an interrupt
-void SensorDigitalOutput::onInterrupt() {
-}
-
-// write the value to the output
-void SensorDigitalOutput::setStatus(Child* child, int value) {
-  // pre-process the input value
-  if (_input_is_elapsed) {
-    // the input provided is an elapsed time
-    if (value == OFF) {
-      // turning it off, no need for a safeguard anymore, stop the timer
-      _safeguard_timer->stop();
-    } 
-    else if (value == ON) {
-      // configure and start the timer
-      _safeguard_timer->start(value,MINUTES);
-      // if the input is an elapsed time, unless the value is OFF, the output will be always ON
-      value = ON;
-    }
-  } else {
-    // if turning the output on and a safeguard timer is configured, start it
-    if (value == ON && _safeguard_timer->isConfigured() && ! _safeguard_timer->isRunning()) _safeguard_timer->start();
-  }
-  _setStatus(child, value);
-  // wait if needed for relay drawing a lot of current
-  if (_wait_after_set > 0) _node->sleepOrWait(_wait_after_set);
-  // store the new status so it will be sent to the controller
-  _status = value;
-  ((ChildInt*)child)->setValueInt(value);
-}
-
-// setup the provided pin for output
-void SensorDigitalOutput::_setupPin(Child* child, int pin) {
-  // set the pin as output and initialize it accordingly
-  pinMode(pin, OUTPUT);
-  // setup the pin in a off status
-  _status = ! _on_value;
-  digitalWrite(pin, _status);
-  // the initial value is now the current value
-  ((ChildInt*)child)->setValueInt(_status);
-}
-
-// switch to the requested status
-void SensorDigitalOutput::_setStatus(Child* child, int value) {
-  int value_to_write = _getValueToWrite(value);
-  // set the value to the pin
-  digitalWrite(_pin, value_to_write);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" P="));
-    Serial.print(_pin);
-    Serial.print(F(" V="));
-    Serial.println(value_to_write);
-  #endif
-}
-
-// reverse the value if needed based on the _on_value
-int SensorDigitalOutput::_getValueToWrite(int value) {
-  int value_to_write = value;
-  if (_on_value == LOW) {
-    // if the "on" value is LOW, reverse the value
-    if (value == ON) value_to_write = LOW;
-    if (value == OFF) value_to_write = HIGH;
-  }
-  return value_to_write;
-}
-
-/*
-   SensorRelay
-*/
-
-// contructor
-SensorRelay::SensorRelay(const NodeManager& node_manager, int pin): SensorDigitalOutput(node_manager, pin) {
-  _name = "REL";
-}
-
-// what to do during before
-void SensorRelay::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
-}
-
-/*
-   SensorLatchingRelay
-*/
-
-// contructor
-SensorLatchingRelay::SensorLatchingRelay(const NodeManager& node_manager, int pin): SensorRelay(node_manager, pin) {
-  // set the "off" pin to the provided pin and the "on" pin to the provided pin + 1
-  _pin_on = pin;
-  _pin_off = pin + 1;
-}
-
-// setter/getter
-void SensorLatchingRelay::setPulseWidth(int value) {
-  _pulse_width = value;
-}
-void SensorLatchingRelay::setPinOn(int value) {
-  _pin_on = value;
-}
-void SensorLatchingRelay::setPinOff(int value) {
-  _pin_off = value;
-}
-
-// what to do during before
-void SensorLatchingRelay::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
-}
-
-// what to do during setup
-void SensorLatchingRelay::onSetup() {
-  _setupPin(children.get(1),_pin_on);
-  _setupPin(children.get(1),_pin_off);
-}
-
-// switch to the requested status
-void SensorLatchingRelay::_setStatus(Child* child, int value) {
-  // select the right pin to send the pulse to
-  int pin = value == OFF ? _pin_off : _pin_on;
-  // set the value
-  digitalWrite(pin, _on_value);
-  // wait for the given time before restoring the value to the original value after the pulse
-  _node->sleepOrWait(_pulse_width);
-  digitalWrite(pin, ! _on_value);
-  #if DEBUG == 1
-    Serial.print(F("LAT I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" P="));
-    Serial.print(pin);
-    Serial.print(F(" S="));
-    Serial.print(value);
-    Serial.print(F(" V="));
-    Serial.print(_on_value);
-    Serial.print(F(" P="));
-    Serial.println(_pulse_width);
-  #endif
-}
-
-#endif
-
-#if MODULE_DHT == 1
-/*
-   SensorDHT
-*/
-
-// contructor
-SensorDHT::SensorDHT(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DHT";
-  _dht_type = DHT::DHT11;
-}
-
-// what to do during before
-void SensorDHT::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-}
-
-// what to do during setup
-void SensorDHT::onSetup() {
-  // store the dht object
-  _dht = new DHT();
-  // initialize the dht library
-  _dht->setup(_pin,_dht_type);
-}
-
-// what to do during loop
-void SensorDHT::onLoop(Child* child) {
-  _node->sleepOrWait(_dht->getMinimumSamplingPeriod());
-  _dht->readSensor(true);
-  // temperature sensor
-  if (child->type == V_TEMP) {
-    // read the temperature
-    float temperature = _dht->getTemperature();
-    if (! _node->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-  }
-  // humidity sensor
-  else if (child->type == V_HUM) {
-    // read humidity
-    float humidity = _dht->getHumidity();
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" H="));
-      Serial.println(humidity);
-    #endif
-    // store the value
-    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
-  }
-}
-
-// what to do as the main task when receiving a message
-void SensorDHT::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorDHT::onInterrupt() {
-}
-
-/*
-   SensorDHT11
-*/
-
-// contructor
-SensorDHT11::SensorDHT11(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
-  _name = "DHT11";
-  _dht_type = DHT::DHT11;
-}
-
-/*
-   SensorDHT11
-*/
-
-// contructor
-SensorDHT22::SensorDHT22(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
-  _name = "DHT22";
-  _dht_type = DHT::DHT22;
-}
-#endif
-
-/*
-   SensorSHT21
-*/
-#if MODULE_SHT21 == 1
-// contructor
-SensorSHT21::SensorSHT21(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "SHT21";
-}
-
-// what to do during before
-void SensorSHT21::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-}
-
-// what to do during setup
-void SensorSHT21::onSetup() {
-  // initialize the library
-  Wire.begin();
-}
-
-// what to do during loop
-void SensorSHT21::onLoop(Child* child) {
-  // temperature sensor
-  if (child->type == V_TEMP) {
-    // read the temperature
-    float temperature = SHT2x.GetTemperature();
-    // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-  }
-  // Humidity Sensor
-  else if (child->type == V_HUM) {
-    // read humidity
-    float humidity = SHT2x.GetHumidity();
-    if (isnan(humidity)) return;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" H="));
-      Serial.println(humidity);
-    #endif
-    // store the value
-   if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
-  }
-}
-
-// what to do as the main task when receiving a message
-void SensorSHT21::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorSHT21::onInterrupt() {
-}
-
-/*
- * SensorHTU21D
- */
- // constructor
-SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
-  _name = "HTU21";
-}
-#endif 
-
-#if MODULE_SWITCH == 1
-/*
- * SensorSwitch
- */
-SensorSwitch::SensorSwitch(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "SWITCH";
-}
-
-// setter/getter
-void SensorSwitch::setMode(int value) {
-  _mode = value;
-}
-void SensorSwitch::setDebounce(int value) {
-  _debounce = value;
-}
-void SensorSwitch::setTriggerTime(int value) {
-  _trigger_time = value;
-}
-void SensorSwitch::setInitial(int value) {
-  _initial = value;
-}
-
-// what to do during before
-void SensorSwitch::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_TRIPPED);
-}
-
-// what to do during setup
-void SensorSwitch::onSetup() {
-  // set the interrupt pin so it will be called only when waking up from that interrupt
-  setInterrupt(_pin,_mode,_initial);
-  // report immediately
-  _report_timer->unset();
-}
-
-// what to do during loop
-void SensorSwitch::onLoop(Child* child) {
-}
-
-// what to do as the main task when receiving a message
-void SensorSwitch::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == V_STATUS) {
-    // return current status
-    ((ChildInt*)child)->setValueInt(digitalRead(_pin));
-  }
-}
-
-// what to do when receiving an interrupt
-void SensorSwitch::onInterrupt() {
-  Child* child = children.get(1);
-  // wait to ensure the the input is not floating
-  if (_debounce > 0) _node->sleepOrWait(_debounce);
-  // read the value of the pin
-  int value = digitalRead(_pin);
-  // process the value
-  if ( (_mode == RISING && value == HIGH ) || (_mode == FALLING && value == LOW) || (_mode == CHANGE) )  {
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" P="));
-      Serial.print(_pin);
-      Serial.print(F(" V="));
-      Serial.println(value);
-    #endif
-    ((ChildInt*)child)->setValueInt(value);
-    // allow the signal to be restored to its normal value
-    if (_trigger_time > 0) _node->sleepOrWait(_trigger_time);
-  } else {
-    // invalid
-    ((ChildInt*)child)->setValueInt(-1);
-  }
-}
-
-/*
- * SensorDoor
- */
-SensorDoor::SensorDoor(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
-  _name = "DOOR";
-}
-
-// what to do during before
-void SensorDoor::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_DOOR,V_TRIPPED);
-}
-
-/*
- * SensorMotion
- */
-SensorMotion::SensorMotion(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
-  _name = "MOTION";
-}
-
-// what to do during before
-void SensorMotion::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_MOTION,V_TRIPPED);
-}
-
-// what to do during setup
-void SensorMotion::onSetup() {
-  // set initial value to LOW
-  setInitial(LOW);
-}
-#endif
-
-/*
-   SensorDs18b20
-*/
-#if MODULE_DS18B20 == 1
-// contructor
-SensorDs18b20::SensorDs18b20(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DS18B20";
-}
-
-// what to do during before
-void SensorDs18b20::onBefore() {
-  // initialize the library
-  OneWire* oneWire = new OneWire(_pin);
-  DallasTemperature* _sensors = new DallasTemperature(oneWire);
-  // initialize the sensors
-  _sensors->begin();
-  // register a new child for each sensor on the bus
-  for(int i = 0; i < _sensors->getDeviceCount(); i++) {
-    new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  }
-}
-
-// what to do during setup
-void SensorDs18b20::onSetup() {
-}
-
-// what to do during loop
-void SensorDs18b20::onLoop(Child* child) {
-  int index = -1;
-  // get the index of the requested child
-  for (int i = 1; i <= children.size(); i++) {
-    if (children.get(i) == child) index = i-1;
-  }
-  // do not wait for conversion, will sleep manually during it
-  if (_sleep_during_conversion) _sensors->setWaitForConversion(false);
-  // request the temperature
-  _sensors->requestTemperatures();
-  if (_sleep_during_conversion) {
-    // calculate conversion time and sleep
-    int16_t conversion_time = _sensors->millisToWaitForConversion(_sensors->getResolution());
-    sleep(conversion_time);
-  }
-  // read the temperature
-  float temperature = _sensors->getTempCByIndex(index);
-  // convert it
-  temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" T="));
-    Serial.println(temperature);
-  #endif
-  // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-}
-
-// what to do as the main task when receiving a message
-void SensorDs18b20::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorDs18b20::onInterrupt() {
-}
-
-// returns the sensor's resolution in bits
-int SensorDs18b20::getResolution() {
-  return _sensors->getResolution();
-}
-
-// set the sensor's resolution in bits
-void SensorDs18b20::setResolution(int value) {
-  _sensors->setResolution(value);
-}
-
-// sleep while DS18B20 calculates temperature
-void SensorDs18b20::setSleepDuringConversion(bool value) {
-   _sleep_during_conversion = value;
-}
-
-#endif
-
-/*
-   SensorBH1750
-*/
-#if MODULE_BH1750 == 1
-// contructor
-SensorBH1750::SensorBH1750(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "BH1750";
-}
-// setter/getter
-void SensorBH1750::setMode(uint8_t mode) {
-  _lightSensor->configure(mode);
-}
-
-// what to do during before
-void SensorBH1750::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
-}
-
-// what to do during setup
-void SensorBH1750::onSetup() {
-  _lightSensor = new BH1750();
-  _lightSensor->begin();
-}
-
-// what to do during loop
-void SensorBH1750::onLoop(Child* child) {
-  // request the light level
-  int value = _lightSensor->readLightLevel();
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" L="));
-    Serial.println(value);
-  #endif
-  ((ChildInt*)child)->setValueInt(value);
-}
-
-// what to do as the main task when receiving a message
-void SensorBH1750::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorBH1750::onInterrupt() {
-}
-#endif
-
-/*
-   SensorMLX90614
-*/
-#if MODULE_MLX90614 == 1
-// contructor
-SensorMLX90614::SensorMLX90614(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "MLX90614";
-}
-
-// what to do during before
-void SensorMLX90614::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-}
-
-// what to do during setup
-void SensorMLX90614::onSetup() {
-  // initialize the library
-  _mlx = new Adafruit_MLX90614();
-  _mlx->begin();
-}
-
-// what to do during loop
-void SensorMLX90614::onLoop(Child* child) {
-  float temperature;
-  // the first child is the ambient temperature, the second the object temperature
-  if (children.get(1) == child) temperature = _mlx->readAmbientTempC();
-  else temperature = _mlx->readObjectTempC();
-  // convert it
-  temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
-    Serial.print(F("MLX I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" T="));
-    Serial.println(temperature);
-  #endif
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-}
-
-// what to do as the main task when receiving a message
-void SensorMLX90614::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorMLX90614::onInterrupt() {
-}
-#endif
-
-
-/*
-   SensorBosch
-*/
-#if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
-// contructor
-SensorBosch::SensorBosch(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "BOSH";
-}
-
-// setter/getter
-void SensorBosch::setForecastSamplesCount(int value) {
-  _forecast_samples_count = value;
-}
-
-// what to do during before
-void SensorBosch::onBefore() {
-}
-
-// what to do during setup
-void SensorBosch::onSetup() {
-  // initialize the forecast samples array
-  _forecast_samples = new float[_forecast_samples_count];
-}
-
-// what to do during loop
-void SensorBosch::onLoop(Child* child) {
-}
-
-// what to do as the main task when receiving a message
-void SensorBosch::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorBosch::onInterrupt() {
-}
-
-// calculate and send the forecast back
-char* SensorBosch::_forecast(float pressure) {
-  if (isnan(pressure)) return;
-  // Calculate the average of the last n minutes.
-  int index = _minute_count % _forecast_samples_count;
-  _forecast_samples[index] = pressure;
-  _minute_count++;
-  if (_minute_count > 185) _minute_count = 6;
-  if (_minute_count == 5) _pressure_avg = _getLastPressureSamplesAverage();
-  else if (_minute_count == 35) {
-    float last_pressure_avg = _getLastPressureSamplesAverage();
-    float change = (last_pressure_avg - _pressure_avg) * 0.1;
-    // first time initial 3 hour
-    if (_first_round) _dP_dt = change * 2; // note this is for t = 0.5hour
-    else _dP_dt = change / 1.5; // divide by 1.5 as this is the difference in time from 0 value.
-  }
-  else if (_minute_count == 65) {
-    float last_pressure_avg = _getLastPressureSamplesAverage();
-    float change = (last_pressure_avg - _pressure_avg) * 0.1;
-    //first time initial 3 hour
-    if (_first_round) _dP_dt = change; //note this is for t = 1 hour
-    else _dP_dt = change / 2; //divide by 2 as this is the difference in time from 0 value
-  }
-  else if (_minute_count == 95) {
-    float last_pressure_avg = _getLastPressureSamplesAverage();
-    float change = (last_pressure_avg - _pressure_avg) * 0.1;
-    // first time initial 3 hour
-    if (_first_round)_dP_dt = change / 1.5; // note this is for t = 1.5 hour
-    else _dP_dt = change / 2.5; // divide by 2.5 as this is the difference in time from 0 value
-  }
-  else if (_minute_count == 125) {
-    float last_pressure_avg = _getLastPressureSamplesAverage();
-    // store for later use.
-    _pressure_avg2 = last_pressure_avg; 
-    float change = (last_pressure_avg - _pressure_avg) * 0.1;
-    if (_first_round) _dP_dt = change / 2; // note this is for t = 2 hour
-    else _dP_dt = change / 3; // divide by 3 as this is the difference in time from 0 value
-  }
-  else if (_minute_count == 155) {
-    float last_pressure_avg = _getLastPressureSamplesAverage();
-    float change = (last_pressure_avg - _pressure_avg) * 0.1;
-    if (_first_round) _dP_dt = change / 2.5; // note this is for t = 2.5 hour
-    else _dP_dt = change / 3.5; // divide by 3.5 as this is the difference in time from 0 value
-  }
-  else if (_minute_count == 185) {
-    float last_pressure_avg = _getLastPressureSamplesAverage();
-    float change = (last_pressure_avg - _pressure_avg) * 0.1;
-    if (_first_round) _dP_dt = change / 3; // note this is for t = 3 hour
-    else _dP_dt = change / 4; // divide by 4 as this is the difference in time from 0 value
-  }
-  // Equating the pressure at 0 to the pressure at 2 hour after 3 hours have past.
-  _pressure_avg = _pressure_avg2; 
-  // flag to let you know that this is on the past 3 hour mark. Initialized to 0 outside main loop.
-  _first_round = false; 
-  // calculate the forecast (STABLE = 0, SUNNY = 1, CLOUDY = 2, UNSTABLE = 3, THUNDERSTORM = 4, UNKNOWN = 5)
-  int forecast = 5;
-  //if time is less than 35 min on the first 3 hour interval.
-  if (_minute_count < 35 && _first_round) forecast = 5;
-  else if (_dP_dt < (-0.25)) forecast = 5;
-  else if (_dP_dt > 0.25) forecast = 4;
-  else if ((_dP_dt > (-0.25)) && (_dP_dt < (-0.05))) forecast = 2;
-  else if ((_dP_dt > 0.05) && (_dP_dt < 0.25)) forecast = 1;
-  else if ((_dP_dt >(-0.05)) && (_dP_dt < 0.05)) forecast = 0;
-  else forecast = 5;
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" M="));
-    Serial.print(_minute_count);
-    Serial.print(F(" dP="));
-    Serial.print(_dP_dt);
-    Serial.print(F(" F="));
-    Serial.println(_weather[forecast]);
-  #endif
-  return _weather[forecast];
-}
-
-// returns the average of the latest pressure samples
-float SensorBosch::_getLastPressureSamplesAverage() {
-  float avg = 0;
-  for (int i = 0; i < _forecast_samples_count; i++) avg += _forecast_samples[i];
-  avg /= _forecast_samples_count;
-  return avg;
-}
-
-// search for a given chip on i2c bus
-uint8_t SensorBosch::GetI2CAddress(uint8_t chip_id) {
-  uint8_t addresses[] = {0x77, 0x76};
-  uint8_t register_address = 0xD0;
-  for (int i = 0; i <= sizeof(addresses); i++) { 
-    uint8_t i2c_address = addresses[i];
-    uint8_t value;
-    Wire.beginTransmission((uint8_t)i2c_address);
-    Wire.write((uint8_t)register_address);
-    Wire.endTransmission();
-    Wire.requestFrom((uint8_t)i2c_address, (byte)1);
-    value = Wire.read();
-    if (value == chip_id) {
-      #if DEBUG == 1
-        Serial.print(F("I2C=")); 
-        Serial.println(i2c_address);
-      #endif
-      return i2c_address;
-    }
-  }
-  return addresses[0]; 
-}
-#endif
-
-/*
- * SensorBME280
- */
-#if MODULE_BME280 == 1
-SensorBME280::SensorBME280(const NodeManager& node_manager): SensorBosch(node_manager) {
-  _name = "BME280";
-}
-
-// what to do during before
-void SensorBME280::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
-}
-
-void SensorBME280::onLoop(Child* child) {
-  // temperature sensor
-  if (child->type == V_TEMP) {
-    // read the temperature
-    float temperature = _bm->readTemperature();
-    // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-  }
-  // Humidity Sensor
-  else if (child->type == V_HUM) {
-    // read humidity
-    float humidity = _bm->readHumidity();
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" H="));
-      Serial.println(humidity);
-    #endif
-    // store the value
-    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
-  }
-  // Pressure Sensor
-  else if (child->type == V_PRESSURE) {
-    // read pressure
-    float pressure = _bm->readPressure() / 100.0F;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" P="));
-      Serial.println(pressure);
-    #endif
-    // store the value
-    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
-  }
-  // Forecast Sensor
-  else if (child->type == V_FORECAST) {
-    float pressure = _bm->readPressure() / 100.0F;
-    _forecast(pressure);
-  }
-}
-#endif
-
-/*
-   SensorBMP085
-*/
-#if MODULE_BMP085 == 1
-// contructor
-SensorBMP085::SensorBMP085(const NodeManager& node_manager): SensorBosch(node_manager) {
-  _name = "BMP085";
-}
-
-// what to do during before
-void SensorBMP085::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
-}
-
-// what to do during loop
-void SensorBMP085::onLoop(Child* child) {
-  // temperature sensor
-  if (child->type == V_TEMP) {
-    // read the temperature
-    float temperature = _bm->readTemperature();
-    // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-  }
-  // Pressure Sensor
-  else if (child->type == V_PRESSURE) {
-    // read pressure
-    float pressure = _bm->readPressure() / 100.0F;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" P="));
-      Serial.println(pressure);
-    #endif
-    // store the value
-    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
-  }
-  // Forecast Sensor
-  else if (child->type == V_FORECAST) {
-    float pressure = _bm->readPressure() / 100.0F;
-    _forecast(pressure);
-  }
-}
-#endif
-
-/*
- * SensorBMP280
- */
-#if MODULE_BMP280 == 1
-SensorBMP280::SensorBMP280(const NodeManager& node_manager): SensorBosch(node_manager) {
-  _name = "BMP280";
-}
-
-  // what to do during before
-void SensorBMP280::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_BARO,V_PRESSURE);
-  new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
-}
-
-void SensorBMP280::onLoop(Child* child) {
-  // temperature sensor
-  if (child->type == V_TEMP) {
-    // read the temperature
-    float temperature = _bm->readTemperature();
-    // convert it
-    temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-  }
-  // Pressure Sensor
-  else if (child->type == V_PRESSURE) {
-    // read pressure
-    float pressure = _bm->readPressure() / 100.0F;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" P="));
-      Serial.println(pressure);
-    #endif
-    // store the value
-    if (! isnan(pressure)) ((ChildFloat*)child)->setValueFloat(pressure);
-  }
-  // Forecast Sensor
-  else if (child->type == V_FORECAST) {
-    float pressure = _bm->readPressure() / 100.0F;
-    _forecast(pressure);
-  }
-}
-#endif
-
-/*
-   SensorSonoff
-*/
-#if MODULE_SONOFF == 1
-// contructor
-SensorSonoff::SensorSonoff(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "SONOFF";
-} 
-
-// setter/getter
-void SensorSonoff::setButtonPin(int value) {
-    _button_pin = value;
-}
-void SensorSonoff::setRelayPin(int value) {
-    _relay_pin = value;
-}
-void SensorSonoff::setLedPin(int value) {
-    _led_pin = value;
-}
-
-// what to do during before
-void SensorSonoff::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_BINARY,V_STATUS);
-}
-
-// what to do during setup
-void SensorSonoff::onSetup() {
-  // Setup the button
-  pinMode(_button_pin, INPUT_PULLUP);
-  // After setting up the button, setup debouncer
-  _debouncer.attach(_button_pin);
-  _debouncer.interval(5);
-  // Make sure relays and LED are off when starting up
-  digitalWrite(_relay_pin, _relay_off);
-  digitalWrite(_led_pin, _led_off);
-  // Then set relay pins in output mode
-  pinMode(_relay_pin, OUTPUT);
-  pinMode(_led_pin, OUTPUT);
-  _blink();
-}
-
-// what to do during loop
-void SensorSonoff::onLoop(Child* child) {
-  _debouncer.update();
-  // Get the update value from the button
-  int value = _debouncer.read();
-  if (value != _old_value && value == 0) {
-    // button pressed, toggle the state
-    _toggle(child);
-  }
-  _old_value = value;
-}
-
-// what to do as the main task when receiving a message
-void SensorSonoff::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_SET) {
-    // retrieve from the message the value to set
-    int value = message->getInt();
-    if (value != 0 && value != 1 || value == _state) return;
-    // toggle the state
-    _toggle(child);
-  }
-  if (message->getCommand() == C_REQ) {
-    // return the current state
-    ((ChildInt*)child)->setValueInt(_state);
-  }
-}
-
-// what to do when receiving an interrupt
-void SensorSonoff::onInterrupt() {
-}
-
-// toggle the state
-void SensorSonoff::_toggle(Child* child) {
-  // toggle the state
-  _state = _state ? false : true;
-  // Change relay state
-  digitalWrite(_relay_pin, _state? _relay_on: _relay_off);
-  // Change LED state
-  digitalWrite(_led_pin, _state? _led_on: _led_off);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.println(_state);
-  #endif
-  ((ChildInt*)child)->setValueInt(_state);
-}
-
-// blink the led
-void SensorSonoff::_blink() {
-  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
-  wait(200);
-  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
-  wait(200);
-  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
-  wait(200);
-  digitalWrite(_led_pin, digitalRead(_led_pin) ? _led_on : _led_off);
-}
-#endif
-
-/*
-   SensorHCSR04
-*/
-#if MODULE_HCSR04 == 1
-// contructor
-SensorHCSR04::SensorHCSR04(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "HCSR04";
-  _trigger_pin = pin;
-  _echo_pin = pin;
-}
-
-// setter/getter
-void SensorHCSR04::setTriggerPin(int value) {
-  _trigger_pin = value;
-}
-void SensorHCSR04::setEchoPin(int value) {
-  _echo_pin = value;
-}
-void SensorHCSR04::setMaxDistance(int value) {
-  _max_distance = value;
-}
-
-// what to do during before
-void SensorHCSR04::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_DISTANCE,V_DISTANCE);
-}
-
-// what to do during setup
-void SensorHCSR04::onSetup() {
-  // initialize the library
-  _sonar = new NewPing(_trigger_pin,_echo_pin,_max_distance);
-}
-
-// what to do during loop
-void SensorHCSR04::onLoop(Child* child) {
-  int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" D="));
-    Serial.println(distance);
-  #endif
-  ((ChildInt*)child)->setValueInt(distance);
-}
-
-// what to do as the main task when receiving a message
-void SensorHCSR04::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorHCSR04::onInterrupt() {
-}
-#endif
-
-/*
-   SensorMCP9808
-*/
-#if MODULE_MCP9808 == 1
-// contructor
-SensorMCP9808::SensorMCP9808(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "MCP9808";
-}
-
-// what to do during before
-void SensorMCP9808::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-}
-
-// what to do during setup
-void SensorMCP9808::onSetup() {
-  _mcp = new Adafruit_MCP9808();
-}
-
-// what to do during loop
-void SensorMCP9808::onLoop(Child* child) {
-  float temperature = _mcp->readTempC();
-  // convert it
-  temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" T="));
-    Serial.println(temperature);
-  #endif
-  // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-}
-
-// what to do as the main task when receiving a message
-void SensorMCP9808::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorMCP9808::onInterrupt() {
-}
-#endif
-
-
-/*
- * SensorMQ
- */
-#if MODULE_MQ == 1
-
-static float SensorMQ::_default_LPGCurve[3] = {2.3,0.21,-0.47};
-static float SensorMQ::_default_COCurve[3] = {2.3,0.72,-0.34};
-static float SensorMQ::_default_SmokeCurve[3] = {2.3,0.53,-0.44};
-
-SensorMQ::SensorMQ(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "MQ";
-  _LPGCurve = SensorMQ::_default_LPGCurve;
-  _COCurve = SensorMQ::_default_COCurve;
-  _SmokeCurve = SensorMQ::_default_SmokeCurve;
-}
-
-//setter/getter
-void SensorMQ::setTargetGas(int value) {
-  _target_gas = value;
-}
-void SensorMQ::setRlValue(float value) {
-  _rl_value = value;
-}
-void SensorMQ::setRoValue(float value) {
-  _ro = value;
-}
-void SensorMQ::setCleanAirFactor(float value) {
-  _ro_clean_air_factor = value;
-}
-void SensorMQ::setCalibrationSampleTimes(int value) {
-  _calibration_sample_times = value;
-}
-void SensorMQ::setCalibrationSampleInterval(int value){
-  _calibration_sample_interval = value;
-}
-void SensorMQ::setReadSampleTimes(int value) {
-  _read_sample_times = value;
-}
-void SensorMQ::setReadSampleInterval(int value) {
-  _read_sample_interval = value;
-}
-void SensorMQ::setLPGCurve(float *value) {
-  _LPGCurve = value;
-}
-void SensorMQ::setCOCurve(float *value) {
-  _COCurve = value;
-}
-void SensorMQ::setSmokeCurve(float *value) {
-  _SmokeCurve = value;
-}
-
-// what to do during before
-void SensorMQ::onBefore() {
-  // prepare the pin for input
-  pinMode(_pin, INPUT);
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
-}
-
-// what to do during setup
-void SensorMQ::onSetup() {
-  _ro = _MQCalibration();
-}
-
-// what to do during loop
-void SensorMQ::onLoop(Child* child) {
-  // calculate rs/ro
-  float mq = _MQRead()/_ro;
-  // calculate the ppm
-  float lpg = _MQGetGasPercentage(mq,_gas_lpg);
-  float co = _MQGetGasPercentage(mq,_gas_co);
-  float smoke = _MQGetGasPercentage(mq,_gas_smoke);
-  // assign to the value the requested gas
-  uint16_t value;
-  if (_target_gas == _gas_lpg) value = lpg;
-  if (_target_gas == _gas_co) value = co;
-  if (_target_gas == _gas_smoke) value = smoke;
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.print(value);
-    Serial.print(F(" LPG="));
-    Serial.print(lpg);
-    Serial.print(F(" CO="));
-    Serial.print(co);
-    Serial.print(F(" SMOKE="));
-    Serial.println(smoke);
-  #endif
-  // store the value
-  ((ChildInt*)child)->setValueInt((int16_t)ceil(value));
-}
-
-// what to do as the main task when receiving a message
-void SensorMQ::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorMQ::onInterrupt() {
-}
-
-// returns the calculated sensor resistance
-float SensorMQ::_MQResistanceCalculation(int raw_adc) {
-  return ( ((float)_rl_value*(1023-raw_adc)/raw_adc));
-}
-
-//  This function assumes that the sensor is in clean air
-float SensorMQ::_MQCalibration() {
-  int i;
-  float val=0;
-  //take multiple samples
-  for (i=0; i< _calibration_sample_times; i++) {  
-    val += _MQResistanceCalculation(analogRead(_pin));
-    wait(_calibration_sample_interval);
-  }
-  //calculate the average value
-  val = val/_calibration_sample_times;                   
-  //divided by RO_CLEAN_AIR_FACTOR yields the Ro
-  val = val/_ro_clean_air_factor;
-  //according to the chart in the datasheet
-  return val;
-}
-
-// This function use MQResistanceCalculation to caculate the sensor resistenc (Rs).
-float SensorMQ::_MQRead() {
-  int i;
-  float rs=0;
-  for (i=0; i<_read_sample_times; i++) {
-    rs += _MQResistanceCalculation(analogRead(_pin));
-    wait(_read_sample_interval);
-  }
-  rs = rs/_read_sample_times;
-  return rs;
-}
-
-// This function passes different curves to the MQGetPercentage function which calculates the ppm (parts per million) of the target gas.
-int SensorMQ::_MQGetGasPercentage(float rs_ro_ratio, int gas_id) {
-  if ( gas_id == _gas_lpg ) {
-    return _MQGetPercentage(rs_ro_ratio,_LPGCurve);
-  } else if ( gas_id == _gas_co) {
-    return _MQGetPercentage(rs_ro_ratio,_COCurve);
-  } else if ( gas_id == _gas_smoke) {
-    return _MQGetPercentage(rs_ro_ratio,_SmokeCurve);
-  }
-  return 0;
-}
-
-// returns ppm of the target gas
-int SensorMQ::_MQGetPercentage(float rs_ro_ratio, float *pcurve) {
-  return (pow(10,( ((log10(rs_ro_ratio)-pcurve[1])/pcurve[2]) + pcurve[0])));
-}
-#endif
-
-
-
-/*
-   SensorMHZ19
-*/
-#if MODULE_MHZ19 == 1
-// contructor
-SensorMHZ19::SensorMHZ19(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "MHZ19";
-  _rx_pin = pin;
-  _tx_pin = pin+1;
-}
-
-// what to do during before
-void SensorMHZ19::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_AIR_QUALITY,V_LEVEL);
-}
-
-// what to do during setup
-void SensorMHZ19::onSetup() {
-  _ser = new SoftwareSerial(_rx_pin, _tx_pin);
-  _ser->begin(9600);
-  delay(2000);
-  // clear CO2 buffer
-  while (_ser->read()!=-1) {};  
-}
-
-// what to do during loop
-void SensorMHZ19::onLoop(Child* child) {
-  // Read the ppm value
-  int co2ppm = _readCO2(); 
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" ppm="));
-    Serial.println(co2ppm);
-  #endif
-  // store the value
-  ((ChildInt*)child)->setValueInt(co2ppm);
-}
-
-
-// what to do as the main task when receiving a message
-void SensorMHZ19::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorMHZ19::onInterrupt() {
-}
-
-// Read out the CO2 data
-int SensorMHZ19::_readCO2() {
-  while (_ser->read() != -1) {};  //clear serial buffer
-  unsigned char response[9]; // for answer
-  byte cmd[9] = {0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79};
-  // Command to ask for data.
-  _ser->write(cmd, 9); //request PPM CO2
-  // Then for 1 second listen for 9 bytes of data.
-  _ser->readBytes(response, 9);
-  #if DEBUG == 1
-  for (int i=0; i<9; i++) {
-    Serial.print(response[i], HEX);
-    Serial.print(F("-"));
-  }
-  Serial.println(F("END"));
-  #endif
-  if (response[0] != 0xFF) {
-    Serial.println(F("ERR byte"));
-    return -1;
-  }
-  if (response[1] != 0x86) {
-    Serial.println(F("ERR command"));
-    return -1;
-  }
-  int responseHigh = (int) response[2];
-  int responseLow = (int) response[3];
-  int ppm = (256 * responseHigh) + responseLow;
-  return ppm;
-}
-
-#endif
-
-/*
-   SensorAM2320
-*/
-#if MODULE_AM2320 == 1
-// constructor
-SensorAM2320::SensorAM2320(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "AM2320";
-}
-
-// what do to during before
-void SensorAM2320::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-  new ChildFloat(this,_node->getAvailableChildId(),S_HUM,V_HUM);
-}
-
-// what do to during setup
-void SensorAM2320::onSetup() {
-  _th = new AM2320();
-}
-
-// what do to during loop
-void SensorAM2320::onLoop(Child* child) {
-  // read data from the sensor
-  int status = _th->Read();
-  if (status != 0) return;
-  // temperature sensor
-  if (child->type == V_TEMP) {
-    float temperature = _th->t;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(temperature);
-    #endif
-    // store the value
-    if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-  }
-  // Humidity Sensor
-  else if (child->type == V_HUM) {
-    // read humidity
-    float humidity = _th->h;
-    #if DEBUG == 1
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" T="));
-      Serial.println(humidity);
-    #endif
-    // store the value
-    if (! isnan(humidity)) ((ChildFloat*)child)->setValueFloat(humidity);
-  }
-}
-
-// what do to as the main task when receiving a message
-void SensorAM2320::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorAM2320::onInterrupt() {
-}
-#endif
-
-/*
-   SensorTSL2561
-*/
-#if MODULE_TSL2561 == 1
-// contructor
-SensorTSL2561::SensorTSL2561(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "TSL2561";
-}
-
-// setter/getter
-void SensorTSL2561::setGain(int value) {
-  _tsl_gain = value;
-}
-void SensorTSL2561::setTiming(int value) {
-  _tsl_timing = value;
-}
-void SensorTSL2561::setSpectrum(int value) {
-  _tsl_spectrum = value;
-}
-void SensorTSL2561::setAddress(int value) {
-  _tsl_address = value;
-}
-
-// what do to during before
-void SensorTSL2561::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LEVEL);
-}
-
-// what do to during setup
-void SensorTSL2561::onSetup() {
-   switch (_tsl_address) {
-    case SensorTSL2561::ADDR_FLOAT:
-      _tsl = new TSL2561(TSL2561_ADDR_FLOAT);
-      break;
-    case SensorTSL2561::ADDR_LOW:
-      _tsl = new TSL2561(TSL2561_ADDR_LOW);
-      break;   
-    case SensorTSL2561::ADDR_HIGH:
-      _tsl = new TSL2561(TSL2561_ADDR_HIGH);
-      break;   
-  }
-  if (_tsl->begin()) {
-    switch (_tsl_gain) {
-      case SensorTSL2561::GAIN_0X:
-        _tsl->setGain(TSL2561_GAIN_0X);
-        break; 
-      case SensorTSL2561::GAIN_16X:
-        _tsl->setGain(TSL2561_GAIN_16X);
-        break;      
-    }
-    switch (_tsl_timing) {
-      case SensorTSL2561::INTEGRATIONTIME_13MS:
-        _tsl->setTiming(TSL2561_INTEGRATIONTIME_13MS);
-        break; 
-      case SensorTSL2561::INTEGRATIONTIME_101MS:
-        _tsl->setTiming(TSL2561_INTEGRATIONTIME_101MS); 
-        break; 
-      case SensorTSL2561::INTEGRATIONTIME_402MS:
-        _tsl->setTiming(TSL2561_INTEGRATIONTIME_402MS); 
-        break;
-    }
-  }
-  else {
-    #if DEBUG == 1
-      Serial.println(F("ERROR"));
-    #endif
-  } 
-}
-
-// what do to during loop
-void SensorTSL2561::onLoop(Child* child) {
-  // request the light level
-   switch (_tsl_spectrum) {
-    case SensorTSL2561::VISIBLE:
-      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_VISIBLE));
-      break; 
-    case SensorTSL2561::FULLSPECTRUM:
-      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_FULLSPECTRUM));
-      break; 
-    case SensorTSL2561::INFRARED:
-      ((ChildInt*)child)->setValueInt(_tsl->getLuminosity(TSL2561_INFRARED));
-      break; 
-    case SensorTSL2561::FULL:
-      // request the full light level
-      uint32_t lum = _tsl->getFullLuminosity(); 
-      uint16_t ir, full;
-      ir = lum >> 16;
-      full = lum & 0xFFFF;
-      ((ChildInt*)child)->setValueInt(_tsl->calculateLux(full, ir));
-      #if DEBUG == 1
-        Serial.print(_name);
-        Serial.print(F(" I="));
-        Serial.print(child->child_id);
-        Serial.print(F(" LUX="));
-        Serial.print(((ChildInt*)child)->getValueInt());
-        Serial.print(F(" IR="));
-        Serial.print(ir);
-        Serial.print(F(" FULL="));
-        Serial.print(full);
-        Serial.print(F(" VIS="));
-        Serial.println(full-ir);
-      #endif
-      break; 
-  }
-  #if DEBUG == 1
-    if (_tsl_spectrum < 3) {
-      Serial.print(_name);
-      Serial.print(F(" I="));
-      Serial.print(child->child_id);
-      Serial.print(F(" L="));
-      Serial.println(((ChildInt*)child)->getValueInt());
-    }
-  #endif
-}
-
-// what do to as the main task when receiving a message
-void SensorTSL2561::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorTSL2561::onInterrupt() {
-}
-#endif
-
-/*
-   SensorPT100
-*/
-#if MODULE_PT100 == 1
-// contructor
-SensorPT100::SensorPT100(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "PT100";
-}
-
-// setter/getter
-void SensorPT100::setVoltageRef(float value) {
-   _voltageRef = value;
-}
-
-// what to do during before
-void SensorPT100::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-}
-
-// what to do during setup
-void SensorPT100::onSetup() {
-  _PT100 = new DFRobotHighTemperature(_voltageRef); 
-  // set the pin as input
-  pinMode(_pin, INPUT);
-
-}
-
-// what to do during loop
-void SensorPT100::onLoop(Child* child) {
-  // read the PT100 sensor
-  int temperature = _PT100->readTemperature(_pin);  
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" T="));
-    Serial.println(temperature);
-  #endif
-  // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
-}
-
-// what to do as the main task when receiving a message
-void SensorPT100::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorPT100::onInterrupt() {
-}
-#endif
-
-/*
-   SensorDimmer
-*/
-
-#if MODULE_DIMMER == 1
-// contructor
-SensorDimmer::SensorDimmer(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DIMMER";
-}
-
-// setter/getter
-void SensorDimmer::setEasing(int value) {
-  _easing = value;
-}
-void SensorDimmer::setDuration(int value) {
-  _duration = value*1000;
-}
-void SensorDimmer::setStepDuration(int value) {
-  _duration = value;
-}
-
-// what to do during before
-void SensorDimmer::onBefore() {
-  // register the child
-  new ChildInt(this,_node->getAvailableChildId(),S_DIMMER,V_PERCENTAGE);
-}
-
-// what to do during setup
-void SensorDimmer::onSetup() {
-  pinMode(_pin, OUTPUT);
-}
-
-// what to do during loop
-void SensorDimmer::onLoop(Child* child) {
-}
-
-// what to do as the main task when receiving a message
-void SensorDimmer::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_SET && message->type == child->type) {
-    int percentage = message->getInt();
-    // normalize the provided percentage
-    if (percentage < 0) percentage = 0;
-    if (percentage > 100) percentage = 100;
-    _fadeTo(child,percentage);
-    ((ChildInt*)child)->setValueInt(_percentage);
-  }
-  if (message->getCommand() == C_REQ) {
-    // return the current status
-    ((ChildInt*)child)->setValueInt(_percentage);
-  }
-}
-
-// what to do when receiving an interrupt
-void SensorDimmer::onInterrupt() {
-}
-
-// fade to the provided value
-void SensorDimmer::_fadeTo(Child* child, int target_percentage) {
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.println(target_percentage);
-  #endif
-  // count how many steps we need to do
-  int steps = _duration / _step_duration;
-  // for each step
-  for (int current_step = 1; current_step <= steps; current_step++) {
-    // calculate the delta between the target value and the current
-    int delta = target_percentage - _percentage;
-    // calculate the smooth transition and adjust it in the 0-255 range
-    int value_to_write = (int)(_getEasing(current_step,_percentage,delta,steps) / 100. * 255);
-    // write to the PWM output
-    analogWrite(_pin,value_to_write);
-    // wait at the end of this step
-    wait(_step_duration);
-  }
-  _percentage = target_percentage;
-}
-
-// for smooth transitions. t: current time, b: beginning value, c: change in value, d: duration
-float SensorDimmer::_getEasing(float t, float b, float c, float d) {
-  if (_easing == EASE_INSINE) return -c * cos(t/d * (M_PI/2)) + c + b;
-  else if (_easing == EASE_OUTSINE) return c * sin(t/d * (M_PI/2)) + b;
-  else if (_easing == EASE_INOUTSINE) return -c/2 * (cos(M_PI*t/d) - 1) + b;
-  else return c*t/d + b;
-}
-#endif
-
-/*
-   SensorPulseMeter
-*/
-#if MODULE_PULSE_METER == 1
-// contructor
-SensorPulseMeter::SensorPulseMeter(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "PULSE";
-}
-
-// setter/getter
-void SensorPulseMeter::setPulseFactor(float value) {
-  _pulse_factor = value;
-}
-void SensorPulseMeter::setInitialValue(int value) {
-  _initial_value = value;
-}
-void SensorPulseMeter::setInterruptMode(int value) {
-  _interrupt_mode = value;
-}
-
-// what to do during before
-void SensorPulseMeter::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
-}
-
-// what to do during setup
-void SensorPulseMeter::onSetup() {
-  // configure the interrupt pin so onInterrupt() will be called on tip
-  setInterrupt(_pin,_interrupt_mode,_initial_value);
-}
-
-// what to do during loop
-void SensorPulseMeter::onLoop(Child* child) {
-  // do not report anything if called by an interrupt
-  if (_node->getLastInterruptPin() == _interrupt_pin) return;
-  // time to report the rain so far
-  _reportTotal(child);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" T="));
-    Serial.println(((ChildFloat*)child)->getValueFloat());
-  #endif
-  // reset the counter
-  _count = 0;
-}
-
-// what to do as the main task when receiving a message
-void SensorPulseMeter::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) {
-    // report the total the last period
-    _reportTotal(child);
-  }
-}
-
-// what to do when receiving an interrupt
-void SensorPulseMeter::onInterrupt() {
-  // increase the counter
-  _count++;
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.println(F("+"));
-  #endif
-}
-
-// return the total based on the pulses counted
-void SensorPulseMeter::_reportTotal(Child* child) {
-  ((ChildFloat*)child)->setValueFloat(_count / _pulse_factor);
-}
-
-/*
-   SensorRainGauge
-*/
-// contructor
-SensorRainGauge::SensorRainGauge(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "RAING";
-}
-
-// what to do during before
-void SensorRainGauge::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_RAIN,V_RAIN);
-  setPulseFactor(9.09);
-}
-
-/*
-   SensorPowerMeter
-*/
-// contructor
-SensorPowerMeter::SensorPowerMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "POWER";
-}
-
-// what to do during before
-void SensorPowerMeter::onBefore() {
-  // register the child
-  new ChildDouble(this,_node->getAvailableChildId(),S_POWER,V_KWH);
-  setPulseFactor(1000);
-}
-
-// return the total based on the pulses counted
-void SensorPowerMeter::_reportTotal(Child* child) {
-  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
-}
-
-/*
-   SensorWaterMeter
-*/
-// contructor
-SensorWaterMeter::SensorWaterMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "WATER";
-}
-
-// what to do during before
-void SensorWaterMeter::onBefore() {
-  // register the child
-  new ChildDouble(this,_node->getAvailableChildId(),S_WATER,V_VOLUME);
-  setPulseFactor(1000);
-}
-
-// return the total based on the pulses counted
-void SensorWaterMeter::_reportTotal(Child* child) {
-  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
-}
-#endif
-
-/*******************************************
-   NodeManager
-*/
-
-// initialize the node manager
-NodeManager::NodeManager() {
-  // setup the message container
-  _message = MyMessage();
-}
-
-int NodeManager::_last_interrupt_pin = -1;
-long NodeManager::_last_interrupt_1 = millis();
-long NodeManager::_last_interrupt_2 = millis();
-long NodeManager::_interrupt_min_delta = 100;
-
-// setter/getter
-void NodeManager::setRetries(int value) {
-  _retries = value;
-}
-int NodeManager::getRetries() {
-  return _retries;
-}
-
-void NodeManager::setSleepSeconds(int value) {
-  // set the status to AWAKE if the time provided is 0, SLEEP otherwise
-  if (value == 0) _status = AWAKE;
-  else _status = SLEEP;
-  // store the time
-  _sleep_time = value;
-  // save sleep settings to eeprom
-  if (_save_sleep_settings) _saveSleepSettings();
-}
-void NodeManager::setSleepMinutes(int value) {
-  setSleepSeconds(value*60);
-}
-void NodeManager::setSleepHours(int value) {
-  setSleepMinutes(value*60);
-}
-void NodeManager::setSleepDays(int value) {
-  setSleepHours(value*24);
-}
-long NodeManager::getSleepSeconds() {
-  return _sleep_time;
-}
-void NodeManager::setSleepInterruptPin(int value) {
-  _sleep_interrupt_pin = value;
-}
-void NodeManager::setInterrupt(int pin, int mode, int initial) {
-  if (pin == INTERRUPT_PIN_1) {
-    _interrupt_1_mode = mode;
-    _interrupt_1_initial = initial;
-  }
-  if (pin == INTERRUPT_PIN_2) { 
-    _interrupt_2_mode = mode;
-    _interrupt_2_initial = initial;
-  }
-}
-void NodeManager::setInterruptMinDelta(long value) {
-  _interrupt_min_delta = value;
-}
-void NodeManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
-  if (_powerManager == nullptr) return;
-  _powerManager->setPowerPins(ground_pin, vcc_pin, wait_time);
-}
-void NodeManager::powerOn() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOn();
-}
-void NodeManager::powerOff() {
-  if (_powerManager == nullptr) return;
-  _powerManager->powerOff();
-}
-void NodeManager::setSleepBetweenSend(int value) {
-  _sleep_between_send = value;
-}
-int NodeManager::getSleepBetweenSend() {
-  return _sleep_between_send;
-}
-void NodeManager::setAck(bool value) {
-    _ack = value;
-}
-bool NodeManager::getAck() {
-    return _ack;
-}
-void NodeManager::setGetControllerConfig(bool value) {
-  _get_controller_config = value;
-}
-void NodeManager::setIsMetric(bool value) {
-  _is_metric = value;
-}
-bool NodeManager::getIsMetric() {
-  return _is_metric;
-}
-void NodeManager::setSaveSleepSettings(bool value) {
-  _save_sleep_settings = value;
-}
-
-// Convert a temperature from celsius to fahrenheit depending on how isMetric is set
-float NodeManager::celsiusToFahrenheit(float temperature) {
-  if (_is_metric) return temperature;
-  // convert the temperature from C to F
-  return temperature * 1.8 + 32;
-}
-
-// return true if sleep or wait is configured and hence this is a sleeping node
-bool NodeManager::isSleepingNode() {
-  if (_status == SLEEP) return true;
-  return false;
-}
-
-/*
-// register a sensor to this manager
-int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
-  // get a child_id if not provided by the user
-  if (child_id < 0) child_id = _getAvailableChildId();
-  // based on the given sensor type instantiate the appropriate class
-  if (sensor_type < 0) return -1;
-  #if MODULE_ANALOG_INPUT == 1
-    else if (sensor_type == SENSOR_ANALOG_INPUT) return registerSensor(new SensorAnalogInput(this,child_id, pin));
-    else if (sensor_type == SENSOR_LDR) return registerSensor(new SensorLDR(this,child_id, pin));
-    else if (sensor_type == SENSOR_THERMISTOR) return registerSensor(new SensorThermistor(this,child_id, pin));
-    else if (sensor_type == SENSOR_ML8511) return registerSensor(new SensorML8511(this,child_id, pin));
-    else if (sensor_type == SENSOR_ACS712) return registerSensor(new SensorACS712(this,child_id, pin));
-    else if (sensor_type == SENSOR_RAIN) return registerSensor(new SensorRain(this,child_id, pin));
-    else if (sensor_type == SENSOR_SOIL_MOISTURE) return registerSensor(new SensorSoilMoisture(this,child_id, pin));
-  #endif
-  #if MODULE_DIGITAL_INPUT == 1
-    else if (sensor_type == SENSOR_DIGITAL_INPUT) return registerSensor(new SensorDigitalInput(this,child_id, pin));
-  #endif
-  #if MODULE_DIGITAL_OUTPUT == 1
-    else if (sensor_type == SENSOR_DIGITAL_OUTPUT) return registerSensor(new SensorDigitalOutput(this,child_id, pin));
-    else if (sensor_type == SENSOR_RELAY) return registerSensor(new SensorRelay(this,child_id, pin));
-    else if (sensor_type == SENSOR_LATCHING_RELAY) return registerSensor(new SensorLatchingRelay(this,child_id, pin));
-  #endif
-  #if MODULE_DHT == 1
-    else if (sensor_type == SENSOR_DHT11 || sensor_type == SENSOR_DHT22) {
-      int dht_type;
-      if (sensor_type == SENSOR_DHT11) dht_type = DHT::DHT11;
-      else if (sensor_type == SENSOR_DHT22) dht_type = DHT::DHT22;
-      DHT* dht = new DHT();
-      // register temperature sensor
-      registerSensor(new SensorDHT(this,child_id,pin,dht,SensorDHT::TEMPERATURE,dht_type));
-      // register humidity sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorDHT(this,child_id,pin,dht,SensorDHT::HUMIDITY,dht_type));
-    }
-  #endif
-  #if MODULE_SHT21 == 1
-    else if (sensor_type == SENSOR_SHT21) {
-      // register temperature sensor
-      //registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
-      // register humidity sensor
-      //child_id = _getAvailableChildId();
-      //return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
-    }
-    else if (sensor_type == SENSOR_HTU21D) {
-      // register temperature sensor
-      //registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::TEMPERATURE));
-      // register humidity sensor
-      child_id = _getAvailableChildId();
-//      return registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::HUMIDITY));
-    }
-  #endif
-  #if MODULE_SWITCH == 1
-    else if (sensor_type == SENSOR_SWITCH || sensor_type == SENSOR_DOOR || sensor_type == SENSOR_MOTION) {
-      // ensure an interrupt pin is provided
-      if (pin != INTERRUPT_PIN_1 && pin != INTERRUPT_PIN_2) return -1;
-      // register the sensor
-      if (sensor_type == SENSOR_SWITCH) return registerSensor(new SensorSwitch(this,child_id, pin));
-      else if (sensor_type == SENSOR_DOOR) return registerSensor(new SensorDoor(this,child_id, pin));
-      else if (sensor_type == SENSOR_MOTION) return registerSensor(new SensorMotion(this,child_id, pin));
-    }
-  #endif
-  #if MODULE_DS18B20 == 1
-    else if (sensor_type == SENSOR_DS18B20) {
-      // initialize the library
-      OneWire* oneWire = new OneWire(pin);
-      DallasTemperature* sensors = new DallasTemperature(oneWire);
-      // initialize the sensors
-      sensors->begin();
-      int index = 0;
-      // register a new child for each sensor on the bus
-      for(int i = 0; i < sensors->getDeviceCount(); i++) {
-        if (i > 0) child_id = _getAvailableChildId();
-        index = registerSensor(new SensorDs18b20(this,child_id,pin,sensors,i));
-      }
-      return index;
-    }
-  #endif
-  #if MODULE_BH1750 == 1
-    else if (sensor_type == SENSOR_BH1750) return registerSensor(new SensorBH1750(this,child_id));
-  #endif
-  #if MODULE_MLX90614 == 1
-    else if (sensor_type == SENSOR_MLX90614) {
-      Adafruit_MLX90614* mlx = new Adafruit_MLX90614();
-      // register ambient temperature sensor
-      registerSensor(new SensorMLX90614(this,child_id,mlx,SensorMLX90614::TEMPERATURE_AMBIENT));
-      // register object temperature sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorMLX90614(this,child_id,mlx,SensorMLX90614::TEMPERATURE_OBJECT));
-    }
-  #endif
-  #if MODULE_BME280 == 1
-    else if (sensor_type == SENSOR_BME280) {
-      Adafruit_BME280* bme = new Adafruit_BME280();
-      if (! bme->begin(SensorBosch::GetI2CAddress(0x60))) {
-        #if DEBUG == 1
-          Serial.println(F("NO BME"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::TEMPERATURE));
-      child_id = _getAvailableChildId();
-      // register humidity sensor
-      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::HUMIDITY));
-      // register pressure sensor
-      child_id = _getAvailableChildId();
-      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::PRESSURE));
-      // register forecast sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::FORECAST));
-    }
-  #endif
-  #if MODULE_BMP280 == 1
-    else if (sensor_type == SENSOR_BMP280) {
-      Adafruit_BMP280* bmp = new Adafruit_BMP280();
-      if (! bmp->begin(SensorBosch::GetI2CAddress(0x58))) {
-        #if DEBUG == 1
-          Serial.println(F("NO BMP"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::TEMPERATURE));
-      child_id = _getAvailableChildId();
-      // register pressure sensor
-      child_id = _getAvailableChildId();
-      registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::PRESSURE));
-      // register forecast sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::FORECAST));
-    }
-  #endif
-  #if MODULE_SONOFF == 1
-    else if (sensor_type == SENSOR_SONOFF) return registerSensor(new SensorSonoff(this,child_id));
-  #endif
-  #if MODULE_BMP085 == 1
-    else if (sensor_type == SENSOR_BMP085) {
-      Adafruit_BMP085* bmp = new Adafruit_BMP085();
-      if (! bmp->begin(SensorBosch::GetI2CAddress(0x55))) {
-        #if DEBUG == 1
-          Serial.println(F("NO BMP"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::TEMPERATURE));
-      // register pressure sensor
-      child_id = _getAvailableChildId();
-      registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::PRESSURE));
-      // register forecast sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::FORECAST));
-    }
-  #endif
-  #if MODULE_HCSR04 == 1
-    else if (sensor_type == SENSOR_HCSR04) return registerSensor(new SensorHCSR04(this,child_id, pin));
-  #endif
-  #if MODULE_MCP9808 == 1
-    else if (sensor_type == SENSOR_MCP9808) {
-      Adafruit_MCP9808 * mcp = new Adafruit_MCP9808();
-      if (! mcp->begin()) {
-        #if DEBUG == 1
-          Serial.println(F("NO MCP"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorMCP9808(this,child_id,mcp));
-    }
-  #endif
-  #if MODULE_MQ == 1
-    else if (sensor_type == SENSOR_MQ) return registerSensor(new SensorMQ(this,child_id, pin));
-  #endif
-  #if MODULE_MHZ19 == 1
-    else if (sensor_type == SENSOR_MHZ19) return registerSensor(new SensorMHZ19(this, child_id, pin));
-  #endif
-  #if MODULE_AM2320 == 1
-    else if (sensor_type == SENSOR_AM2320) {
-      AM2320* th = new AM2320();
-      // register temperature sensor
-      registerSensor(new SensorAM2320(this,child_id,th,SensorAM2320::TEMPERATURE));
-      // register humidity sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorAM2320(this,child_id,th,SensorAM2320::HUMIDITY));
-    }
-  #endif
-  #if MODULE_TSL2561 == 1 
-    else if (sensor_type == SENSOR_TSL2561) return registerSensor(new SensorTSL2561(this,child_id));
-  #endif
-  #if MODULE_PT100 == 1 
-    else if (sensor_type == SENSOR_PT100) return registerSensor(new SensorPT100(this,child_id,pin));
-  #endif
-  #if MODULE_DIMMER == 1 
-    else if (sensor_type == SENSOR_DIMMER) return registerSensor(new SensorDimmer(this,child_id,pin));
-  #endif
-  #if MODULE_PULSE_METER == 1 
-    else if (sensor_type == SENSOR_RAIN_GAUGE) return registerSensor(new SensorRainGauge(this,child_id,pin));
-    else if (sensor_type == SENSOR_POWER_METER) return registerSensor(new SensorPowerMeter(this,child_id,pin));
-    else if (sensor_type == SENSOR_WATER_METER) return registerSensor(new SensorWaterMeter(this,child_id,pin));
-  #endif
-  else {
-    #if DEBUG == 1
-      Serial.print(F("INVALID "));
-      Serial.println(sensor_type);
-    #endif
-    return -1;
-  };
-}
-/*
-
-
-
-/*
-// attach a built-in or custom sensor to this manager
-int NodeManager::registerSensorOLD(Sensor* sensor) {
-  if (sensor->getChildId() > MAX_SENSORS) return;
-  #if DEBUG == 1
-    Serial.print(F("REG I="));
-    Serial.print(sensor->getChildId());
-    Serial.print(F(" P="));
-    Serial.print(sensor->getPin());
-    Serial.print(F(" P="));
-    Serial.print(sensor->getPresentation());
-    Serial.print(F(" T="));
-    Serial.println(sensor->getType());
-  #endif
-  #if POWER_MANAGER == 1
-    // set auto power pin
-    sensor->setAutoPowerPins(_auto_power_pins);
-  #endif
-  // add the sensor to the array of registered sensors
-  _sensors[sensor->getChildId()] = sensor;
-  // return the child_id
-  return sensor->getChildId();
-}
-*/
-
-void NodeManager::registerSensor(Sensor* sensor) {
-  sensors.push(sensor);
-}
-
-// setup NodeManager
-void NodeManager::before() {
-  // print out the version
-  #if DEBUG == 1
-    Serial.print(F("NodeManager v"));
-    Serial.println(VERSION);
-  #endif
-  // setup the reboot pin if needed
-  if (_reboot_pin > -1) {
-    #if DEBUG == 1
-      Serial.print("REB P=");
-      Serial.println(_reboot_pin);
-    #endif
-    pinMode(_reboot_pin, OUTPUT);
-    digitalWrite(_reboot_pin, HIGH);
-  }
-  // print out MySensors' library capabilities
-  #if DEBUG == 1
-    Serial.print(F("LIB V="));
-    Serial.print(MYSENSORS_LIBRARY_VERSION);
-    Serial.print(F(" R="));
-    Serial.print(MY_CAP_RADIO);
-    #ifdef MY_CAP_ENCR
-      Serial.print(F(" E="));
-      Serial.print(MY_CAP_ENCR);
-    #endif
-    Serial.print(F(" T="));
-    Serial.print(MY_CAP_TYPE);
-    Serial.print(F(" A="));
-    Serial.print(MY_CAP_ARCH);
-    Serial.print(F(" S="));
-    Serial.print(MY_CAP_SIGN);
-    Serial.print(F(" B="));
-    Serial.println(MY_CAP_RXBUF);
-  #endif
-  // restore the sleep settings saved in the eeprom
-  if (_save_sleep_settings) _loadSleepSettings();
-  // setup individual sensors
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
-    // configure reporting interval
-    if (! sensor->isReportIntervalConfigured()) sensor->setReportIntervalSeconds(_report_interval_seconds);
-    // call each sensor's before()
-    sensor->before();
-  }
-  // setup the interrupt pins
-  setupInterrupts();
-}
-
-// present NodeManager and its sensors
-void NodeManager::presentation() {
-  #if DEBUG == 1
-    Serial.println(F("RADIO OK"));
-  #endif
-  // Send the sketch version information to the gateway and Controller
-  if (_sleep_between_send > 0) sleep(_sleep_between_send);
-  sendSketchInfo(SKETCH_NAME,SKETCH_VERSION);
-  // present each sensor
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
-    // call each sensor's presentation()
-    if (_sleep_between_send > 0) sleep(_sleep_between_send);
-    sensor->presentation();
-  }
-  #if DEBUG == 1
-    Serial.println(F("READY"));
-    Serial.println("");
-  #endif
-}
-
-
-// setup NodeManager
-void NodeManager::setup() {
-  // retrieve and store isMetric from the controller
-  if (_get_controller_config) _is_metric = getControllerConfig().isMetric;
-  #if DEBUG == 1
-    Serial.print(F("MY I="));
-    Serial.print(getNodeId());
-    Serial.print(F(" M="));
-    Serial.println(_is_metric);
-  #endif
-  // run setup for all the registered sensors
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
-    // call each sensor's setup()
-    sensor->setup();
-  }
-}
-
-// run the main function for all the register sensors
-void NodeManager::loop() {
-  // turn on the pin powering all the sensors
-  powerOn();
-  // run loop for all the registered sensors
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
-    if (_last_interrupt_pin != -1 && sensor->getInterruptPin() == _last_interrupt_pin) {
-      // if there was an interrupt for this sensor, call the sensor's interrupt() and then loop()
-      _message.clear();
-      sensor->interrupt();
-      sensor->loop(nullptr);
-        // reset the last interrupt pin
-      _last_interrupt_pin = -1;
-    }
-    else if (_last_interrupt_pin == -1) {
-      // if just at the end of a cycle, call the sensor's loop() 
-      _message.clear();
-      sensor->loop(nullptr);
-    }
-  }
-  // turn off the pin powering all the sensors
-  powerOff();
-  // continue/start sleeping as requested
-  if (isSleepingNode()) _sleep();
-}
-
-// dispacth inbound messages
-void NodeManager::receive(const MyMessage &message) {
-  #if DEBUG == 1
-    Serial.print(F("RECV S="));
-    Serial.print(message.sender);
-    Serial.print(F(" I="));
-    Serial.print(message.sensor);
-    Serial.print(F(" C="));
-    Serial.print(message.getCommand());
-    Serial.print(F(" T="));
-    Serial.print(message.type);
-    Serial.print(F(" P="));
-    Serial.println(message.getString());
-  #endif
-  // dispatch the message to the registered sensor
-  Sensor* sensor = getSensorWithChild(message.sensor);
-  if (sensor != nullptr) {
-    // turn on the pin powering all the sensors
-    powerOn();
-    // call the sensor's receive()
-    sensor->receive(message);
-    // turn off the pin powering all the sensors
-    powerOff();
-  }
-}
-
-// request and return the current timestamp from the controller
-long NodeManager::getTimestamp() {
-  int retries = 3;
-  _timestamp = -1;
-  while (_timestamp == -1 && retries > 0) {
-    #if DEBUG == 1
-      Serial.println(F("TIME"));
-    #endif
-    // request the time to the controller
-    requestTime();
-    // keep asking every 1 second
-    sleepOrWait(1000);
-    retries--;
-  }  
-  return _timestamp;
-}
-
-// receive the time from the controller and save it
-void NodeManager::receiveTime(unsigned long ts) {
-  _timestamp = ts;
-  #if DEBUG == 1
-    Serial.print(F("TIME T="));
-    Serial.print(_timestamp);
-  #endif
-}
-
-// Send a hello message back to the controller
-void NodeManager::hello() {
-  // do nothing, the request will be echoed back
-}
-
-// reboot the board
-void NodeManager::reboot() {
-  #if DEBUG == 1
-    Serial.println(F("REBOOT"));
-  #endif
-  if (_reboot_pin > -1) {
-    // reboot the board through the reboot pin which is connected to RST by setting it to low
-    digitalWrite(_reboot_pin, LOW);
-  } else {
-    // Software reboot with watchdog timer. Enter Watchdog Configuration mode:
-    WDTCSR |= (1<<WDCE) | (1<<WDE);
-    // Reset enable
-    WDTCSR= (1<<WDE);
-    // Infinite loop until watchdog reset after 16 ms
-    while(true){}
-  }
-}
-
-// clear the EEPROM
-void NodeManager::clearEeprom() {
-  #if DEBUG == 1
-    Serial.println(F("CLEAR"));
-  #endif
-  for (uint16_t i=0; i<EEPROM_LOCAL_CONFIG_ADDRESS; i++) saveState(i, 0xFF);
-}
-
-// wake up the board
-void NodeManager::wakeup() {
-  #if DEBUG == 1
-    Serial.println(F("WAKEUP"));
-  #endif
-  _status = AWAKE;
-}
-
-// return the value stored at the requested index from the EEPROM
-int NodeManager::loadFromMemory(int index) {
-  return loadState(index+EEPROM_USER_START);
-}
-
-// save the given index of the EEPROM the provided value
-void NodeManager::saveToMemory(int index, int value) {
-  saveState(index+EEPROM_USER_START, value);
-}
-
-// return vcc in V
-float NodeManager::getVcc() {
-  #ifndef MY_GATEWAY_ESP8266
-    // Measure Vcc against 1.1V Vref
-    #if defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-      ADMUX = (_BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1));
-    #elif defined (__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
-      ADMUX = (_BV(MUX5) | _BV(MUX0));
-    #elif defined (__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
-      ADMUX = (_BV(MUX3) | _BV(MUX2));
-    #else
-      ADMUX = (_BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1));
-    #endif
-    // Vref settle
-    wait(70);
-    // Do conversion
-    ADCSRA |= _BV(ADSC);
-    while (bit_is_set(ADCSRA, ADSC)) {};
-    // return Vcc in mV
-    return (float)((1125300UL) / ADC) / 1000;
-  #else
-    return (float)0;
-  #endif
-}
-
-// setup the interrupt pins
-void NodeManager::setupInterrupts() {
-  // configure wakeup pin if needed
-  if (_sleep_interrupt_pin > -1) {
-    // set the interrupt when the pin is connected to ground
-    setInterrupt(_sleep_interrupt_pin,FALLING,HIGH);
-  }
-  // setup the interrupt pins
-  if (_interrupt_1_mode != MODE_NOT_DEFINED) {
-    pinMode(INTERRUPT_PIN_1,INPUT);
-    if (_interrupt_1_initial > -1) digitalWrite(INTERRUPT_PIN_1,_interrupt_1_initial);
-    // for non sleeping nodes, we need to handle the interrupt by ourselves  
-    if (_status != SLEEP) attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN_1), _onInterrupt_1, _interrupt_1_mode);
-  }
-  if (_interrupt_2_mode != MODE_NOT_DEFINED) {
-    pinMode(INTERRUPT_PIN_2, INPUT);
-    if (_interrupt_2_initial > -1) digitalWrite(INTERRUPT_PIN_2,_interrupt_2_initial);
-    // for non sleeping nodes, we need to handle the interrupt by ourselves  
-    if (_status != SLEEP) attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN_2), _onInterrupt_2, _interrupt_2_mode);
-  }
-  #if DEBUG == 1
-    Serial.print(F("INT P="));
-    Serial.print(INTERRUPT_PIN_1);
-    Serial.print(F(" M="));
-    Serial.println(_interrupt_1_mode);
-    Serial.print(F("INT P="));
-    Serial.print(INTERRUPT_PIN_2);
-    Serial.print(F(" M="));
-    Serial.println(_interrupt_2_mode);
-  #endif
-}
-
-// return the pin from which the last interrupt came
-int NodeManager::getLastInterruptPin() {
-  return _last_interrupt_pin;
-}
-
-// set the default interval in seconds all the sensors will report their measures
-void NodeManager::setReportIntervalSeconds(int value) {
-  _report_interval_seconds = value;
-}
-
-// set the default interval in minutes all the sensors will report their measures
-void NodeManager::setReportIntervalMinutes(int value) {
-  _report_interval_seconds = value*60;
-}
-
-// set the default interval in hours all the sensors will report their measures
-void NodeManager::setReportIntervalHours(int value) {
-  _report_interval_seconds = value*60*60;
-}
-
-// set the default interval in days all the sensors will report their measures
-void NodeManager::setReportIntervalDays(int value) {
-  _report_interval_seconds = value*60*60*24;
-}
-
-// if set and when the board is battery powered, sleep() is always called instead of wait()
-void NodeManager::setSleepOrWait(bool value) {
-  _sleep_or_wait = value;
-}
-
-// set which pin is connected to RST of the board to reboot the board when requested. If not set the software reboot is used instead (default: -1)
-void NodeManager::setRebootPin(int value) {
-  _reboot_pin = value;
-}
-
-// turn the ADC off so to save 0.2 mA
-void NodeManager::setADCOff() {
-  // Disable the ADC by setting the ADEN bit (bit 7) to zero
-  ADCSRA = ADCSRA & B01111111;
-  // Disable the analog comparator by setting the ACD bit (bit 7) to one
-  ACSR = B10000000;
-}
-
-// sleep if the node is a battery powered or wait if it is not for the given number of milliseconds 
-void NodeManager::sleepOrWait(long value) {
-  // if the node is sleeping, sleep-or-wait is enabled and we need to sleep for a decent amount of time, call sleep() otherwise wait()
-  if (isSleepingNode() && _sleep_or_wait && value > 200) sleep(value);
-  else wait(value);
-}
-
-// return the next available child_id
-int NodeManager::getAvailableChildId() {
-  for (int i = 1; i < 255; i++) {
-    if (i == CONFIGURATION_CHILD_ID || i == BATTERY_CHILD_ID || i == SIGNAL_CHILD_ID) continue;
-    Child* child = getChild(i);
-    if (child == nullptr) return i;
-  }
-  return 254;
-}
-
-// handle an interrupt
-void NodeManager::_onInterrupt_1() {
-  long now = millis();
-  if ( (now - _last_interrupt_1 > _interrupt_min_delta) || (now < _last_interrupt_1) ) {
-    _last_interrupt_pin = INTERRUPT_PIN_1;
-    #if DEBUG == 1
-      Serial.print(F("INT P="));
-      Serial.println(INTERRUPT_PIN_1);
-    #endif
-    _last_interrupt_1 = now;
-  }
-}
-void NodeManager::_onInterrupt_2() {
-  long now = millis();
-  if ( (now - _last_interrupt_2 > _interrupt_min_delta) || (now < _last_interrupt_2) ) {
-    _last_interrupt_pin = INTERRUPT_PIN_2;
-    #if DEBUG == 1
-      Serial.print(F("INT P="));
-      Serial.println(INTERRUPT_PIN_2);
-    #endif
-    _last_interrupt_2 = now;
-  }
-}
-
-// send a message by providing the source child, type of the message and value
-void NodeManager::sendMessage(int child_id, int type, int value) {
-  _message.clear();
-  _message.set(value);
-  _sendMessage(child_id,type);
-}
-void NodeManager::sendMessage(int child_id, int type, float value) {
-  _message.clear();
-  _message.set(value,2);
-  _sendMessage(child_id,type);
-}
-void NodeManager::sendMessage(int child_id, int type, double value) {
-  _message.clear();
-  _message.set(value,4);
-  _sendMessage(child_id,type);
-}
-void NodeManager::sendMessage(int child_id, int type, const char* value) {
-  _message.clear();
-  _message.set(value);
-  _sendMessage(child_id,type);
-}
-
-// send a message to the network
-void NodeManager::_sendMessage(int child_id, int type) {
-  // prepare the message
-  _message.setSensor(child_id);
-  _message.setType(type);
-  // send the message, multiple times if requested
-  for (int i = 0; i < _retries; i++) {
-    // if configured, sleep beetween each send
-    if (_sleep_between_send > 0) sleep(_sleep_between_send);
-    #if DEBUG == 1
-      Serial.print(F("SEND D="));
-		  Serial.print(_message.destination);
-      Serial.print(F(" I="));
-		  Serial.print(_message.sensor);
-      Serial.print(F(" C="));
-		  Serial.print(_message.getCommand());
-      Serial.print(F(" T="));
-		  Serial.print(_message.type);
-      Serial.print(F(" S="));
-		  Serial.print(_message.getString());
-      Serial.print(F(" I="));
-		  Serial.print(_message.getInt());
-      Serial.print(F(" F="));
-		  Serial.println(_message.getFloat());
-    #endif
-		send(_message, _ack);
-  }
-}
-
-void NodeManager::setPowerManager(const PowerManager& powerManager) {
-  _powerManager = &powerManager;
-}
-
-// return the requested child 
-Child* NodeManager::getChild(int child_id) {
-  Sensor* sensor = getSensorWithChild(child_id);
-  if (sensor == nullptr) return nullptr;
-  return sensor->getChild(child_id);
-}
-
-// return the sensor with the requested child 
-Sensor* NodeManager::getSensorWithChild(int child_id) {
-  for (List<Sensor*>::iterator itr = sensors.begin(); itr != sensors.end(); ++itr) {
-    Sensor* sensor = *itr;
-    Child* child = sensor->getChild(child_id);
-    if (child != nullptr) return sensor;
-  }
-  return nullptr;  
-}
-
-// wrapper of smart sleep
-void NodeManager::_sleep() {
-  #if DEBUG == 1
-    Serial.print(F("SLEEP "));
-    Serial.print(_sleep_time);
-    Serial.println(F("s"));
-  #endif
-  #if DEBUG == 1
-    // print a new line to separate the different cycles
-    Serial.println("");
-  #endif
-  // go to sleep
-  int interrupt = -1;
-  // setup interrupt pins
-  int interrupt_1_pin = _interrupt_1_mode == MODE_NOT_DEFINED ? INTERRUPT_NOT_DEFINED  : digitalPinToInterrupt(INTERRUPT_PIN_1);
-  int interrupt_2_pin = _interrupt_2_mode == MODE_NOT_DEFINED ? INTERRUPT_NOT_DEFINED  : digitalPinToInterrupt(INTERRUPT_PIN_2);
-  // enter smart sleep for the requested sleep interval and with the configured interrupts
-  interrupt = sleep(interrupt_1_pin,_interrupt_1_mode,interrupt_2_pin,_interrupt_2_mode,_sleep_time*1000, true);
-  if (interrupt > -1) {
-    // woke up by an interrupt
-    int pin_number = -1;
-    int interrupt_mode = -1;
-    // map the interrupt to the pin
-    if (digitalPinToInterrupt(INTERRUPT_PIN_1) == interrupt) {
-      pin_number = INTERRUPT_PIN_1;
-      interrupt_mode = _interrupt_1_mode;
-    }
-    if (digitalPinToInterrupt(INTERRUPT_PIN_2) == interrupt) {
-      pin_number = INTERRUPT_PIN_2;
-      interrupt_mode = _interrupt_2_mode;
-    }
-    _last_interrupt_pin = pin_number;
-    #if DEBUG == 1
-      Serial.print(F("INT P="));
-      Serial.print(pin_number);
-      Serial.print(F(", M="));
-      Serial.println(interrupt_mode);
-    #endif
-    // when waking up from an interrupt on the wakup pin, stop sleeping
-    if (_sleep_interrupt_pin == pin_number) _status = AWAKE;
-  }
-  // coming out of sleep
-  #if DEBUG == 1
-    Serial.println(F("AWAKE"));
-  #endif
-}
-
-// present the service
-void NodeManager::_present(int child_id, int type) {
-  #if DEBUG == 1
-    Serial.print(F("PRES I="));
-    Serial.print(child_id);
-    Serial.print(F(", T="));
-    Serial.println(type);
-  #endif
-  if (_sleep_between_send > 0) sleep(_sleep_between_send);
-  present(child_id,type,"",_ack);
-}
-
-// load the configuration stored in the eeprom
-void NodeManager::_loadSleepSettings() {
-  if (loadState(EEPROM_SLEEP_SAVED) == 1) {
-    // load sleep settings
-    int bit_1 = loadState(EEPROM_SLEEP_1);
-    int bit_2 = loadState(EEPROM_SLEEP_2);
-    int bit_3 = loadState(EEPROM_SLEEP_3);
-    _sleep_time = bit_3*255*255 + bit_2*255 + bit_1;
-    #if DEBUG == 1
-      Serial.print(F("LOADSLP T="));
-      Serial.println(_sleep_time);
-    #endif
-  }
-}
-
-// save the configuration in the eeprom
-void NodeManager::_saveSleepSettings() {
-  if (_sleep_time == 0) return;
-  // encode the sleep time in 3 bits
-  int bit_1, bit_2, bit_3 = 0;
-  bit_1 = _sleep_time;
-  if (bit_1 >= 255) {
-    bit_2 = (int)bit_1/255;
-    bit_1 = bit_1 - bit_2*255;
-  }
-  if (bit_2 >= 255) {
-    bit_3 = (int)bit_2/255;
-    bit_2 = bit_2 - bit_3*255;
-  }
-  // save the 3 bits
-  saveState(EEPROM_SLEEP_SAVED,1);
-  saveState(EEPROM_SLEEP_1,bit_1);
-  saveState(EEPROM_SLEEP_2,bit_2);
-  saveState(EEPROM_SLEEP_3,bit_3);
-}
-
diff --git a/NodeManager.h b/NodeManager.h
deleted file mode 100644
index 463e036..0000000
--- a/NodeManager.h
+++ /dev/null
@@ -1,1489 +0,0 @@
-/*
- * NodeManager
- */
-#ifndef NodeManager_h
-#define NodeManager_h
-
-#include <Arduino.h>
-
-// define NodeManager version
-#define VERSION "1.7-dev"
-
-/***********************************
-   Constants
-*/
-
-// define board status
-#define AWAKE 0
-#define SLEEP 1
-
-// define time unit
-#define SECONDS 0
-#define MINUTES 1
-#define HOURS 2
-#define DAYS 3
-
-// define on/off
-#define OFF 0
-#define ON 1
-
-// define value type
-#define TYPE_INTEGER 0
-#define TYPE_FLOAT 1
-#define TYPE_STRING 2
-#define TYPE_DOUBLE 2
-
-// define interrupt pins
-#define INTERRUPT_PIN_1 3
-#define INTERRUPT_PIN_2 2
-
-// define eeprom addresses
-#define EEPROM_SLEEP_SAVED 0
-#define EEPROM_SLEEP_1 5
-#define EEPROM_SLEEP_2 6
-#define EEPROM_SLEEP_3 7
-#define EEPROM_USER_START 100
-
-// define requests
-
-/************************************
- * Include user defined configuration settings
- */
- 
-#include "config.h"
-
-/***********************************
-   Default configuration settings
-*/
-// if enabled, enable debug messages on serial port
-#ifndef DEBUG
-  #define DEBUG 1
-#endif
-
-// if enabled, allow modifying the configuration remotely by interacting with the configuration child id
-// the child id used to allow remote configuration
-#ifndef CONFIGURATION_CHILD_ID
-  #define CONFIGURATION_CHILD_ID 200
-#endif
-// the child id used to report the battery voltage to the controller
-#ifndef BATTERY_CHILD_ID
-  #define BATTERY_CHILD_ID 201
-#endif
-// the child id used to report the rssi level to the controller
-#ifndef SIGNAL_CHILD_ID
-  #define SIGNAL_CHILD_ID 202
-#endif
-// define default sketch name and version
-#ifndef SKETCH_NAME
-  #define SKETCH_NAME "NodeManager"
-#endif
-#ifndef SKETCH_VERSION
-  #define SKETCH_VERSION "1.0"
-#endif
-
-/***********************************
-  Libraries
-*/
-
-// include supporting libraries
-#ifdef MY_USE_UDP
-    #include <WiFiUdp.h>
-#endif
-#ifdef MY_GATEWAY_ESP8266
-  #include <ESP8266WiFi.h>
-#endif
-
-// include MySensors libraries
-#include <core/MySensorsCore.h>
-#include <core/MyCapabilities.h>
-#include <core/MyTransport.h>
-#include <core/Version.h>
-
-// include third party libraries
-#if MODULE_DHT == 1
-  #include <DHT.h>
-#endif
-#if MODULE_SHT21 == 1
-  #include <Wire.h>
-  #include <Sodaq_SHT2x.h>
-#endif
-#if MODULE_DS18B20 == 1
-  #include <OneWire.h>
-  #include <DallasTemperature.h>
-#endif
-#if MODULE_BH1750 == 1
-  #include <BH1750.h>
-  #include <Wire.h>
-#endif
-#if MODULE_MLX90614 == 1
-  #include <Wire.h>
-  #include <Adafruit_MLX90614.h>
-#endif
-#if MODULE_BME280 == 1
-  #include <Wire.h>
-  #include <SPI.h>
-  #include <Adafruit_Sensor.h>
-  #include <Adafruit_BME280.h>
-#endif
-#if MODULE_SONOFF == 1
-  #include <Bounce2.h>
-#endif
-#if MODULE_BMP085 == 1
-  #include <Wire.h>
-  #include <Adafruit_BMP085.h>
-#endif
-#if MODULE_HCSR04 == 1
-  #include <NewPing.h>
-#endif
-#if MODULE_MCP9808 == 1
-  #include <Wire.h>
-  #include "Adafruit_MCP9808.h"
-#endif
-#if MODULE_MHZ19 == 1
-  #include <SoftwareSerial.h>
-#endif
-#if MODULE_AM2320 == 1
-  #include <Wire.h>
-  #include <AM2320.h>
-#endif
-#if MODULE_TSL2561 == 1
-  #include <TSL2561.h>
-  #include <Wire.h>
-#endif
-#if MODULE_PT100 == 1
-  #include <DFRobotHighTemperatureSensor.h>
-#endif
-#if MODULE_BMP280 == 1
-  #include <Wire.h>
-  #include <Adafruit_Sensor.h>
-  #include <Adafruit_BMP280.h>
-#endif
-#if MODULE_DIMMER == 1
-  #include <math.h>
-#endif
-
-/*******************************************************************
-   Classes
-*/
-class NodeManager;
-class Sensor;
-
-/*
- * List
- */
-template<typename T> class List {
-public:
-  typedef T* iterator;
-  List() {
-    _internalArray = NULL;
-    _endPosition = 0;
-    _allocBlocks = 0;
-    _preAllocBlocks = 0;
-  }
-  ~List() {
-    delete[] _internalArray;
-    _internalArray = NULL;
-    _endPosition = 0;
-    _allocBlocks = 0;
-    _preAllocBlocks = 0;
-  }
-  void push(T item) {
-    if (_endPosition == _allocBlocks) _AllocOneBlock(false);
-    _internalArray[_endPosition] = item;
-    ++_endPosition;
-  }
-  void pop() {
-    if (_endPosition == 0) return;
-    --_endPosition;
-    if (_allocBlocks > _preAllocBlocks) _DeAllocOneBlock(false);
-  }
-  T get(int position) {
-    position = position -1;
-    if (position > _endPosition) position = _endPosition;
-    return _internalArray[position];
-  }
-  inline iterator begin() { return _internalArray; }
-  inline iterator end() { return _internalArray + _endPosition; }
-  inline bool empty() { return (_endPosition == 0); }
-  inline unsigned int size() { return _endPosition; }
-private:
-  T* _internalArray;
-  int _endPosition;
-  int _allocBlocks;
-  int _preAllocBlocks;
-  void _AllocOneBlock(bool shiftItems) {
-    ++_allocBlocks;
-    T* newArray = new T[_allocBlocks];
-    for (int i = 0; i < _endPosition; ++i) newArray[shiftItems ? (i + 1) : i] = _internalArray[i];
-    delete[] _internalArray;
-    _internalArray = newArray;
-  }
-  void _DeAllocOneBlock(bool shiftItems) {
-    --_allocBlocks;
-    if (_allocBlocks == 0) {
-      delete[] _internalArray;
-      _internalArray = NULL;
-      return;
-    }
-    T* newArray = new T[_allocBlocks];
-    for (int i = 0; i < _endPosition; ++i) newArray[i] = _internalArray[shiftItems ? (i + 1) : i];
-    delete[] _internalArray;
-    _internalArray = newArray;
-  }
-};
-
-/*
-   PowerManager
-*/
-
-class PowerManager {
-  public:
-    PowerManager(int ground_pin, int vcc_pin, int wait_time = 50);
-    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
-    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
-    // if enabled the pins will be automatically powered on while awake and off during sleeping
-    // turns the power pins on
-    void powerOn();
-    // turns the power pins on
-    void powerOff();
-  private:
-    int _vcc_pin = -1;
-    int _ground_pin = -1;
-    long _wait = 0;
-};
-
-/*
-   Timer
-*/
-
-class Timer {
-  public:
-    Timer(NodeManager* node_manager);
-    // start the timer which will be over when the configured target passes by
-    void start(int target, int unit);
-    void start();
-    // stop the timer
-    void stop();
-    // reset the timer
-    void reset();
-    // reset the timer and start over
-    void restart();
-    // set the timer configuration but do not start it
-    void set(int target, int unit);
-    void unset();
-    // update the timer. To be called at every cycle
-    void update();
-    // return true if the time is over
-    bool isOver();
-    // return true if the timer is running
-    bool isRunning();
-    // return true if the timer has been configured
-    bool isConfigured();
-    // return true if this is the first time the timer runs
-    bool isFirstRun();
-    // return the current elapsed time
-    float getElapsed();
-   private:
-    NodeManager* _node;
-    int _target = 0;
-    long _elapsed = 0;
-    long _last_millis = 0;
-    bool _is_running = false;
-    bool _is_configured = false;
-    bool _first_run = true;
-};
-
-/*
-   Request
-*/
-
-class Request {
-  public:
-    Request(int child_id, const char* string);
-    // return the child id the message has been requested to
-    int getRecipientChildId();
-    // return the child id the request is for
-    int getChildId();
-    // return the parsed function
-    int getFunction();
-    // return the value as an int
-    int getValueInt();
-    // return the value as a float
-    float getValueFloat();
-   private:
-    int _function = -1;
-    int _child_id = -1;
-    int _recipient_child_id = -1;
-    float _value;
-};
-
-/***************************************
-   Child: child class
-*/
-
-class Child {
-  public:
-    Child();
-    Child(Sensor* sensor, int child_id, int presentation, int type, char* description);
-    int child_id;
-    int presentation = S_CUSTOM;
-    int type = V_CUSTOM;
-    char* description = "";
-    Timer* force_update_timer;
-    virtual void sendValue();
-    virtual bool isNewValue();
-  protected:
-    int _samples = 0;
-    Sensor* _sensor;
-};
-
-class ChildInt: public Child {
-  public:
-    ChildInt(Sensor* sensor, int child_id, int presentation, int type, char* description);
-    void setValueInt(int value);
-    int getValueInt();
-    void sendValue();
-    bool isNewValue();
-  private:
-    int _value;
-    int _last_value;
-    int _total = 0;
-};
-
-class ChildFloat: public Child {
-  public:
-    ChildFloat(Sensor* sensor, int child_id, int presentation, int type, char* description);
-    void setValueFloat(float value);
-    float getValueFloat();
-    void sendValue();
-    bool isNewValue();
-  private:
-    float _value;
-    float _last_value;
-    float _total = 0;
-};
-
-class ChildDouble: public Child {
-  public:
-    ChildDouble(Sensor* sensor, int child_id, int presentation, int type, char* description);
-    void setValueDouble(double value);
-    double getValueDouble();
-    void sendValue();
-    bool isNewValue();
-  private:
-    double _value;
-    double _last_value;
-    double _total = 0;
-};
-
-class ChildString: public Child {
-  public:
-    ChildString(Sensor* sensor, int child_id, int presentation, int type, char* description);
-    void setValueString(char* value);
-    char* getValueString();
-    void sendValue();
-    bool isNewValue();
-  private:
-    char* _value = "";
-    char* _last_value = "";
-};
-
-/***************************************
-   Sensor: generic sensor class
-*/
-
-class Sensor {
-  public:
-    Sensor();
-    Sensor(const NodeManager& node_manager, int pin);
-    // return the name of the sensor
-    char* getName();
-    // [1] where the sensor is attached to (default: not set)
-    void setPin(int value);
-    int getPin();
-    // [5] For some sensors, the measurement can be queried multiple times and an average is returned (default: 1)
-    void setSamples(int value);
-    // [6] If more then one sample has to be taken, set the interval in milliseconds between measurements (default: 0)
-    void setSamplesInterval(int value);
-    // [7] if true will report the measure only if different than the previous one (default: false)
-    void setTrackLastValue(bool value);
-    // [9] if track last value is enabled, force to send an update after the configured number of minutes
-    void setForceUpdateMinutes(int value);
-    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
-    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
-    // [13] manually turn the power on
-    void powerOn();
-    // [14] manually turn the power off
-    void powerOff();
-    // [17] After how many minutes the sensor will report back its measure (default: 10 minutes)
-    void setReportIntervalSeconds(int value);
-    // [16] After how many minutes the sensor will report back its measure (default: 10 minutes)
-    void setReportIntervalMinutes(int value);
-    // [19] After how many hours the sensor will report back its measure (default: 10 minutes)
-    void setReportIntervalHours(int value);
-    // [20] After how many days the sensor will report back its measure (default: 10 minutes)
-    void setReportIntervalDays(int value);
-    // return true if the report interval has been already configured
-    bool isReportIntervalConfigured();
-    // return the pin the interrupt is attached to
-    int getInterruptPin();
-    // listen for interrupts on the given pin so interrupt() will be called when occurring
-    void setInterrupt(int pin, int mode, int initial);
-    // define what to do at each stage of the sketch
-    void before();
-    void presentation();
-    void setup();
-    void loop(MyMessage* message);
-    void interrupt();
-    void receive(const MyMessage & message);
-    // abstract functions, subclasses need to implement
-    virtual void onBefore();
-    virtual void onSetup();
-    virtual void onLoop(Child* child);
-    virtual void onReceive(MyMessage* message);
-    virtual void onInterrupt();
-    List<Child*> children;
-    Child* getChild(int child_id);
-    // register a child
-    void registerChild(Child* child);
-    void setPowerManager(const PowerManager& powerManager);
-    NodeManager* _node;
-  protected:
-    const char* _name = "";
-    int _pin = -1;
-    int _samples = 1;
-    int _samples_interval = 0;
-    bool _track_last_value = false;
-    int _interrupt_pin = -1;
-    PowerManager* _powerManager = nullptr;
-    Timer* _report_timer;
-};
-
-/*
-   SensorBattery: report battery level
-*/
-class SensorBattery: public Sensor {
-  public:
-    SensorBattery(const NodeManager& nodeManager);
-      // [11] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
-      void setMinVoltage(float value);
-      // [12] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
-      void setMaxVoltage(float value);
-      // [15] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
-      void setBatteryInternalVcc(bool value);
-      // [16] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
-      void setBatteryPin(int value);
-      // [17] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
-      void setBatteryVoltsPerBit(float value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-      float _battery_min = 2.6;
-      float _battery_max = 3.3;
-      bool _battery_internal_vcc = true;
-      int _battery_pin = -1;
-      float _battery_volts_per_bit = 0.003363075;
-};
-
-/*
-   SensorSignal: report RSSI signal strength from the radio
-*/
-class SensorSignal: public Sensor {
-  public:
-    SensorSignal(const NodeManager& nodeManager);
-    // [101] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
-    void setSignalCommand(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    int _signal_command = SR_RX_RSSI;
-};
-
-/*
-   SensorConfiguration: allow remote configuration of the board and any configured sensor
-*/
-class SensorConfiguration: public Sensor {
-  public:
-    SensorConfiguration(const NodeManager& nodeManager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-};
-
-#if MODULE_ANALOG_INPUT == 1
-/*
-   SensorAnalogInput: read the analog input of a configured pin
-*/
-class SensorAnalogInput: public Sensor {
-  public:
-    SensorAnalogInput(const NodeManager& node_manager, int pin);
-    // [101] the analog reference to use (default: not set, can be either INTERNAL or DEFAULT)
-    void setReference(int value);
-    // [102] reverse the value or the percentage (e.g. 70% -> 30%) (default: false)
-    void setReverse(bool value);
-    // [103] when true returns the value as a percentage (default: true)
-    void setOutputPercentage(bool value);
-    // [104] minimum value for calculating the percentage (default: 0)
-    void setRangeMin(int value);
-    // [105] maximum value for calculating the percentage (default: 1024)
-    void setRangeMax(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    int _reference = -1;
-    bool _reverse = false;
-    bool _output_percentage = true;
-    int _range_min = 0;
-    int _range_max = 1024;
-    int _getPercentage(int value);
-    int _getAnalogRead();
-};
-
-/*
-   SensorLDR: return the percentage of light from a Light dependent resistor
-*/
-class SensorLDR: public SensorAnalogInput {
-  public:
-    SensorLDR(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-};
-
-/*
-   SensorRain
-*/
-class SensorRain: public SensorAnalogInput {
-  public:
-    SensorRain(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-};
-
-/*
-   SensorSoilMoisture
-*/
-class SensorSoilMoisture: public SensorAnalogInput {
-  public:
-    SensorSoilMoisture(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-};
-#endif
-
-#if MODULE_THERMISTOR == 1
-/*
-   SensorThermistor: read the temperature from a thermistor
-*/
-class SensorThermistor: public Sensor {
-  public:
-    SensorThermistor(const NodeManager& node_manager, int pin);
-    // [101] resistance at 25 degrees C (default: 10000)
-    void setNominalResistor(long value);
-    // [102] temperature for nominal resistance (default: 25)
-    void setNominalTemperature(int value);
-    // [103] The beta coefficient of the thermistor (default: 3950)
-    void setBCoefficient(int value);
-    // [104] the value of the resistor in series with the thermistor (default: 10000)
-    void setSeriesResistor(long value);
-    // [105] set a temperature offset
-    void setOffset(float value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    long _nominal_resistor = 10000;
-    int _nominal_temperature = 25;
-    int _b_coefficient = 3950;
-    long _series_resistor = 10000;
-    float _offset = 0;
-};
-#endif
-
-#if MODULE_ML8511 == 1
-/*
-    SensorML8511
-*/
-
-class SensorML8511: public Sensor {
-  public:
-    SensorML8511(const NodeManager& node_Manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    float _mapfloat(float x, float in_min, float in_max, float out_min, float out_max);
-};
-#endif
-
-#if MODULE_ACS712 == 1
-/*
-    SensorACS712
-*/
-
-class SensorACS712: public Sensor {
-  public:
-    SensorACS712(const NodeManager& node_manager, int pin);
-    // [101] set how many mV are equivalent to 1 Amp. The value depends on the module (100 for 20A Module, 66 for 30A Module) (default: 185);
-    void setmVPerAmp(int value);
-    // [102] set ACS offset (default: 2500);
-    void setOffset(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    int _ACS_offset = 2500;
-    int _mv_per_amp = 185;
-};
-#endif
-
-#if MODULE_DIGITAL_INPUT == 1
-/*
-   SensorDigitalInput: read the digital input of the configured pin
-*/
-class SensorDigitalInput: public Sensor {
-  public:
-    SensorDigitalInput(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-};
-#endif
-
-#if MODULE_DIGITAL_OUTPUT == 1
-/*
-   SensorDigitalOutput: control a digital output of the configured pin
-*/
-class SensorDigitalOutput: public Sensor {
-  public:
-    SensorDigitalOutput(const NodeManager& node_manager, int pin);
-    // [103] define which value to set to the output when set to on (default: HIGH)
-    void setOnValue(int value);
-    // [104] when legacy mode is enabled expect a REQ message to trigger, otherwise the default SET (default: false)
-    void setLegacyMode(bool value);
-    // [105] automatically turn the output off after the given number of minutes
-    void setSafeguard(int value);
-    // [106] if true the input value becomes a duration in minutes after which the output will be automatically turned off (default: false)
-    void setInputIsElapsed(bool value);
-    // [107] optionally wait for the given number of milliseconds after changing the status (default: 0)
-    void setWaitAfterSet(int value);
-    // manually switch the output to the provided value
-    void setStatus(Child* child, int value);
-    // get the current state
-    int getStatus();
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    int _on_value = HIGH;
-    int _status = OFF;
-    bool _legacy_mode = false;
-    bool _input_is_elapsed = false;
-    int _wait_after_set = 0;
-    Timer* _safeguard_timer;
-    void _setupPin(Child* child, int pin);
-    virtual void _setStatus(Child* child, int value);
-    int _getValueToWrite(int value);
-};
-
-/*
-   SensorRelay
-*/
-class SensorRelay: public SensorDigitalOutput {
-  public:
-    SensorRelay(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-};
-
-/*
-   SensorLatchingRelay
-*/
-class SensorLatchingRelay: public SensorRelay {
-  public:
-    SensorLatchingRelay(const NodeManager& node_manager, int pin);
-    // [201] set the duration of the pulse to send in ms to activate the relay (default: 50)
-    void setPulseWidth(int value);
-    // [202] set the pin which turns the relay off (default: the pin provided while registering the sensor)
-    void setPinOff(int value);
-    // [203] set the pin which turns the relay on (default: the pin provided while registering the sensor + 1)
-    void setPinOn(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-  protected:
-    int _pin_on;
-    int _pin_off;
-    int _pulse_width = 50;
-    void _setStatus(Child* child, int value);
-};
-#endif
-
-/*
-   SensorDHT
-*/
-#if MODULE_DHT == 1
-class SensorDHT: public Sensor {
-  public:
-    SensorDHT(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    DHT* _dht;
-    int _dht_type;
-    float _offset = 0;
-};
-
-/*
-   SensorDHT11
-*/
-class SensorDHT11: public SensorDHT {
-  public:
-    SensorDHT11(const NodeManager& node_manager, int pin);
-};
-
-/*
-   SensorDHT22
-*/
-class SensorDHT22: public SensorDHT {
-  public:
-    SensorDHT22(const NodeManager& node_manager, int pin);
-};
-#endif
-
-/*
-   SensorSHT21: temperature and humidity sensor
-*/
-#if MODULE_SHT21 == 1
-class SensorSHT21: public Sensor {
-  public:
-    SensorSHT21(const NodeManager& node_manager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-};
-
-/*
-   SensorHTU21D: temperature and humidity sensor
-*/
-
-class SensorHTU21D: public SensorSHT21 {
-  public:
-    SensorHTU21D(NodeManager& nodeManager);
-};
-#endif
-
-/*
- * SensorSwitch
- */
-#if MODULE_SWITCH == 1
-class SensorSwitch: public Sensor {
-  public:
-    SensorSwitch(const NodeManager& node_manager, int pin);
-    // [101] set the interrupt mode. Can be CHANGE, RISING, FALLING (default: CHANGE)
-    void setMode(int value);
-    // [102] milliseconds to wait before reading the input (default: 0)
-    void setDebounce(int value);
-    // [103] time to wait in milliseconds after a change is detected to allow the signal to be restored to its normal value (default: 0)
-    void setTriggerTime(int value);
-    // [104] Set initial value on the interrupt pin (default: HIGH)
-    void setInitial(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    int _debounce = 0;
-    int _trigger_time = 0;
-    int _mode = CHANGE;
-    int _initial = HIGH;
-};
-
-/*
- * SensorDoor
- */
-class SensorDoor: public SensorSwitch {
-  public:
-    SensorDoor(const NodeManager& node_manager, int pin);
-    void onBefore();
-};
-
-/*
- * SensorMotion
- */
-class SensorMotion: public SensorSwitch {
-  public:
-    SensorMotion(const NodeManager& node_manager, int pin);
-    void onBefore();
-    void onSetup();
-};
-#endif
-/*
-   SensorDs18b20
-*/
-#if MODULE_DS18B20 == 1
-class SensorDs18b20: public Sensor {
-  public:
-    SensorDs18b20(const NodeManager& node_manager, int pin);
-    // returns the sensor's resolution in bits
-    int getResolution();
-    // [101] set the sensor's resolution in bits
-    void setResolution(int value);
-    // [102] sleep while DS18B20 calculates temperature (default: false)
-    void setSleepDuringConversion(bool value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    bool _sleep_during_conversion = false;
-    DallasTemperature* _sensors;
-};
-#endif
-
-/*
-   SensorBH1750
-*/
-#if MODULE_BH1750 == 1
-class SensorBH1750: public Sensor {
-  public:
-    SensorBH1750(const NodeManager& node_manager);
-    // [101] set sensor reading mode, e.g. BH1750_ONE_TIME_HIGH_RES_MODE
-    void setMode(uint8_t mode);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    BH1750* _lightSensor;
-};
-#endif
-
-/*
-   SensorMLX90614
-*/
-#if MODULE_MLX90614 == 1
-class SensorMLX90614: public Sensor {
-  public:
-    SensorMLX90614(const NodeManager& node_manager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-    // constants
-    const static int TEMPERATURE_AMBIENT = 0;
-    const static int TEMPERATURE_OBJECT = 1;
-  protected:
-    Adafruit_MLX90614* _mlx;
-    int _sensor_type;
-};
-#endif
-
-
-/*
- * SensorBosch
-*/
-
-#if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
-class SensorBosch: public Sensor {
-  public:
-    SensorBosch(const NodeManager& node_manager);
-    // [101] define how many pressure samples to keep track of for calculating the forecast (default: 5)
-    void setForecastSamplesCount(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-    static uint8_t GetI2CAddress(uint8_t chip_id);
-  protected:
-    char* _weather[6] = { "stable", "sunny", "cloudy", "unstable", "thunderstorm", "unknown" };
-    int _forecast_samples_count = 5;
-    float* _forecast_samples;
-    int _minute_count = 0;
-    float _pressure_avg;
-    float _pressure_avg2;
-    float _dP_dt;
-    bool _first_round = true;
-    float _getLastPressureSamplesAverage();
-    char* _forecast(float pressure);
-};
-#endif
-
-/*
-   SensorBME280
-*/
-#if MODULE_BME280 == 1
-class SensorBME280: public SensorBosch {
-  public:
-    SensorBME280(const NodeManager& node_manager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onLoop(Child* child);
-  protected:
-    Adafruit_BME280* _bm;
-};
-#endif
-
-/*
-   SensorBMP085
-*/
-#if MODULE_BMP085 == 1
-class SensorBMP085: public SensorBosch {
-  public:
-    SensorBMP085(const NodeManager& node_manager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onLoop(Child* child);
-  protected:
-    Adafruit_BMP085* _bm;
-};
-#endif
-
-/*
-   SensorBMP280
-*/
-#if MODULE_BMP280 == 1
-class SensorBMP280: public SensorBosch {
-  public:
-    SensorBMP280(const NodeManager& node_manager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onLoop(Child* child);
-  protected:
-    Adafruit_BMP280* _bm;
-};
-#endif
-
-/*
-   SensorSonoff
-*/
-#if MODULE_SONOFF == 1
-class SensorSonoff: public Sensor {
-  public:
-    SensorSonoff(const NodeManager& node_manager);
-    // [101] set the button's pin (default: 0)
-    void setButtonPin(int value);
-    // [102] set the relay's pin (default: 12)
-    void setRelayPin(int value);
-    // [103] set the led's pin (default: 13)
-    void setLedPin(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    Bounce _debouncer = Bounce();
-    int _button_pin = 0;
-    int _relay_pin = 12;
-    int _led_pin = 13;
-    int _old_value = 0;
-    bool _state = false;
-    int _relay_on = 1;
-    int _relay_off = 0;
-    int _led_on = 0;
-    int _led_off = 1;
-    void _blink();
-    void _toggle(Child* child);
-};
-#endif
-
-/*
-   SensorHCSR04
-*/
-#if MODULE_HCSR04 == 1
-class SensorHCSR04: public Sensor {
-  public:
-    SensorHCSR04(const NodeManager& node_manager, int pin);
-    // [101] Arduino pin tied to trigger pin on the ultrasonic sensor (default: the pin set while registering the sensor)
-    void setTriggerPin(int value);
-    // [102] Arduino pin tied to echo pin on the ultrasonic sensor (default: the pin set while registering the sensor)
-    void setEchoPin(int value);
-    // [103] Maximum distance we want to ping for (in centimeters) (default: 300)
-    void setMaxDistance(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onProcess(Request & request);
-    void onInterrupt();
-  protected:
-    int _trigger_pin;
-    int _echo_pin;
-    int _max_distance = 300;
-    NewPing* _sonar;
-};
-#endif
-
-/*
-   SensorMCP9808
-*/
-#if MODULE_MCP9808 == 1
-class SensorMCP9808: public Sensor {
-  public:
-    SensorMCP9808(const NodeManager& node_manager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    Adafruit_MCP9808* _mcp;
-};
-#endif
-
-/*
-    SensorMQ
- */
- #if MODULE_MQ == 1
-class SensorMQ: public Sensor {
-  public:
-    SensorMQ(const NodeManager& node_manager, int pin);
-    // [101] define the target gas whose ppm has to be returned. 0: LPG, 1: CO, 2: Smoke (default: 1);
-    void setTargetGas(int value);
-    // [102] define the load resistance on the board, in kilo ohms (default: 1);
-    void setRlValue(float value);
-    // [103] define the Ro resistance on the board (default: 10000);
-    void setRoValue(float value);
-    // [104] Sensor resistance in clean air (default: 9.83);
-    void setCleanAirFactor(float value);
-    // [105] define how many samples you are going to take in the calibration phase (default: 50);
-    void setCalibrationSampleTimes(int value);
-    // [106] define the time interal(in milisecond) between each samples in the cablibration phase (default: 500);
-    void setCalibrationSampleInterval(int value);
-    // [107] define how many samples you are going to take in normal operation (default: 50);
-    void setReadSampleTimes(int value);
-    // [108] define the time interal(in milisecond) between each samples in the normal operations (default: 5);
-    void setReadSampleInterval(int value);
-    // set the LPGCurve array (default: {2.3,0.21,-0.47})
-    void setLPGCurve(float *value);
-    // set the COCurve array (default: {2.3,0.72,-0.34})
-    void setCOCurve(float *value);
-    // set the SmokeCurve array (default: {2.3,0.53,-0.44})
-    void setSmokeCurve(float *value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    float _rl_value = 1.0;
-    float _ro_clean_air_factor = 9.83;
-    int _calibration_sample_times = 50;
-    int _calibration_sample_interval = 500;
-    int _read_sample_interval = 50;
-    int _read_sample_times = 5;
-    float _ro = 10000.0;
-    static float _default_LPGCurve[3];
-    static float _default_COCurve[3];
-    static float _default_SmokeCurve[3];
-    float *_LPGCurve;
-    float *_COCurve;
-    float *_SmokeCurve;
-    float _MQResistanceCalculation(int raw_adc);
-    float _MQCalibration();
-    float _MQRead();
-    int _MQGetGasPercentage(float rs_ro_ratio, int gas_id);
-    int  _MQGetPercentage(float rs_ro_ratio, float *pcurve);
-    const static int _gas_lpg = 0;
-    const static int _gas_co = 1;
-    const static int _gas_smoke = 2;
-    int _target_gas = _gas_co;
-};
-#endif
-
-/*
-   SensorMHZ19
-*/
-#if MODULE_MHZ19 == 1
-class SensorMHZ19: public Sensor {
-  public:
-    SensorMHZ19(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    int _readCO2();
-    SoftwareSerial* _ser;
-    int _tx_pin = 6;
-    int _rx_pin = 7;
-};
-#endif
-
-/*
-   SensorAM2320
-*/
-#if MODULE_AM2320 == 1
-class SensorAM2320: public Sensor {
-  public:
-    SensorAM2320(const NodeManager& node_manager);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    AM2320* _th;
-};
-#endif
-
-/*
-   SensorTSL2561
-*/
-#if MODULE_TSL2561 == 1
-class SensorTSL2561: public Sensor {
-  public:
-    SensorTSL2561(const NodeManager& node_manager);
-    // [101] set the gain, possible values are SensorTSL2561::GAIN_0X (0), SensorTSL2561::GAIN_16X (1) (default 16x)
-    void setGain(int value);
-    // [102] set the timing, possible values are SensorTSL2561::INTEGRATIONTIME_13MS (0), SensorTSL2561::INTEGRATIONTIME_101MS (1), SensorTSL2561::INTEGRATIONTIME_402MS (2) (default: 13ms)
-    void setTiming(int value);
-    // [103] set the spectrum, possible values are SensorTSL2561::VISIBLE (0), SensorTSL2561::FULLSPECTRUM (1), SensorTSL2561::INFRARED (2), SensorTSL2561::FULL (3) (default: visible)
-    void setSpectrum(int value);
-    // [104] set the i2c address values are SensorTSL2561::ADDR_FLOAT, SensorTSL2561::ADDR_LOW, SensorTSL2561::ADDR_HIGH
-    void setAddress(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onProcess(Request & request);
-    void onInterrupt();
-    // constants
-    const static int ADDR_FLOAT = 0;
-    const static int ADDR_LOW = 1;
-    const static int ADDR_HIGH = 2;
-    const static int GAIN_0X = 0;
-    const static int GAIN_16X = 1;
-    const static int INTEGRATIONTIME_13MS = 0;
-    const static int INTEGRATIONTIME_101MS = 1;
-    const static int INTEGRATIONTIME_402MS = 2;
-    const static int VISIBLE = 0;
-    const static int FULLSPECTRUM = 1;
-    const static int INFRARED = 2;
-    const static int FULL = 3;
-  protected:
-    TSL2561* _tsl;
-    int _tsl_address = 0;
-    int _tsl_gain = 1;
-    int _tsl_timing = 0;
-    int _tsl_spectrum = 0;
-};
-#endif
-
-/*
-    SensorPT100
-*/
-#if MODULE_PT100 == 1
-class SensorPT100: public Sensor {
-  public:
-    SensorPT100(const NodeManager& node_manager, int pin);
-    // [101] set the voltageRef used to compare with analog measures
-    void setVoltageRef(float value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    DFRobotHighTemperature* _PT100;
-    float _voltageRef = 3.3;
-};
-#endif
-
-/*
-    SensorPT100
-*/
-#if MODULE_DIMMER == 1
-class SensorDimmer: public Sensor {
-  public:
-    SensorDimmer(const NodeManager& node_manager, int pin);
-    // [101] set the effect to use for a smooth transition, can be one of SensorDimmer::EASE_LINEAR, SensorDimmer::EASE_INSINE, SensorDimmer::EASE_OUTSINE, SensorDimmer::EASE_INOUTSINE (default: EASE_LINEAR)
-    void setEasing(int value);
-    // [102] the duration of entire the transition in seconds (default: 1)
-    void setDuration(int value);
-    // [103] the duration of a single step of the transition in milliseconds (default: 100)
-    void setStepDuration(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onInterrupt();
-  protected:
-    // fade the output from the current value to the target provided in the range 0-100
-    void _fadeTo(Child* child, int value);
-    enum _easing_list {
-      EASE_LINEAR,
-      EASE_INSINE,
-      EASE_OUTSINE,
-      EASE_INOUTSINE,
-    };
-    int _percentage = 0;
-    int _easing = EASE_LINEAR;
-    int _duration = 1000;
-    int _step_duration = 100;
-    float _getEasing(float t, float b, float c, float d);
-};
-#endif
-
-/*
-    SensorPulseMeter
-*/
-#if MODULE_PULSE_METER == 1
-class SensorPulseMeter: public Sensor {
-  public:
-    SensorPulseMeter(const NodeManager& node_manager, int pin);
-    // [102] set how many pulses for each unit (e.g. 1000 pulses for 1 kwh of power, 9 pulses for 1 mm of rain, etc.)
-    void setPulseFactor(float value);
-    // set initial value - internal pull up (default: HIGH)
-    void setInitialValue(int value);
-    // set the interrupt mode to attach to (default: FALLING)
-    void setInterruptMode(int value);
-    // define what to do at each stage of the sketch
-    void onBefore();
-    void onSetup();
-    void onLoop(Child* child);
-    void onReceive(MyMessage* message);
-    void onProcess(Request & request);
-    void onInterrupt();
-  protected:
-    long _count = 20;
-    float _pulse_factor;
-    int _initial_value = HIGH;
-    int _interrupt_mode = FALLING;
-    virtual void _reportTotal(Child* child);
-};
-
-/*
-    SensorRainGauge
-*/
-class SensorRainGauge: public SensorPulseMeter {
-  public:
-    SensorRainGauge(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-};
-
-/*
-    SensorPowerMeter
-*/
-class SensorPowerMeter: public SensorPulseMeter {
-  public:
-    SensorPowerMeter(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-  protected:
-    void _reportTotal(Child* child);
-};
-
-/*
-    SensorWaterMeter
-*/
-class SensorWaterMeter: public SensorPulseMeter {
-  public:
-    SensorWaterMeter(const NodeManager& node_manager, int pin);
-    // define what to do at each stage of the sketch
-    void onBefore();
-  protected:
-    void _reportTotal(Child* child);
-};
-#endif
-
-/***************************************
-   NodeManager: manages all the aspects of the node
-*/
-class NodeManager {
-  public:
-    NodeManager();
-    // [10] send the same service message multiple times (default: 1)
-    void setRetries(int value);
-    int getRetries();
-    // [3] set the duration (in seconds) of a sleep cycle
-    void setSleepSeconds(int value);
-    long getSleepSeconds();
-    // [4] set the duration (in minutes) of a sleep cycle
-    void setSleepMinutes(int value);
-    // [5] set the duration (in hours) of a sleep cycle
-    void setSleepHours(int value);
-    // [29] set the duration (in days) of a sleep cycle
-    void setSleepDays(int value);
-    // [19] if enabled, when waking up from the interrupt, the board stops sleeping. Disable it when attaching e.g. a motion sensor (default: true)
-    void setSleepInterruptPin(int value);
-    // configure the interrupt pin and mode. Mode can be CHANGE, RISING, FALLING (default: MODE_NOT_DEFINED)
-    void setInterrupt(int pin, int mode, int initial = -1);
-    // [28] ignore two consecutive interrupts if happening within this timeframe in milliseconds (default: 100)
-    void setInterruptMinDelta(long value);
-    // [20] optionally sleep interval in milliseconds before sending each message to the radio network (default: 0)
-    void setSleepBetweenSend(int value);
-    int getSleepBetweenSend();
-    // register a sensor
-    void registerSensor(Sensor* sensor);
-    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
-    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
-    // [24] manually turn the power on
-    void powerOn();
-    // [25] manually turn the power off
-    void powerOff();
-    // [21] set this to true if you want destination node to send ack back to this node (default: false)
-    void setAck(bool value);
-    bool getAck();
-    // request and return the current timestamp from the controller
-    long getTimestamp();
-    // Request the controller's configuration on startup (default: true)
-    void setGetControllerConfig(bool value);
-    // [22] Manually set isMetric setting
-    void setIsMetric(bool value);
-    bool getIsMetric();
-    // Convert a temperature from celsius to fahrenheit depending on how isMetric is set
-    float celsiusToFahrenheit(float temperature);
-    // return true if sleep or wait is configured and hence this is a sleeping node
-    bool isSleepingNode();
-    // [1] Send a hello message back to the controller
-    void hello();
-    // [6] reboot the board
-    void reboot();
-    // [7] clear the EEPROM
-    void clearEeprom();
-    // [9] wake up the board
-    void wakeup();
-    // return the value stored at the requested index from the EEPROM
-    int loadFromMemory(int index);
-    // [27] save the given index of the EEPROM the provided value
-    void saveToMemory(int index, int value);
-    // return vcc in V
-    float getVcc();
-    // setup the configured interrupt pins
-    void setupInterrupts();
-    // return the pin from which the last interrupt came
-    int getLastInterruptPin();
-    // [36] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
-    void setReportIntervalSeconds(int value);
-    // [37] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
-    void setReportIntervalMinutes(int value);
-    // [38] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
-    void setReportIntervalHours(int value);
-    // [39] set the default interval in minutes all the sensors will report their measures. If the same function is called on a specific sensor, this will not change the previously set value. or sleeping sensors, the elapsed time can be evaluated only upon wake up (default: 10 minutes)
-    void setReportIntervalDays(int value);
-    // [30] if set and when the board is battery powered, sleep() is always called instead of wait() (default: true)
-    void setSleepOrWait(bool value);
-    // sleep if the node is a battery powered or wait if it is not for the given number of milliseconds 
-    void sleepOrWait(long value);
-    // [31] set which pin is connected to RST of the board to reboot the board when requested. If not set the software reboot is used instead (default: -1)
-    void setRebootPin(int value);
-    // [32] turn the ADC off so to save 0.2 mA
-    void setADCOff();
-    // [30] if set save the sleep settings in memory, also when changed remotely (default: false)
-    void setSaveSleepSettings(bool value);
-    // hook into the main sketch functions
-    void before();
-    void presentation();
-    void setup();
-    void loop();
-    void receive(const MyMessage & msg);
-    void receiveTime(unsigned long ts);
-    // handle interrupts
-    static void _onInterrupt_1();
-    static void _onInterrupt_2();
-    // send a message by providing the source child, type of the message and value
-	  void sendMessage(int child_id, int type, int value);
-    void sendMessage(int child_id, int type, float value);
-    void sendMessage(int child_id, int type, double value);
-    void sendMessage(int child_id, int type, const char* value);
-    void setPowerManager(const PowerManager& powerManager);
-    int getAvailableChildId();
-    List<Sensor*> sensors;
-    Child* getChild(int child_id);
-    Sensor* getSensorWithChild(int child_id);
-  private:
-    PowerManager* _powerManager = nullptr;
-    MyMessage _message;
-    void _sendMessage(int child_id, int type);
-    int _status = AWAKE;
-    long _sleep_time = 0;
-    int _sleep_interrupt_pin = -1;
-    int _sleep_between_send = 0;
-    int _retries = 1;
-    int _interrupt_1_mode = MODE_NOT_DEFINED;
-    int _interrupt_2_mode = MODE_NOT_DEFINED;
-    int _interrupt_1_initial = -1;
-    int _interrupt_2_initial = -1;
-    static int _last_interrupt_pin;
-    static long _interrupt_min_delta;
-    static long _last_interrupt_1;
-    static long _last_interrupt_2;
-    long _timestamp = -1;
-    bool _ack = false;
-    void _sleep();
-    void _present(int child_id, int type);
-    bool _get_controller_config = true;
-    int _is_metric = 1;
-    int _report_interval_seconds = 10*60;
-    bool _sleep_or_wait = true;
-    int _reboot_pin = -1;
-    bool _save_sleep_settings = false;
-    void _loadSleepSettings();
-    void _saveSleepSettings();
-};
-
-#endif
diff --git a/config.h b/config.h
deleted file mode 100755
index 53fda66..0000000
--- a/config.h
+++ /dev/null
@@ -1,168 +0,0 @@
-#ifndef config_h
-#define config_h
-
-/**********************************
- * Sketch configuration
- */
-
-#define SKETCH_NAME "NodeManager"
-#define SKETCH_VERSION "1.0"
-
-/**********************************
- * MySensors node configuration
- */
-
-// General settings
-#define MY_BAUD_RATE 9600
-//#define MY_DEBUG
-#define MY_NODE_ID 99
-//#define MY_SMART_SLEEP_WAIT_DURATION_MS 500
-#define MY_SPLASH_SCREEN_DISABLED
-
-// NRF24 radio settings
-#define MY_RADIO_NRF24
-//#define MY_RF24_ENABLE_ENCRYPTION
-//#define MY_RF24_CHANNEL 125
-//#define MY_RF24_PA_LEVEL RF24_PA_HIGH
-//#define MY_DEBUG_VERBOSE_RF24
-//#define MY_RF24_DATARATE RF24_250KBPS
-
-// RFM69 radio settings
-//#define MY_RADIO_RFM69
-//#define MY_RFM69_FREQUENCY RF69_868MHZ
-//#define MY_RFM69_FREQUENCY RFM69_868MHZ
-//#define MY_IS_RFM69HW
-//#define MY_RFM69_NEW_DRIVER
-//#define MY_RFM69_ENABLE_ENCRYPTION
-//#define MY_RFM69_NETWORKID 100
-//#define MY_DEBUG_VERBOSE_RFM69
-//#define MY_RF69_IRQ_PIN D1
-//#define MY_RF69_IRQ_NUM MY_RF69_IRQ_PIN
-//#define MY_RF69_SPI_CS D2
-//#define MY_RFM69_ATC_MODE_DISABLED
-
-// RS485 serial transport settings
-//#define MY_RS485
-//#define MY_RS485_BAUD_RATE 9600
-//#define MY_RS485_DE_PIN 2
-//#define MY_RS485_MAX_MESSAGE_LENGTH 40
-//#define MY_RS485_HWSERIAL Serial1
-
-// Message signing settings
-//#define MY_SIGNING_SOFT
-//#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7
-//#define MY_SIGNING_REQUEST_SIGNATURES
-//#define MY_SIGNING_ATSHA204
-
-// OTA Firmware update settings
-//#define MY_OTA_FIRMWARE_FEATURE
-//#define OTA_WAIT_PERIOD 300
-//#define FIRMWARE_MAX_REQUESTS 2
-//#define MY_OTA_RETRY 2
-
-/**********************************
- * MySensors gateway configuration
- */
-// Common gateway settings
-//#define MY_REPEATER_FEATURE
-
-// Serial gateway settings
-//#define MY_GATEWAY_SERIAL
-
-// Ethernet gateway settings
-//#define MY_GATEWAY_W5100
-
-// ESP8266 gateway settings
-//#define MY_GATEWAY_ESP8266
-//#define MY_ESP8266_SSID ""
-//#define MY_ESP8266_PASSWORD ""
-
-// Gateway networking settings
-//#define MY_IP_ADDRESS 192,168,178,87
-//#define MY_IP_GATEWAY_ADDRESS 192,168,178,1
-//#define MY_IP_SUBNET_ADDRESS 255,255,255,0
-//#define MY_PORT 5003
-//#define MY_GATEWAY_MAX_CLIENTS 2
-//#define MY_USE_UDP
-
-// Gateway MQTT settings
-//#define MY_GATEWAY_MQTT_CLIENT
-//#define MY_CONTROLLER_IP_ADDRESS 192, 168, 178, 68
-//#define MY_PORT 1883
-//#define MY_MQTT_USER "username"
-//#define MY_MQTT_PASSWORD "password"
-//#define MY_MQTT_CLIENT_ID "mysensors-1"
-//#define MY_MQTT_PUBLISH_TOPIC_PREFIX "mygateway1-out"
-//#define MY_MQTT_SUBSCRIBE_TOPIC_PREFIX "mygateway1-in"
-
-// Gateway inclusion mode
-//#define MY_INCLUSION_MODE_FEATURE
-//#define MY_INCLUSION_BUTTON_FEATURE
-//#define MY_INCLUSION_MODE_DURATION 60
-//#define MY_DEFAULT_LED_BLINK_PERIOD 300
-
-// Gateway Leds settings
-//#define MY_DEFAULT_ERR_LED_PIN 4
-//#define MY_DEFAULT_RX_LED_PIN  5
-//#define MY_DEFAULT_TX_LED_PIN  6
-
-/***********************************
- * NodeManager configuration
- */
-
-// if enabled, enable debug messages on serial port
-#define DEBUG 1
-
-// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SensorRain, SensorSoilMoisture
-#define MODULE_ANALOG_INPUT 0
-// Enable this module to use one of the following sensors: SensorThermistor
-#define MODULE_THERMISTOR 0
-// Enable this module to use one of the following sensors: SensorML8511
-#define MODULE_ML8511 0
-// Enable this module to use one of the following sensors: SensorACS712
-#define MODULE_ACS712 0
-// Enable this module to use one of the following sensors: SensorDigitalInput
-#define MODULE_DIGITAL_INPUT 0
-// Enable this module to use one of the following sensors: SensorDigitalOutput, SensorRelay, SensorLatchingRelay
-#define MODULE_DIGITAL_OUTPUT 0
-// Enable this module to use one of the following sensors: SensorDHT11, SensorDHT22
-#define MODULE_DHT 0
-// Enable this module to use one of the following sensors: SensorSHT21, SensorHTU21D
-#define MODULE_SHT21 0
-// Enable this module to use one of the following sensors: SensorSwitch, SensorDoor, SensorMotion
-#define MODULE_SWITCH 0
-// Enable this module to use one of the following sensors: SensorDs18b20
-#define MODULE_DS18B20 0
-// Enable this module to use one of the following sensors: SensorBH1750
-#define MODULE_BH1750 0
-// Enable this module to use one of the following sensors: SensorMLX90614
-#define MODULE_MLX90614 0
-// Enable this module to use one of the following sensors: SensorBME280
-#define MODULE_BME280 0
-// Enable this module to use one of the following sensors: SensorBMP085
-#define MODULE_BMP085 0
-// Enable this module to use one of the following sensors: SensorBMP280
-#define MODULE_BMP280 0
-// Enable this module to use one of the following sensors: SensorSonoff
-#define MODULE_SONOFF 0
-// Enable this module to use one of the following sensors: SensorHCSR04
-#define MODULE_HCSR04 0
-// Enable this module to use one of the following sensors: SensorMCP9808
-#define MODULE_MCP9808 0
-// Enable this module to use one of the following sensors: SensorMQ
-#define MODULE_MQ 0
-// Enable this module to use one of the following sensors: SensorMHZ19
-#define MODULE_MHZ19 0
-// Enable this module to use one of the following sensors: SensorAM2320    
-#define MODULE_AM2320 0
-// Enable this module to use one of the following sensors: SensorTSL2561    
-#define MODULE_TSL2561 0
-// Enable this module to use one of the following sensors: SensorPT100
-#define MODULE_PT100 0
-// Enable this module to use one of the following sensors: SensorDimmer
-#define MODULE_DIMMER 0
-// Enable this module to use one of the following sensors: SensorRainGauge, SensorPowerMeter, SensorWaterMeter
-#define MODULE_PULSE_METER 1
-
-#endif
-

From 3c325bea23dc4b98b6a64ae9150f402793f2656a Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 17 Dec 2017 16:49:56 +0100
Subject: [PATCH 49/51] Updated documentation

---
 NodeManager.ino      |    2 +-
 NodeManagerLibrary.h |   30 +-
 README.md            | 1229 ++++++++++--------------------------------
 3 files changed, 287 insertions(+), 974 deletions(-)

diff --git a/NodeManager.ino b/NodeManager.ino
index d5fc701..833990a 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -193,7 +193,7 @@
 NodeManager node;
 
 /***********************************
- * Add here your sensors
+ * Add your sensors below
  */
 
 //SensorBattery battery(node);
diff --git a/NodeManagerLibrary.h b/NodeManagerLibrary.h
index 454cdee..8fcd97c 100644
--- a/NodeManagerLibrary.h
+++ b/NodeManagerLibrary.h
@@ -417,6 +417,10 @@ class Sensor {
     int getInterruptPin();
     // listen for interrupts on the given pin so interrupt() will be called when occurring
     void setInterrupt(int pin, int mode, int initial);
+    // set a previously configured PowerManager to the sensor so to powering it up with custom pins
+    void setPowerManager(const PowerManager& powerManager);
+    // list of configured child
+    List<Child*> children;
     // define what to do at each stage of the sketch
     void before();
     void presentation();
@@ -430,11 +434,9 @@ class Sensor {
     virtual void onLoop(Child* child);
     virtual void onReceive(MyMessage* message);
     virtual void onInterrupt();
-    List<Child*> children;
     Child* getChild(int child_id);
     // register a child
     void registerChild(Child* child);
-    void setPowerManager(const PowerManager& powerManager);
     NodeManager* _node;
   protected:
     const char* _name = "";
@@ -453,16 +455,16 @@ class Sensor {
 class SensorBattery: public Sensor {
   public:
     SensorBattery(const NodeManager& nodeManager);
-      // [11] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
-      void setMinVoltage(float value);
-      // [12] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
-      void setMaxVoltage(float value);
-      // [15] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
-      void setBatteryInternalVcc(bool value);
-      // [16] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
-      void setBatteryPin(int value);
-      // [17] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
-      void setBatteryVoltsPerBit(float value);
+    // [102] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
+    void setMinVoltage(float value);
+    // [103] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
+    void setMaxVoltage(float value);
+    // [104] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
+    void setBatteryInternalVcc(bool value);
+    // [105] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
+    void setBatteryPin(int value);
+    // [106] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
+    void setBatteryVoltsPerBit(float value);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -1344,7 +1346,7 @@ class SensorWaterMeter: public SensorPulseMeter {
 class NodeManager {
   public:
     NodeManager();
-    // [10] send the same service message multiple times (default: 1)
+    // [10] send the same message multiple times (default: 1)
     void setRetries(int value);
     int getRetries();
     // [3] set the duration (in seconds) of a sleep cycle
@@ -1474,4 +1476,4 @@ class NodeManager {
     void _saveSleepSettings();
 };
 
-#endif
\ No newline at end of file
+#endif
diff --git a/README.md b/README.md
index 0804f7a..315f277 100755
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, speeding up the development cycle of your projects.
 
-NodeManager includes the following main components:
+NodeManager includes the following main features:
 
 * Sleep manager: allows managing automatically the complexity behind battery-powered sensors spending most of their time sleeping
 * Power manager: allows powering on your sensors only while the node is awake
@@ -15,263 +15,174 @@ NodeManager includes the following main components:
 * Allow waking up a sleeping node remotely at the end of a sleeping cycle
 * Allow powering on each connected sensor only while the node is awake to save battery
 * Report battery level periodically and automatically or on demand
-* Report signal level periodically and automatically or on demand
 * Calculate battery level without requiring an additional pin and the resistors
+* Report signal level periodically and automatically or on demand
 * Allow rebooting the board remotely
 * Provide out-of-the-box sensors personalities and automatically execute their main task at each cycle
 * Allow collecting and averaging multiple samples, tracking the last value and forcing periodic updates for any sensor
 * Provide buil-in capabilities to handle interrupt-based sensors 
 
+### Built-in sensors
+
+NodeManager provides built-in implementation of a number of sensors through dedicated classes:
+
+Sensor's class  | Description
+ ------------- | -------------
+SensorAnalogInput | Generic analog sensor, return a pin's analog value or its percentage
+SensorLDR | LDR sensor, return the light level of an attached light resistor in percentage
+SensorRain | Rain sensor, return the percentage of rain from an attached analog sensor
+SensorSoilMoisture | Soil moisture sensor, return the percentage of moisture from an attached analog sensor
+SensorThermistor | Thermistor sensor, return the temperature based on the attached thermistor
+SensorML8511 | ML8511 sensor, return UV intensity
+SensorACS712 | ACS712 sensor, measure the current going through the attached module
+SensorDigitalInput |  Generic digital sensor, return a pin's digital value
+SensorDigitalOutput | Generic digital output sensor, allows setting the digital output of a pin to the requested value
+SensorRelay | Relay sensor, allows activating the relay
+SensorLatchingRelay| Latching Relay sensor, allows activating the relay with a pulse
+SensorDHT11 | DHT11 sensor, return temperature/humidity based on the attached DHT sensor
+SensorDHT22 | DHT22 sensor, return temperature/humidity based on the attached DHT sensor
+SensorSHT21 | SHT21 sensor, return temperature/humidity based on the attached SHT21 sensor
+SensorHTU21D | HTU21D sensor, return temperature/humidity based on the attached HTU21D sensor
+SensorSwitch | Generic switch, wake up the board when a pin changes status
+SensorDoor | Door sensor, wake up the board and report when an attached magnetic sensor has been opened/closed
+SensorMotion | Motion sensor, wake up the board and report when an attached PIR has triggered
+SensorDs18b20 | DS18B20 sensor, return the temperature based on the attached sensor
+SensorBH1750 | BH1750 sensor, return light level in lux
+SensorMLX90614 | MLX90614 contactless temperature sensor, return ambient and object temperature
+SensorBME280 | BME280 sensor, return temperature/humidity/pressure based on the attached BME280 sensor
+SensorBMP085 | BMP085/BMP180 sensor, return temperature and pressure
+SensorBMP280 | BMP280 sensor, return temperature/pressure based on the attached BMP280 sensor
+SensorSonoff | Sonoff wireless smart switch
+SensorHCSR04 | HC-SR04 sensor, return the distance between the sensor and an object
+SensorMCP9808 | MCP9808 sensor, measure the temperature through the attached module
+SensorMQ | MQ sensor, return ppm of the target gas
+SensorMHZ19 | MH-Z19 CO2 sensor via UART (SoftwareSerial, default on pins 6(Rx) and 7(Tx)
+SensorAM2320 | AM2320 sensors, return temperature/humidity based on the attached AM2320 sensor
+SensorTSL2561 | TSL2561 sensor, return light in lux
+SensorPT100 | High temperature sensor associated with DFRobot Driver, return the temperature in C from the attached PT100 sensor
+SensorDimmer | Generic dimmer sensor used to drive a pwm output
+SensorRainGauge | Rain gauge sensor
+SensorPowerMeter | Power meter pulse sensor
+SensorWaterMeter | Water meter pulse sensor
+
 ## Installation
+
 * Download the package or clone the git repository from https://github.com/mysensors/NodeManager
-* Open the provided sketch and save it under a different name
-* Open `config.h` and customize both MySensors configuration and NodeManager global settings
-* Register your sensors in the sketch file
-* Upload the sketch to your arduino board
+* Open the NodeManager.ino sketch and save it under a different name
+* Configure you sensors and upload the sketch to your arduino board
 
 Please note NodeManager cannot be used as an arduino library since requires access to your MySensors configuration directives, hence its files have to be placed into the same directory of your sketch.
 
+### Installing the dependencies
+
+Some of the sensors rely on third party libraries. Those libraries are not included within NodeManager and have to be installed from the Arduino IDE Library Manager (Sketch -> Include Library -> Manager Libraries) or manually. You need to install the library ONLY if you are planning to enable to use the sensor:
+
+Sensor  | Required Library
+ ------------- | -------------
+SensorSHT21, SensorHTU21D | https://github.com/SodaqMoja/Sodaq_SHT2x
+SensorDHT11, SensorDHT22 | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/DHT
+SensorDs18b20 | https://github.com/milesburton/Arduino-Temperature-Control-Library
+SensorBH1750 | https://github.com/claws/BH1750
+SensorMLX90614 | https://github.com/adafruit/Adafruit-MLX90614-Library
+SensorBME280 | https://github.com/adafruit/Adafruit_BME280_Library
+SensorSonoff | https://github.com/thomasfredericks/Bounce2
+SensorBMP085 | https://github.com/adafruit/Adafruit-BMP085-Library
+SensorHCSR04 | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/NewPing
+SensorMCP9808 | https://github.com/adafruit/Adafruit_MCP9808_Library
+SensorAM2320 | https://github.com/thakshak/AM2320
+SensorTSL2561 | https://github.com/adafruit/TSL2561-Arduino-Library
+SensorBMP280 | https://github.com/adafruit/Adafruit_BMP280_Library
+
 ### Upgrade
-* Download the package
-* Replace the NodeManager.cpp and NodeManager.h of your project with those just downloaded
-* Review the release notes in case there is any manual change required to the existing sketch or config.h file
+
+* Download the latest version of NodeManager
+* Replace the NodeManagerLibrary.ino and NodeManagerLibrary.h of your project with those just downloaded
+* Review the release notes in case there is any manual change required to the main sketch
 
 ## Configuration
-NodeManager configuration includes compile-time configuration directives (which can be set in config.h), runtime global and per-sensor configuration settings (which can be set in your sketch).
 
-### Setup MySensors
-Since NodeManager has to communicate with the MySensors gateway on your behalf, it has to know how to do it. Place on top of the `config.h` file all the MySensors typical directives you are used to set on top of your sketch so both your sketch AND NodeManager will be able to share the same configuration. For example:
+Configuring a sketch with is using NodeManager requires a few steps. All the configuration directives are located within the main sketch.
+
+### MySensors configuration
+
+Since NodeManager has to communicate with the MySensors network on your behalf, it has to know how to do it. On top of the main sketch you will find the typical MySensors directives you are used to which can be customized to configure the board to act as a MySensors node or a MySensors gateway. 
+Please note you don't necessarily need a NodeManager gateway to interact with a NodeManager node. A NodeManager node is fully compatible with any existing gateway you are currently operating with.
+
+### NodeManager configuration
+
+The next step is to enable NodeManager's modules required for your sensors. When a module is enabled, the required library will be loaded and the corresponding sensor will be made available. To enable it, set it to 1. Enabled only what you need to ensure enough storage is left for your custom code.
+
+### Add your sensors
+
+Find in the main sketch `Add your sensors below` and add your sensors to NodeManager. To add a sensor, just create an instance of the class, passing it `node` as an argument and an optional pin. 
+
 ~~~c
-/**********************************
- * Sketch configuration
- */
-
-#define SKETCH_NAME "NodeManager"
-#define SKETCH_VERSION "1.0"
-
-/**********************************
- * MySensors node configuration
- */
-
-// General settings
-#define MY_BAUD_RATE 9600
-//#define MY_DEBUG
-//#define MY_NODE_ID 100
-//#define MY_SMART_SLEEP_WAIT_DURATION_MS 500
-
-// NRF24 radio settings
-#define MY_RADIO_NRF24
-//#define MY_RF24_ENABLE_ENCRYPTION
-//#define MY_RF24_CHANNEL 76
-//#define MY_RF24_PA_LEVEL RF24_PA_HIGH
-//#define MY_DEBUG_VERBOSE_RF24
-//#define MY_RF24_DATARATE RF24_250KBPS
-
-// RFM69 radio settings
-//#define MY_RADIO_RFM69
-//#define MY_RFM69_FREQUENCY RF69_868MHZ
-//#define MY_RFM69_FREQUENCY RFM69_868MHZ
-//#define MY_IS_RFM69HW
-//#define MY_RFM69_NEW_DRIVER
-//#define MY_RFM69_ENABLE_ENCRYPTION
-//#define MY_RFM69_NETWORKID 100
-//#define MY_DEBUG_VERBOSE_RFM69
-//#define MY_RF69_IRQ_PIN D1
-//#define MY_RF69_IRQ_NUM MY_RF69_IRQ_PIN
-//#define MY_RF69_SPI_CS D2
-//#define MY_RFM69_ATC_MODE_DISABLED
-
-// RS485 serial transport settings
-//#define MY_RS485
-//#define MY_RS485_BAUD_RATE 9600
-//#define MY_RS485_DE_PIN 2
-//#define MY_RS485_MAX_MESSAGE_LENGTH 40
-//#define MY_RS485_HWSERIAL Serial1
-
-// Message signing settings
-//#define MY_SIGNING_SOFT
-//#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7
-//#define MY_SIGNING_REQUEST_SIGNATURES
-//#define MY_SIGNING_ATSHA204
-
-// OTA Firmware update settings
-//#define MY_OTA_FIRMWARE_FEATURE
-//#define OTA_WAIT_PERIOD 300
-//#define FIRMWARE_MAX_REQUESTS 2
-//#define MY_OTA_RETRY 2
-
-/**********************************
- * MySensors gateway configuration
- */
-// Common gateway settings
-//#define MY_REPEATER_FEATURE
-
-// Serial gateway settings
-//#define MY_GATEWAY_SERIAL
-
-// Ethernet gateway settings
-//#define MY_GATEWAY_W5100
-
-// ESP8266 gateway settings
-//#define MY_GATEWAY_ESP8266
-//#define MY_ESP8266_SSID ""
-//#define MY_ESP8266_PASSWORD ""
-
-// Gateway networking settings
-//#define MY_IP_ADDRESS 192,168,178,87
-//#define MY_IP_GATEWAY_ADDRESS 192,168,178,1
-//#define MY_IP_SUBNET_ADDRESS 255,255,255,0
-//#define MY_PORT 5003
-//#define MY_GATEWAY_MAX_CLIENTS 2
-//#define MY_USE_UDP
-
-// Gateway MQTT settings
-//#define MY_GATEWAY_MQTT_CLIENT
-//#define MY_CONTROLLER_IP_ADDRESS 192, 168, 178, 68
-//#define MY_PORT 1883
-//#define MY_MQTT_USER "username"
-//#define MY_MQTT_PASSWORD "password"
-//#define MY_MQTT_CLIENT_ID "mysensors-1"
-//#define MY_MQTT_PUBLISH_TOPIC_PREFIX "mygateway1-out"
-//#define MY_MQTT_SUBSCRIBE_TOPIC_PREFIX "mygateway1-in"
-
-// Gateway inclusion mode
-//#define MY_INCLUSION_MODE_FEATURE
-//#define MY_INCLUSION_BUTTON_FEATURE
-//#define MY_INCLUSION_MODE_DURATION 60
-//#define MY_DEFAULT_LED_BLINK_PERIOD 300
-
-// Gateway Leds settings
-//#define MY_DEFAULT_ERR_LED_PIN 4
-//#define MY_DEFAULT_RX_LED_PIN  5
-//#define MY_DEFAULT_TX_LED_PIN  6
+SensorThermistor thermistor(node,A0);
+SensorSHT21 sht21(node);
 ~~~
 
-### Enable/Disable NodeManager's modules
+The sensor will be then registered automatically with NodeManager which will take care of it all along its lifecycle. Please ensure the corresponding module has been previously enabled for a successful compilation of the code.
+NodeManager will assign a child id automatically, present each sensor for you to the controller, query each sensor and report the measure back to the gateway/controller. For actuators (e.g. relays) those can be triggered by sending a `REQ` message with the expected type to their assigned child id.
+
+For your convenience, NodeManager makes available additional special sensors which can be added in the same way as other built-in sensors:
+Special Sensor  | Description
+ ------------- | -------------
+SensorBattery | Add it to enable automatic battery reporting
+SensorSignal | Add it to enable automatic signal level reporting
+SensorConfiguration | Add it to enable OTA remote configuration of any registered sensor
 
-The next step is to enable NodeManager's additional functionalities and the modules required for your sensors. The directives in the `config.h` file control which module/library/functionality will be made available to your sketch. Enable (e.g. set to 1) only what you need to ensure enough storage is left to your custom code.
+### Configuring your sensors
+
+NodeManager and all the sensors can be configured from within `before()` in the main sketch. Find `Configure your sensors below` to customize the behavior of any sensor by calling one of the functions available.
 
 ~~~c
-/***********************************
- * NodeManager configuration
- */
-
-// if enabled, enable debug messages on serial port
-#define DEBUG 1
-
-// if enabled, enable the capability to power on sensors with the arduino's pins to save battery while sleeping
-#define POWER_MANAGER 1
-// if enabled, will load the battery manager library to allow the battery level to be reported automatically or on demand
-#define BATTERY_MANAGER 1
-// if enabled, allow modifying the configuration remotely by interacting with the configuration child id
-#define REMOTE_CONFIGURATION 1
-// if enabled, persist the remote configuration settings on EEPROM
-#define PERSIST 0
-// if enabled, a battery sensor will be created at BATTERY_CHILD_ID and will report vcc voltage together with the battery level percentage
-#define BATTERY_SENSOR 1
-// if enabled, a signal sensor will be created at RSSI_CHILD_ID (202 by default) and will report the signal quality of the transport layer
-#define SIGNAL_SENSOR 0
-// if enabled, send a SLEEPING and AWAKE service messages just before entering and just after leaving a sleep cycle and STARTED when starting/rebooting
-#define SERVICE_MESSAGES 0
-
-// Enable this module to use one of the following sensors: SENSOR_ANALOG_INPUT, SENSOR_LDR, SENSOR_THERMISTOR, SENSOR_ML8511, SENSOR_ACS712, SENSOR_RAIN, SENSOR_SOIL_MOISTURE
-#define MODULE_ANALOG_INPUT 1
-// Enable this module to use one of the following sensors: SENSOR_DIGITAL_INPUT
-#define MODULE_DIGITAL_INPUT 1
-// Enable this module to use one of the following sensors: SENSOR_DIGITAL_OUTPUT, SENSOR_RELAY, SENSOR_LATCHING_RELAY
-#define MODULE_DIGITAL_OUTPUT 1
-// Enable this module to use one of the following sensors: SENSOR_DHT11, SENSOR_DHT22
-#define MODULE_DHT 0
-// Enable this module to use one of the following sensors: SENSOR_SHT21, SENSOR_HTU21D
-#define MODULE_SHT21 0
-// Enable this module to use one of the following sensors: SENSOR_SWITCH, SENSOR_DOOR, SENSOR_MOTION
-#define MODULE_SWITCH 0
-// Enable this module to use one of the following sensors: SENSOR_DS18B20
-#define MODULE_DS18B20 0
-// Enable this module to use one of the following sensors: SENSOR_BH1750
-#define MODULE_BH1750 0
-// Enable this module to use one of the following sensors: SENSOR_MLX90614
-#define MODULE_MLX90614 0
-// Enable this module to use one of the following sensors: SENSOR_BME280
-#define MODULE_BME280 0
-// Enable this module to use one of the following sensors: SENSOR_SONOFF
-#define MODULE_SONOFF 0
-// Enable this module to use one of the following sensors: SENSOR_BMP085
-#define MODULE_BMP085 0
-// Enable this module to use one of the following sensors: SENSOR_HCSR04
-#define MODULE_HCSR04 0
-// Enable this module to use one of the following sensors: SENSOR_MCP9808
-#define MODULE_MCP9808 0
-// Enable this module to use one of the following sensors: SENSOR_MQ
-#define MODULE_MQ 0
-// Enable this module to use one of the following sensors: SENSOR_MHZ19
-#define MODULE_MHZ19 0
-// Enable this module to use one of the following sensors: SENSOR_AM2320    
-#define MODULE_AM2320 0
-// Enable this module to use one of the following sensors: SENSOR_TSL2561    
-#define MODULE_TSL2561 0
-// Enable this module to use one of the following sensors: SENSOR_PT100
-#define MODULE_PT100 0
-// Enable this module to use one of the following sensors: SENSOR_BMP280
-#define MODULE_BMP280 0
-// Enable this module to use one of the following sensors: SENSOR_DIMMER
-#define MODULE_DIMMER 0
-// Enable this module to use one of the following sensors: SENSOR_RAIN_GAUGE, SENSOR_POWER_METER, SENSOR_WATER_METER
-#define MODULE_PULSE_METER 0
+// report measures of every attached sensors every 10 minutes
+node.setReportIntervalMinutes(10);
+// set the node to sleep in 5 minutes cycles
+node.setSleepMinutes(5);
+// report battery level every 10 minutes
+battery.setReportIntervalMinutes(10);
+// set an offset to -1 to a thermistor sensor
+thermistor.setOffset(-1);
+// Change the id of a the first child of a sht21 sensor
+sht21.children.get(1)->child_id = 5;
+// power all the nodes through dedicated pins
+node.setPowerManager(power);
 ~~~
 
-### Installing the dependencies
+If not instructed differently, the node will stay awake and all the sensors will report every 10 minutes, battery level and signal level will be automatically reported every 60 minutes (if the corresponding sensors have been added). 
 
-Some of the modules above rely on third party libraries. Those libraries are not included within NodeManager and have to be installed from the Arduino IDE Library Manager (Sketch -> Include Library -> Manager Libraries) or manually. You need to install the library ONLY if the module is enabled:
+Please note, if you configure a sleep cycle, this may have an impact on the reporting interval since the sensor will be able to report its measures ONLY when awake. For example if you set a report interval of 5 minutes and a sleep cycle of 10 minutes, the sensors will report every 10 minutes.
 
-Module  | Required Library
- ------------- | -------------
-MODULE_SHT21 | https://github.com/SodaqMoja/Sodaq_SHT2x
-MODULE_DHT | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/DHT
-MODULE_DS18B20 | https://github.com/milesburton/Arduino-Temperature-Control-Library
-MODULE_BH1750 | https://github.com/claws/BH1750
-MODULE_MLX90614 | https://github.com/adafruit/Adafruit-MLX90614-Library
-MODULE_BME280 | https://github.com/adafruit/Adafruit_BME280_Library
-MODULE_SONOFF | https://github.com/thomasfredericks/Bounce2
-MODULE_BMP085 | https://github.com/adafruit/Adafruit-BMP085-Library
-MODULE_HCSR04 | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/NewPing
-MODULE_MCP9808 | https://github.com/adafruit/Adafruit_MCP9808_Library
-MODULE_AM2320 | https://github.com/thakshak/AM2320
-MODULE_TSL2561 | https://github.com/adafruit/TSL2561-Arduino-Library
-MODULE_BMP280 | https://github.com/adafruit/Adafruit_BMP280_Library
-
-### Configure NodeManager
-
-The next step is to configure NodeManager with settings which will instruct how the node should behave. To do so, go to the main sketch, inside the `before()` function and add call one or more of the functions below just before registering your sensors. The following methods are exposed for your convenience and can be called on the `nodeManager` object already created for you:
+## Running the node
+
+Once finished configuring your node, upload your sketch to your arduino board as you are used to.
+
+Check your gateway's logs to ensure the node is working as expected. You should see the node presenting itself, presenting all the registered sensors and reporting new measures at the configured reporting interval.
+When `DEBUG` is enabled, detailed information will be available through the serial port. Remember to disable debug once the tests have been completed to save additional storage.
+
+## Communicate with the sensors
+
+You can interact with each registered sensor by sending to the child id a `REQ` command (or a `SET` for output sensors like relays). For example to request the temperature to node_id 254 and child_id 1:
+
+`254;1;2;0;0;`
+
+To activate a relay connected to the same node, child_id 100 we need to send a `SET` command with payload set to 1:
+
+`254;100;1;0;2;1`
+
+No need to implement anything on your side since for built-in sensors this is handled automatically. 
+
+## API
+
+You can interact with each class provided by NodeManager through a set of API functions. 
+
+### NodeManager API
 
 ~~~c
-    // [10] send the same service message multiple times (default: 1)
+    // [10] send the same message multiple times (default: 1)
     void setRetries(int value);
     int getRetries();
-    #if BATTERY_MANAGER == 1
-      // [11] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
-      void setBatteryMin(float value);
-      // [12] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
-      void setBatteryMax(float value);
-      // [14] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportMinutes(int value);
-      // [40] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportSeconds(int value);
-      // [41] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportHours(int value);
-      // [42] after how many minutes report the battery level to the controller. When reset the battery is always reported (default: 60 minutes)
-      void setBatteryReportDays(int value);
-      // [15] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
-      void setBatteryInternalVcc(bool value);
-      // [16] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
-      void setBatteryPin(int value);
-      // [17] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
-      void setBatteryVoltsPerBit(float value);
-      // [18] If true, wake up by an interrupt counts as a valid cycle for battery reports otherwise only uninterrupted sleep cycles would contribute (default: true)
-      void setBatteryReportWithInterrupt(bool value);
-      // [2] Send a battery level report to the controller
-      void batteryReport();
-    #endif
     // [3] set the duration (in seconds) of a sleep cycle
     void setSleepSeconds(int value);
     long getSleepSeconds();
@@ -290,27 +201,14 @@ The next step is to configure NodeManager with settings which will instruct how
     // [20] optionally sleep interval in milliseconds before sending each message to the radio network (default: 0)
     void setSleepBetweenSend(int value);
     int getSleepBetweenSend();
-    // register a built-in sensor
-    int registerSensor(int sensor_type, int pin = -1, int child_id = -1);
-    // register a custom sensor
-    int registerSensor(Sensor* sensor);
-    // [26] un-register a sensor
-    void unRegisterSensor(int sensor_index);
-    // return a sensor by its index
-    Sensor* get(int sensor_index);
-    Sensor* getSensor(int sensor_index);
-    // assign a different child id to a sensor
-    bool renameSensor(int old_child_id, int new_child_id);
-    #if POWER_MANAGER == 1
-      // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
-      void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
-      // [23] if enabled the pins will be automatically powered on while awake and off during sleeping (default: true)
-      void setAutoPowerPins(bool value);
-      // [24] manually turn the power on
-      void powerOn();
-      // [25] manually turn the power off
-      void powerOff();
-    #endif
+    // register a sensor
+    void registerSensor(Sensor* sensor);
+    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
+    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // [24] manually turn the power on
+    void powerOn();
+    // [25] manually turn the power off
+    void powerOff();
     // [21] set this to true if you want destination node to send ack back to this node (default: false)
     void setAck(bool value);
     bool getAck();
@@ -329,14 +227,10 @@ The next step is to configure NodeManager with settings which will instruct how
     void hello();
     // [6] reboot the board
     void reboot();
-    // [8] send NodeManager's the version back to the controller
-    void version();
     // [7] clear the EEPROM
     void clearEeprom();
     // [9] wake up the board
     void wakeup();
-    // process a remote request
-    void process(Request & request);
     // return the value stored at the requested index from the EEPROM
     int loadFromMemory(int index);
     // [27] save the given index of the EEPROM the provided value
@@ -363,153 +257,19 @@ The next step is to configure NodeManager with settings which will instruct how
     void setRebootPin(int value);
     // [32] turn the ADC off so to save 0.2 mA
     void setADCOff();
-    #if SIGNAL_SENSOR == 1 && defined(MY_SIGNAL_REPORT_ENABLED)
-      // [33] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportMinutes(int value);
-      // [43] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportSeconds(int value);
-      // [44] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportHours(int value);
-      // [45] How frequenly to send a signal report to the controller (default: 60 minutes)
-      void setSignalReportDays(int value);
-      // [34] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
-      void setSignalCommand(int value);
-      // [35] report the signal level to the controller
-      void signalReport();
-    #endif
-~~~
-
-### Set reporting intervals and sleeping cycles
-
-If not instructed differently, the node will stay awake and all the sensors will report every 10 minutes, battery level and signal level will be automatically reported every 60 minutes. To change those settings, you can call the following functions on the nodeManager object:
-
-Function  | Description
------------- | -------------
-setSleepSeconds(), setSleepMinutes(), setSleepHours(), setSleepDays() | the time interval the node will spend in a (smart) sleep cycle
-setReportIntervalSeconds(), setReportIntervalMinutes(), setReportIntervalHours(), setReportIntervalDays() | the time interval the node will report the measures of all the attached sensors
-setBatteryReportSeconds(), setBatteryReportMinutes(), setBatteryReportHours(), setBatteryReportDays() | the time interval the node will report the battery level
-setSignalReportSeconds(), setSignalReportMinutes(), setSignalReportHours(), setSignalReportDays() | the time interval the node will report the radio signal level
-
-For example, to put the node to sleep in cycles of 10 minutes:
-
-~~~c
-	nodeManager.setSleepMinutes(10);
-~~~
-
-If you need every sensor to report at a different time interval, you can call `setBatteryReportSeconds(), setBatteryReportMinutes(), setBatteryReportHours(), setBatteryReportDays()` on the sensor's object. For example to have a DHT sensor reporting every 60 seconds while all the other sensors every 20 minutes:
-~~~c
-int id = nodeManager.registerSensor(SENSOR_DHT22,6);
-SensorDHT* dht = (SensorDHT*)nodeManager.get(id);
-dht->setReportIntervalSeconds(60);
-nodeManager.setReportIntervalMinutes(20);
-~~~
-
-Please note, if you configure a sleep cycle, this may have an impact on the reporting interval since the sensor will be able to report its measures ONLY when awake. For example if you set a report interval of 5 minutes and a sleep cycle of 10 minutes, the sensors will report every 10 minutes.
-
-### Register your sensors
-Once configured the node, it is time to tell NodeManager which sensors are attached to the board and where. In your sketch, inside the `before()` function and just before calling `nodeManager.before()`, you can register your sensors against NodeManager. The following built-in sensor types are available. Remember the corresponding module should be enabled in `config.h` for a successful compilation: 
-
-Sensor type  | Description
- ------------- | -------------
-SENSOR_ANALOG_INPUT | Generic analog sensor, return a pin's analog value or its percentage
-SENSOR_LDR | LDR sensor, return the light level of an attached light resistor in percentage
-SENSOR_THERMISTOR | Thermistor sensor, return the temperature based on the attached thermistor
-SENSOR_DIGITAL_INPUT |  Generic digital sensor, return a pin's digital value
-SENSOR_DIGITAL_OUTPUT | Generic digital output sensor, allows setting the digital output of a pin to the requested value
-SENSOR_RELAY | Relay sensor, allows activating the relay
-SENSOR_LATCHING_RELAY| Latching Relay sensor, allows activating the relay with a pulse
-SENSOR_DHT11 | DHT11 sensor, return temperature/humidity based on the attached DHT sensor
-SENSOR_DHT22 | DHT22 sensor, return temperature/humidity based on the attached DHT sensor
-SENSOR_SHT21 | SHT21 sensor, return temperature/humidity based on the attached SHT21 sensor
-SENSOR_SWITCH | Generic switch, wake up the board when a pin changes status
-SENSOR_DOOR | Door sensor, wake up the board and report when an attached magnetic sensor has been opened/closed
-SENSOR_MOTION | Motion sensor, wake up the board and report when an attached PIR has triggered
-SENSOR_DS18B20 | DS18B20 sensor, return the temperature based on the attached sensor
-SENSOR_HTU21D | HTU21D sensor, return temperature/humidity based on the attached HTU21D sensor
-SENSOR_BH1750 | BH1750 sensor, return light level in lux
-SENSOR_MLX90614 | MLX90614 contactless temperature sensor, return ambient and object temperature
-SENSOR_BME280 | BME280 sensor, return temperature/humidity/pressure based on the attached BME280 sensor
-SENSOR_MQ | MQ sensor, return ppm of the target gas
-SENSOR_ML8511 | ML8511 sensor, return UV intensity
-SENSOR_SONOFF | Sonoff wireless smart switch
-SENSOR_BMP085 | BMP085/BMP180 sensor, return temperature and pressure
-SENSOR_HCSR04 | HC-SR04 sensor, return the distance between the sensor and an object
-SENSOR_ACS712 | ACS712 sensor, measure the current going through the attached module
-SENSOR_MCP9808 | MCP9808 sensor, measure the temperature through the attached module
-SENSOR_RAIN_GAUGE | Rain gauge sensor
-SENSOR_RAIN | Rain sensor, return the percentage of rain from an attached analog sensor
-SENSOR_SOIL_MOISTURE | Soil moisture sensor, return the percentage of moisture from an attached analog sensor
-SENSOR_MHZ19 | MH-Z19 CO2 sensor via UART (SoftwareSerial, default on pins 6(Rx) and 7(Tx)
-SENSOR_TSL2561 | TSL2561 sensor, return light in lux
-SENSOR_AM2320 | AM2320 sensors, return temperature/humidity based on the attached AM2320 sensor
-SENSOR_PT100 | High temperature sensor associated with DFRobot Driver, return the temperature in C from the attached PT100 sensor
-SENSOR_BMP280 | BMP280 sensor, return temperature/pressure based on the attached BMP280 sensor
-SENSOR_DIMMER | Generic dimmer sensor used to drive a pwm output
-SENSOR_POWER_METER | Power meter pulse sensor
-SENSOR_WATER_METER | Water meter pulse sensor
-
-To register a sensor simply call the NodeManager instance with the sensory type and the pin the sensor is conncted to and optionally a child id. For example:
-~~~c
-	nodeManager.registerSensor(SENSOR_THERMISTOR,A2);
-	nodeManager.registerSensor(SENSOR_DOOR,3,1);
-~~~
-
-Once registered, your job is done. NodeManager will assign a child id automatically if not instructed differently, present each sensor for you to the controller, query each sensor and report the measure back to the gateway/controller. For actuators (e.g. relays) those can be triggered by sending a `REQ` message with the expected type to their assigned child id.
-
-When called, registerSensor returns the child_id of the sensor so you will be able to retrieve it later if needed. Please note for sensors creating multiple child IDs (like a DHT sensor which creates a temperature and humidity sensor with different IDs), the last id is returned.
-
-#### Creating a custom sensor
-
-If you want to create a custom sensor and register it with NodeManager so it can take care of all the common tasks, you can create an inline class inheriting from `Sensor` or other subclasses and implement the following methods:
-~~~c
-    // define what to do during before() to setup the sensor
-    void onBefore();
-	// define what to do during setup() by executing the sensor's main task
-    void onSetup();
-    // define what to do during loop() by executing the sensor's main task
-    void onLoop();
-    // define what to do during receive() when the sensor receives a message
-    void onReceive(const MyMessage & message);
-	// define what to do when receiving a remote configuration message
-    void onProcess(Request & request);
-    // define what to do when receiving an interrupt
-    void onInterrupt();
-~~~
-
-You can then instantiate your newly created class and register it with NodeManager:
-~~~c
-    nodeManager.registerSensor(new SensorCustom(&nodeManager,child_id, pin));
+    // [30] if set save the sleep settings in memory, also when changed remotely (default: false)
+    void setSaveSleepSettings(bool value);
 ~~~
 
-### Configuring the sensors
-Each built-in sensor class comes with reasonable default settings. In case you want/need to customize any of those settings, after having registered the sensor, you can retrieve it back and call set functions common to all the sensors or specific for a given class.
-
-To do so, use `nodeManager.getSensor(child_id)` which will return a pointer to the sensor. Remeber to cast it to the right class before calling their functions. For example:
+### Sensor API
 
+The following methods are available for all the sensors:
 ~~~c
-	SensorLatchingRelay* relay = (SensorLatchingRelay*) nodeManager.getSensor(2);
-	relay->setPulseWidth(50);
-~~~
-
-
-#### Sensor's general configuration
-
-The following methods are available for all the sensors and can be called on the object reference as per the example above:
-~~~c
+    // return the name of the sensor
+    char* getName();
     // [1] where the sensor is attached to (default: not set)
     void setPin(int value);
     int getPin();
-    // [2] child_id of this sensor (default: not set)
-    void setChildId(int value);
-    int getChildId();
-    // presentation of this sensor (default: S_CUSTOM)
-    void setPresentation(int value);
-    int getPresentation();
-    // [3] type of this sensor (default: V_CUSTOM)
-    void setType(int value);
-    int getType();
-    // [4] description of the sensor (default: '')
-    void setDescription(char *value);
     // [5] For some sensors, the measurement can be queried multiple times and an average is returned (default: 1)
     void setSamples(int value);
     // [6] If more then one sample has to be taken, set the interval in milliseconds between measurements (default: 0)
@@ -518,29 +278,12 @@ The following methods are available for all the sensors and can be called on the
     void setTrackLastValue(bool value);
     // [9] if track last value is enabled, force to send an update after the configured number of minutes
     void setForceUpdateMinutes(int value);
-    // [19] if track last value is enabled, force to send an update after the configured number of hours
-    void setForceUpdateHours(int value);
-    // [10] the value type of this sensor (default: TYPE_INTEGER)
-    void setValueType(int value);
-    int getValueType();
-    // [11] for float values, set the float precision (default: 2)
-    void  setFloatPrecision(int value);
-    // [21] for double values, set the double precision (default: 4)
-    void  setDoublePrecision(int value);
-    #if POWER_MANAGER == 1
-      // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
-      void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
-      // [12] if enabled the pins will be automatically powered on while awake and off during sleeping (default: true)
-      void setAutoPowerPins(bool value);
-      // [13] manually turn the power on
-      void powerOn();
-      // [14] manually turn the power off
-      void powerOff();
-    #endif
-    // get the latest recorded value from the sensor
-    int getValueInt();
-    float getValueFloat();
-    char* getValueString();
+    // to save battery the sensor can be optionally connected to two pins which will act as vcc and ground and activated on demand
+    void setPowerPins(int ground_pin, int vcc_pin, int wait_time = 50);
+    // [13] manually turn the power on
+    void powerOn();
+    // [14] manually turn the power off
+    void powerOff();
     // [17] After how many minutes the sensor will report back its measure (default: 10 minutes)
     void setReportIntervalSeconds(int value);
     // [16] After how many minutes the sensor will report back its measure (default: 10 minutes)
@@ -551,17 +294,39 @@ The following methods are available for all the sensors and can be called on the
     void setReportIntervalDays(int value);
     // return true if the report interval has been already configured
     bool isReportIntervalConfigured();
-    // process a remote request
-    void process(Request & request);
     // return the pin the interrupt is attached to
     int getInterruptPin();
     // listen for interrupts on the given pin so interrupt() will be called when occurring
     void setInterrupt(int pin, int mode, int initial);
+    // set a previously configured PowerManager to the sensor so to powering it up with custom pins
+    void setPowerManager(const PowerManager& powerManager);
+    // list of configured child
+    List<Child*> children;
 ~~~
 
-#### Sensor's specific configuration
+### Built-in sensors API
+
+Each sensor class exposes additional methods.
+
+* SensorBattery
+~~~c
+    // [102] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
+    void setMinVoltage(float value);
+    // [103] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
+    void setMaxVoltage(float value);
+    // [104] if true, the battery level will be evaluated by measuring the internal vcc without the need to connect any pin, if false the voltage divider methon will be used (default: true)
+    void setBatteryInternalVcc(bool value);
+    // [105] if setBatteryInternalVcc() is set to false, the analog pin to which the battery's vcc is attached (https://www.mysensors.org/build/battery) (default: -1)
+    void setBatteryPin(int value);
+    // [106] if setBatteryInternalVcc() is set to false, the volts per bit ratio used to calculate the battery voltage (default: 0.003363075)
+    void setBatteryVoltsPerBit(float value);
+~~~
 
-Each sensor class can expose additional methods.
+* SensorSignal
+~~~c
+    // [101] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
+    void setSignalCommand(int value);
+~~~
 
 * SensorAnalogInput / SensorLDR / SensorRain / SensorSoilMoisture
 ~~~c
@@ -591,32 +356,6 @@ Each sensor class can expose additional methods.
     void setOffset(float value);
 ~~~
 
-* SensorMQ
-~~~c
-    // [101] define the target gas whose ppm has to be returned. 0: LPG, 1: CO, 2: Smoke (default: 1);
-    void setTargetGas(int value);
-    // [102] define the load resistance on the board, in kilo ohms (default: 1);
-    void setRlValue(float value);
-    // [103] define the Ro resistance on the board (default: 10000);
-    void setRoValue(float value);
-    // [104] Sensor resistance in clean air (default: 9.83);
-    void setCleanAirFactor(float value);
-    // [105] define how many samples you are going to take in the calibration phase (default: 50);
-    void setCalibrationSampleTimes(int value);
-    // [106] define the time interal(in milisecond) between each samples in the cablibration phase (default: 500);
-    void setCalibrationSampleInterval(int value);
-    // [107] define how many samples you are going to take in normal operation (default: 50);
-    void setReadSampleTimes(int value);
-    // [108] define the time interal(in milisecond) between each samples in the normal operations (default: 5);
-    void setReadSampleInterval(int value);
-    // set the LPGCurve array (default: {2.3,0.21,-0.47})
-    void setLPGCurve(float *value);
-    // set the COCurve array (default: {2.3,0.72,-0.34})
-    void setCOCurve(float *value);
-    // set the SmokeCurve array (default: {2.3,0.53,-0.44})
-    void setSmokeCurve(float *value);
-~~~
-
 * SensorACS712
 ~~~c
     // [101] set how many mV are equivalent to 1 Amp. The value depends on the module (100 for 20A Module, 66 for 30A Module) (default: 185);
@@ -625,16 +364,6 @@ Each sensor class can expose additional methods.
     void setOffset(int value);
 ~~~
 
-* SensorRainGauge / SensorPowerMeter / SensorWaterMeter
-~~~c
-    // [102] set how many pulses for each unit (e.g. 1000 pulses for 1 kwh of power, 9 pulses for 1 mm of rain, etc.)
-    void setPulseFactor(float value);
-    // set initial value - internal pull up (default: HIGH)
-    void setInitialValue(int value);
-    // set the interrupt mode to attach to (default: FALLING)
-    void setInterruptMode(int value);
-~~~
-
 * SensorDigitalOutput / SensorRelay
 ~~~c
     // [103] define which value to set to the output when set to on (default: HIGH)
@@ -647,10 +376,6 @@ Each sensor class can expose additional methods.
     void setInputIsElapsed(bool value);
     // [107] optionally wait for the given number of milliseconds after changing the status (default: 0)
     void setWaitAfterSet(int value);
-    // manually switch the output to the provided value
-    void setStatus(int value);
-    // get the current state
-    int getStatus();
 ~~~
 
 * SensorLatchingRelay (in addition to those available for SensorDigitalOutput / SensorRelay)
@@ -699,16 +424,6 @@ Each sensor class can expose additional methods.
     void setForecastSamplesCount(int value);
 ~~~
 
-* SensorHCSR04
-~~~c
-    // [101] Arduino pin tied to trigger pin on the ultrasonic sensor (default: the pin set while registering the sensor)
-    void setTriggerPin(int value);
-    // [102] Arduino pin tied to echo pin on the ultrasonic sensor (default: the pin set while registering the sensor)
-    void setEchoPin(int value);
-    // [103] Maximum distance we want to ping for (in centimeters) (default: 300)
-    void setMaxDistance(int value);
-~~~
-
 *  SensorSonoff
 ~~~c
     // [101] set the button's pin (default: 0)
@@ -719,10 +434,40 @@ Each sensor class can expose additional methods.
     void setLedPin(int value);
 ~~~
 
-* SensorMHZ19
+* SensorHCSR04
+~~~c
+    // [101] Arduino pin tied to trigger pin on the ultrasonic sensor (default: the pin set while registering the sensor)
+    void setTriggerPin(int value);
+    // [102] Arduino pin tied to echo pin on the ultrasonic sensor (default: the pin set while registering the sensor)
+    void setEchoPin(int value);
+    // [103] Maximum distance we want to ping for (in centimeters) (default: 300)
+    void setMaxDistance(int value);
+~~~
+
+* SensorMQ
 ~~~c
-    // set the RX and TX pins for the software serial port to talk to the sensor
-    void setRxTx(int rxpin, int txpin);
+    // [101] define the target gas whose ppm has to be returned. 0: LPG, 1: CO, 2: Smoke (default: 1);
+    void setTargetGas(int value);
+    // [102] define the load resistance on the board, in kilo ohms (default: 1);
+    void setRlValue(float value);
+    // [103] define the Ro resistance on the board (default: 10000);
+    void setRoValue(float value);
+    // [104] Sensor resistance in clean air (default: 9.83);
+    void setCleanAirFactor(float value);
+    // [105] define how many samples you are going to take in the calibration phase (default: 50);
+    void setCalibrationSampleTimes(int value);
+    // [106] define the time interal(in milisecond) between each samples in the cablibration phase (default: 500);
+    void setCalibrationSampleInterval(int value);
+    // [107] define how many samples you are going to take in normal operation (default: 50);
+    void setReadSampleTimes(int value);
+    // [108] define the time interal(in milisecond) between each samples in the normal operations (default: 5);
+    void setReadSampleInterval(int value);
+    // set the LPGCurve array (default: {2.3,0.21,-0.47})
+    void setLPGCurve(float *value);
+    // set the COCurve array (default: {2.3,0.72,-0.34})
+    void setCOCurve(float *value);
+    // set the SmokeCurve array (default: {2.3,0.53,-0.44})
+    void setSmokeCurve(float *value);
 ~~~
 
 * SensorTSL2561
@@ -737,6 +482,12 @@ Each sensor class can expose additional methods.
     void setAddress(int value);
 ~~~
 
+* SensorPT100
+~~~c
+    // [101] set the voltageRef used to compare with analog measures
+    void setVoltageRef(float value);
+~~~
+
 * SensorDimmer
 ~~~c
     // [101] set the effect to use for a smooth transition, can be one of SensorDimmer::EASE_LINEAR, SensorDimmer::EASE_INSINE, SensorDimmer::EASE_OUTSINE, SensorDimmer::EASE_INOUTSINE (default: EASE_LINEAR)
@@ -749,88 +500,67 @@ Each sensor class can expose additional methods.
     void fadeTo(int value);
 ~~~
 
-### Creating a gateway
-
-NodeManager can be also used to create a MySensors gateway. Open your config.h file and look for the gateway-specific defines under "MySensors gateway configuration". The most common settings are reported there, just uncomment those you need to use based on the network you are creating.
-
-Please note you don't necessarily need a NodeManager gateway to interact with a NodeManager node. The NodeManager node is fully compatible with any existing gateway you are currently operating with.
-
-### Upload your sketch
-
-Upload your sketch to your arduino board as you are used to.
-
-Check your gateway's logs to ensure the node is working as expected. You should see the node presenting itself, reporting battery level, presenting all the registered sensors and the configuration child id service.
-When `DEBUG` is enabled, detailed information is available through the serial port. Remember to disable debug once the tests have been completed.
-
-### Communicate with NodeManager and its sensors
-
-You can interact with each registered sensor by sending to the child id a `REQ` command (or a `SET` for output sensors like relays). For example to request the temperature to node_id 254 and child_id 1:
-
-`254;1;2;0;0;`
-
-To activate a relay connected to the same node, child_id 100 we need to send a `SET` command with payload set to 1:
-
-`254;100;1;0;2;1`
-
-No need to implement anything on your side since for built-in sensors this is handled automatically. 
-
-NodeManager exposes also a configuration service which is by default on child_id 200 so you can interact with it by sending `V_CUSTOM` type of messages and commands within the payload. For each `REQ` message, the node will respond with a `SET` message if successful. 
-
-Almost all the functions made available through the API can be called remotely. To do so, the payload must be in the format `<function_id>[,<value_to_set>]` where `function_id` is the number between square brackets you can find in the description above and, if the function takes and argument, this can be passed along in `value_to_set`. 
-For example, to request a battery report, find the function you need to call remotely within the documentation:
+* SensorRainGauge / SensorPowerMeter / SensorWaterMeter
 ~~~c
-    // [2] Send a battery level report to the controller
-    void batteryReport();
+    // [102] set how many pulses for each unit (e.g. 1000 pulses for 1 kwh of power, 9 pulses for 1 mm of rain, etc.)
+    void setPulseFactor(float value);
+    // set initial value - internal pull up (default: HIGH)
+    void setInitialValue(int value);
+    // set the interrupt mode to attach to (default: FALLING)
+    void setInterruptMode(int value);
 ~~~
-In this case `function_id` will be 2. To request a battery report to the node_id 100, send the following message:
-`<node_id>;<configuration_child_id>;<req>;0;<V_CUSTOM>;<function_id>`
-`100;200;2;0;48;2`
 
-The change the sleep time to e.g. 10 minutes:
+### Remote API
+
+If SensorConfiguration is added to NodeManager, the API can be also called remotely. SensorConfiguration exposes child id 200 that can be used to interact with the service by sending `V_CUSTOM` type of messages and commands within the payload. For each `REQ` message, the node will respond with a `SET` message if successful. 
+
+Almost all the functions made available through the API can be called remotely. To do so, the payload must be in the format `<child_id>,<function_id>[,<value_to_set>]` where `child_id` is the recipient child id you want to communicate with (the board has child id 0), `function_id` is the number between square brackets you can find in the API documentation and, if the function takes and argument, this can be passed along in `value_to_set`. 
+For example, to change the sleep time to e.g. 10 minutes:
 ~~~c
     // [4] set the duration (in minutes) of a sleep cycle
     void setSleepMinutes(int value);
 ~~~
-`<node_id>;<configuration_child_id>;<req>;0;<V_CUSTOM>;<function_id>,<value>`
-`100;200;2;0;48;4,10`
+`<node_id>;<configuration_child_id>;<req>;0;<V_CUSTOM>;<child_id>,<function_id>,<value>`
+`100;200;2;0;48;0,4,10`
 
 To wake up a node previously configured as sleeping, send the following as the node wakes up next:
 ~~~c
     // [9] wake up the board
     void wakeup();
 ~~~
-`100;200;2;0;48;9`
+`100;200;2;0;48;0,9`
 
-The same protocol can be used to execute remotely also sensor-specific functions. In this case the message has to be sent to the sensor's child_id, with a `V_CUSTOM` type of message. For example if you want to collect and average 10 samples for child_id 1:
+if you want to collect and average 10 samples for the sensor on child_id 1:
 ~~~c
     // [5] For some sensors, the measurement can be queried multiple times and an average is returned (default: 1)
     void setSamples(int value);
 ~~~
-`100;1;2;0;48;5,10`
+`100;200;2;0;48;1,5,10`
 
 If you want to decrease the temperature offset of a thermistor sensor to -2:
 ~~~c
     // [105] set a temperature offset
     void setOffset(float value);
 ~~~
-`100;1;2;0;48;105,-2`
+`100;200;2;0;48;1,105,-2`
 
-Please note that anything set remotely will NOT persist a reboot apart from the sleep interval which is saved to the EEPROM (provided `PERSIST` is enabled).
+Please note that anything set remotely will NOT persist a reboot apart from the sleep interval which is saved to the EEPROM if setSaveSleepSettings() is set.
 
-## Understanding NodeManager: how it works
+## Creating a new sensor
+
+### NodeManager's internal architecture review
 
 A NodeManager object is created for you at the beginning of your sketch and its main functions must be called from within `before()`, `presentation()`, `loop()` and `receive()` to work properly. NodeManager will do the following during each phase:
 
 NodeManager::before():
 * Setup the interrupt pins to wake up the board based on the configured interrupts
-* If persistance is enabled, restore from the EEPROM the latest sleeping settings
+* Restore from the EEPROM the latest sleeping settings, if setSaveSleepSettings() was set
 * Call `before()` of each registered sensor
 
 Sensor::before():
-* Call sensor-specific implementation of before by invoking `onBefore()` to initialize the sensor
+* Call sensor-specific implementation of before by invoking `onBefore()` to initialize the sensor. 
 
 NodeManager::setup():
-* Send a custom message with a STARTED payload to the controller
 * Call `setup()` of each registered sensor
 
 Sensor::setup():
@@ -843,462 +573,41 @@ NodeManager::loop():
 
 Sensor::loop():
 * If the sensor is powered by an arduino pin, this is set to on
-* For each registered sensor, the sensor-specific `onLoop()` is called. If multiple samples are requested, this is run multiple times. `onLoop()` is not intended to send out any message but just sets a new value to a local variable
-* In case multiple samples have been collected, the average is calculated
-* A message is sent to the gateway with the calculated value. Depending on the configuration, this is not sent if it is the same as the previous value or sent anyway after a given number of cycles. These functionalies are not sensor-specific and common to all the sensors inheriting from the `Sensor` class.
+* For each registered sensor, the sensor-specific `onLoop()` is called. If multiple samples are requested, this is run multiple times. `onLoop()` is not intended to send out any message but just sets a new value to the requested child
+* A message is sent to the gateway with the value. Depending on the configuration, this is not sent if it is the same as the previous value or sent anyway after a given number of cycles. These functionalies are not sensor-specific and common to all the sensors inheriting from the `Sensor` class.
 * If the sensor is powered by an arduino pin, this is turned off
 
 NodeManager::receive():
 * Receive a message from the radio network 
-* If the destination child id is the configuration node, it will handle the incoming message, otherwise will dispatch the message to the recipient sensor
+* Dispatch the message to the recipient sensor
 
 Sensor::receive(): 
 * Invoke `Sensor::loop()` which will execute the sensor main taks and eventually call `Sensor::onReceive()`
 
-NodeManager::process():
-* Process an incoming remote configuration request
-
-Sensor::process():
-* Process a sensor-generic incoming remote configuration request
-* Calls `onProcess()` for sensor-specific incoming remote configuration request
-
 Sensor::interrupt():
 * Calls the sensor's implementation of `onInterrupt()` to handle the interrupt
 
-## Examples
-All the examples below takes place within the before() function in the main sketch, just below the "Register below your sensors" comment.
-
-Set battery minimum and maxium voltage. This will be used to calculate the level percentage:
-
-~~~c
-    nodeManager.setBatteryMin(1.8);
-    nodeManager.setBatteryMin(3.2);
-~~~
-
-Instruct the board to sleep for 10 minutes at each cycle:
-
-~~~c
-    nodeManager.setSleepMinutes(10);
-~~~
-
-Configure a wake up pin. When pin 3 is connected to ground, the board will stop sleeping:
-
-~~~c
-    nodeManager.setSleepInterruptPin(3);
-~~~
-
-Use the arduino pins to power on and off the attached sensors. All the sensors' vcc and ground are connected to pin 6 (ground) and 7 (vcc). NodeManager will enable the vcc pin every time just before loop() and wait for 100ms for the power to settle before running loop() of each sensor:
-
-~~~c
-   nodeManager.setPowerPins(6,7,100);
-~~~
-
-Register a thermistor sensor attached to pin A2. NodeManager will then send the temperature to the controller at the end of each sleeping cycle:
-
-~~~c
-   nodeManager.registerSensor(SENSOR_THERMISTOR,A2);
-~~~
-
-Register a SHT21 temperature/humidity sensor; since using I2C for communicating with the sensor, the pins used are implicit (A4 and A5). NodeManager will then send the temperature and the humidity to the controller at the end of each sleeping cycle:
-
-~~~c
-   nodeManager.registerSensor(SENSOR_SHT21);
-~~~
-
-Register a LDR sensor attached to pin A1 and send to the gateway the average of 3 samples:
-
-~~~c
-  int sensor_ldr = nodeManager.registerSensor(SENSOR_LDR,A1);
-  ((SensorLDR*)nodeManager.getSensor(sensor_ldr))->setSamples(3);
-~~~
-
-Register a rain sensor connected to A0. This will be powered with via pins 4 (ground) and 5 (vcc) just before reading its value at each cycle, it will be presented as S_RAIN. sending V_RAINRATE messages, the output will be a percentage (calculated between 200 and 1024) and the value will be reversed (so that no rain will be 0%):
-
-~~~c
-  int rain = nodeManager.registerSensor(SENSOR_ANALOG_INPUT,A0);
-  SensorAnalogInput* rainSensor = ((SensorAnalogInput*)nodeManager.getSensor(rain));
-  rainSensor->setPowerPins(4,5,300);
-  rainSensor->setPresentation(S_RAIN);
-  rainSensor->setType(V_RAINRATE);
-  rainSensor->setOutputPercentage(true);
-  rainSensor->setRangeMin(200);
-  rainSensor->setRangeMax(1024);
-  rainSensor->setReverse(true);
-~~~
-
-Register a latching relay connecting to pin 6 (set) and pin 7 (unset):
-
-~~~c
-  nodeManager.registerSensor(SENSOR_LATCHING_RELAY,6);
-~~~
-
-## Example Sketches
-
-*  Analog Light and Temperature Sensor
-
-The following sketch can be used to report the temperature and the light level based on a thermistor and LDR sensors attached to two analog pins of the arduino board (A1 and A2). Both the thermistor and the LDR are connected to ground on one side and to vcc via a resistor on the other so to measure the voltage drop across each of them through the analog pins. 
-
-The sensor will be put to sleep after startup and will report both the measures every 10 minutes. NodeManager will take care of presenting the sensors, managing the sleep cycle, reporting the battery level every hour and report the measures in the appropriate format. This sketch requires MODULE_ANALOG_INPUT enabled in the global config.h file.
-
-Even if the sensor is sleeping most of the time, it can be potentially woke up by sending a V_CUSTOM message to NodeManager service child id (200 by default) just after having reported its heartbeat. At this point the node will report awake and the user can interact with it by e.g. sending REQ messages to its child IDs, changing the duration of a sleep cycle, etc.
-
-~~~c
-/*
-NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, speeding up the development cycle of your projects.
-
-NodeManager includes the following main components:
-- Sleep manager: allows managing automatically the complexity behind battery-powered sensors spending most of their time sleeping
-- Power manager: allows powering on your sensors only while the node is awake
-- Battery manager: provides common functionalities to read and report the battery level
-- Remote configuration: allows configuring remotely the node without the need to have physical access to it
-- Built-in personalities: for the most common sensors, provide embedded code so to allow their configuration with a single line 
-
-Documentation available on: https://github.com/mysensors/NodeManager
- */
-
- 
-// load user settings
-#include "config.h"
-// load MySensors library
-#include <MySensors.h>
-// load NodeManager library
-#include "NodeManager.h"
-
-// create a NodeManager instance
-NodeManager nodeManager;
-
-// before
-void before() {
-  // setup the serial port baud rate
-  Serial.begin(MY_BAUD_RATE);  
-  /*
-   * Register below your sensors
-  */
-  nodeManager.setSleepMinutes(10);
-  nodeManager.setReportIntervalMinutes(10);
-  nodeManager.registerSensor(SENSOR_THERMISTOR,A1);
-  nodeManager.registerSensor(SENSOR_LDR,A2);
-  /*
-   * Register above your sensors
-  */
-  nodeManager.before();
-}
-
-// presentation
-void presentation() {
-  // call NodeManager presentation routine
-  nodeManager.presentation();
-
-}
-
-// setup
-void setup() {
-  // call NodeManager setup routine
-  nodeManager.setup();
-}
-
-// loop
-void loop() {
-  // call NodeManager loop routine
-  nodeManager.loop();
-
-}
-
-// receive
-void receive(const MyMessage &message) {
-  // call NodeManager receive routine
-  nodeManager.receive(message);
-}
-
-// receiveTime
-void receiveTime(unsigned long ts) {
-  // call NodeManager receiveTime routine
-  nodeManager.receiveTime(ts);
-}
-~~~
-
-*  Motion Sensor
-
-The following sketch can be used to report back to the controller when a motion sensor attached to the board's pin 3 triggers. In this example, the board will be put to sleep just after startup and will report a heartbeat every hour. NodeManager will take care of configuring an interrupt associated to the provided pin so automatically wake up when a motion is detected and report a V_TRIPPED message back. This sketch requires MODULE_SWITCH to be enabled in the global config.h file.
-
-~~~c
-/*
-NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, speeding up the development cycle of your projects.
-
-NodeManager includes the following main components:
-- Sleep manager: allows managing automatically the complexity behind battery-powered sensors spending most of their time sleeping
-- Power manager: allows powering on your sensors only while the node is awake
-- Battery manager: provides common functionalities to read and report the battery level
-- Remote configuration: allows configuring remotely the node without the need to have physical access to it
-- Built-in personalities: for the most common sensors, provide embedded code so to allow their configuration with a single line 
-
-Documentation available on: https://github.com/mysensors/NodeManager 
- */
-
- 
-// load user settings
-#include "config.h"
-// include supporting libraries
-#ifdef MY_GATEWAY_ESP8266
-  #include <ESP8266WiFi.h>
-#endif
-// load MySensors library
-#include <MySensors.h>
-// load NodeManager library
-#include "NodeManager.h"
-
-// create a NodeManager instance
-NodeManager nodeManager;
-
-// before
-void before() {
-  // setup the serial port baud rate
-  Serial.begin(MY_BAUD_RATE);  
-  /*
-   * Register below your sensors
-  */
-  nodeManager.setSleepHours(1);
-  nodeManager.registerSensor(SENSOR_MOTION,3);
-
-  /*
-   * Register above your sensors
-  */
-  nodeManager.before();
-}
-
-// presentation
-void presentation() {
-  // call NodeManager presentation routine
-  nodeManager.presentation();
-
-}
-
-// setup
-void setup() {
-  // call NodeManager setup routine
-  nodeManager.setup();
-}
-
-// loop
-void loop() {
-  // call NodeManager loop routine
-  nodeManager.loop();
-
-}
-
-// receive
-void receive(const MyMessage &message) {
-  // call NodeManager receive routine
-  nodeManager.receive(message);
-}
-
-// receiveTime
-void receiveTime(unsigned long ts) {
-  // call NodeManager receiveTime routine
-  nodeManager.receiveTime(ts);
-}
-~~~
-
-*  Boiler Sensor
-
-The following sketch controls a latching relay connected to a boiler. A latching relay (requiring only a pulse to switch) has been chosen to minimize the power consumption required by a traditional relay to stay on. This relay has normally two pins, one for closing and the other for opening the controlled circuit, connected to pin 6 and 7 of the arduino board. Since using a SENSOR_LATCHING_RELAY type of sensor, NodeManager will automatically consider the provided pin as the ON pin and the one just after as the OFF pin and will take care of just sending out a single pulse only when a SET command of type V_STATUS is sent to the child id. The appropriate pin will be then used.
-
-In this example, the board also runs at 1Mhz so it can go down to 1.8V: by setting setBatteryMin() and setBatteryMax(), the battery percentage will be calculated and reported (by default, automatically every 10 sleeping cycles) based on these custom boundaries.
-
-The board will be put to sleep just after startup and will report back to the controller every 5 minutes. It is the controller's responsability to catch when the board reports its heartbeat (using smart sleep behind the scene) and send a command back if needed. This sketch requires MODULE_DIGITAL_OUTPUT to be enabled in the config.h file.
+### Custom sensors
 
+If you want to create a new sensor, you can create a new class inheriting from Sensor or other subclasses. The constructor is supposed to assign to assign the sensor a name through the `_name` variable. The following methods have to be implemented:
 ~~~c
-/*
-NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, speeding up the development cycle of your projects.
-
-NodeManager includes the following main components:
-- Sleep manager: allows managing automatically the complexity behind battery-powered sensors spending most of their time sleeping
-- Power manager: allows powering on your sensors only while the node is awake
-- Battery manager: provides common functionalities to read and report the battery level
-- Remote configuration: allows configuring remotely the node without the need to have physical access to it
-- Built-in personalities: for the most common sensors, provide embedded code so to allow their configuration with a single line 
-
-Documentation available on: https://github.com/mysensors/NodeManager 
- */
-
- 
-// load user settings
-#include "config.h"
-// include supporting libraries
-#ifdef MY_GATEWAY_ESP8266
-  #include <ESP8266WiFi.h>
-#endif
-// load MySensors library
-#include <MySensors.h>
-// load NodeManager library
-#include "NodeManager.h"
-
-// create a NodeManager instance
-NodeManager nodeManager;
-
-// before
-void before() {
-  // setup the serial port baud rate
-  Serial.begin(MY_BAUD_RATE);  
-  /*
-   * Register below your sensors
-  */
-  nodeManager.setBatteryMin(1.8);
-  nodeManager.setBatteryMax(3.2);
-  nodeManager.setSleepMinutes(5);
-  nodeManager.registerSensor(SENSOR_LATCHING_RELAY,6);
-
-  /*
-   * Register above your sensors
-  */
-  nodeManager.before();
-}
-
-// presentation
-void presentation() {
-  // call NodeManager presentation routine
-  nodeManager.presentation();
-
-}
-
-// setup
-void setup() {
-  // call NodeManager setup routine
-  nodeManager.setup();
-}
-
-// loop
-void loop() {
-  // call NodeManager loop routine
-  nodeManager.loop();
-
-}
-
-// receive
-void receive(const MyMessage &message) {
-  // call NodeManager receive routine
-  nodeManager.receive(message);
-}
-
-// receiveTime
-void receiveTime(unsigned long ts) {
-  // call NodeManager receiveTime routine
-  nodeManager.receiveTime(ts);
-}
+    // define what to do during before(). Usually creates all the Child(ren) which belong to the sensor
+    void onBefore();
+	// define what to do during setup(). Usually initialize the required libraries
+    void onSetup();
+    // define what to do during loop() by executing the sensor's main task. Usually does a calculation and store the value to send back to the given Child class.
+    void onLoop(Child* child);
+    // define what to do during receive() when the sensor receives a message
+    void onReceive(MyMessage* message);
+    // define what to do when receiving an interrupt
+    void onInterrupt();
 ~~~
 
+If the sensor implements a remote API, this has to be made available in SensorConfiguration::onReceive.
 
-*  Rain and Soil Moisture Sensor
-
-The following sketch can be used to report the rain level and the soil moisture based on two sensors connected to the board's analog pins (A1 and A2). In this case we are customizing the out-of-the-box SENSOR_ANALOG_INPUT sensor type since we just need to measure an analog input but we also want to provide the correct type and presentation for each sensor. 
-
-We register the sensors first with registerSensor() which returns the child id assigned to the sensor. We then retrieve the sensor's reference by calling getSensor() so we can invoke the sensor-specific functions, like setPresentation() and setType().
-
-In this example, the two sensors are not directly connected to the battery's ground and vcc but, to save additional power, are powered through two arduino's pins. By using e.g. setPowerPins(4,5,300), NodeManger will assume pin 4 is ground and pin 5 is vcc for that specific sensor so it will turn on the power just before reading the analog input (and waiting 300ms for the sensor to initialize) and back off before going to sleep.
-
-For both the sensors we want a percentage output and with setRangeMin() and setRangeMax() we define the boundaries for calculating the percentage (if we read e.g. 200 when the rain sensor is completely into the water, we know for sure it will not go below this value which will represent the new lower boundary). 
-Finally, since both the sensors reports low when wet and high when dry but we need the opposite, we set setReverse() so to have 0% reported when there is no rain/moisture, 100% on the opposite situation.
-
-~~~c
-/*
-NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, speeding up the development cycle of your projects.
+## Examples
 
-NodeManager includes the following main components:
-- Sleep manager: allows managing automatically the complexity behind battery-powered sensors spending most of their time sleeping
-- Power manager: allows powering on your sensors only while the node is awake
-- Battery manager: provides common functionalities to read and report the battery level
-- Remote configuration: allows configuring remotely the node without the need to have physical access to it
-- Built-in personalities: for the most common sensors, provide embedded code so to allow their configuration with a single line 
-
-Documentation available on: https://github.com/mysensors/NodeManager 
- */
-
- 
-// load user settings
-#include "config.h"
-// include supporting libraries
-#ifdef MY_GATEWAY_ESP8266
-  #include <ESP8266WiFi.h>
-#endif
-// load MySensors library
-#include <MySensors.h>
-// load NodeManager library
-#include "NodeManager.h"
-
-// create a NodeManager instance
-NodeManager nodeManager;
-
-// before
-void before() {
-  // setup the serial port baud rate
-  Serial.begin(MY_BAUD_RATE);  
-  /*
-   * Register below your sensors
-  */
-  analogReference(DEFAULT);
-  nodeManager.setSleepMinutes(10);
-  nodeManager.setReportIntervalMinutes(10);
-  
-  int rain = nodeManager.registerSensor(SENSOR_ANALOG_INPUT,A1);
-  int soil = nodeManager.registerSensor(SENSOR_ANALOG_INPUT,A2);
-  
-  SensorAnalogInput* rainSensor = ((SensorAnalogInput*)nodeManager.getSensor(rain));
-  SensorAnalogInput* soilSensor = ((SensorAnalogInput*)nodeManager.getSensor(soil));
-  
-  rainSensor->setPresentation(S_RAIN);
-  rainSensor->setType(V_RAINRATE);
-  rainSensor->setPowerPins(4,5,300);
-  rainSensor->setOutputPercentage(true);
-  rainSensor->setRangeMin(200);
-  rainSensor->setRangeMax(1024);
-  rainSensor->setReverse(true);
-  
-  soilSensor->setPresentation(S_MOISTURE);
-  soilSensor->setType(V_LEVEL);
-  soilSensor->setPowerPins(6,7,300);
-  soilSensor->setOutputPercentage(true);
-  soilSensor->setRangeMin(300);
-  soilSensor->setRangeMax(1024);
-  soilSensor->setReverse(true);
-
-  /*
-   * Register above your sensors
-  */
-  nodeManager.before();
-}
-
-// presentation
-void presentation() {
-  // call NodeManager presentation routine
-  nodeManager.presentation();
-
-}
-
-// setup
-void setup() {
-  // call NodeManager setup routine
-  nodeManager.setup();
-}
-
-// loop
-void loop() {
-  // call NodeManager loop routine
-  nodeManager.loop();
-
-}
-
-// receive
-void receive(const MyMessage &message) {
-  // call NodeManager receive routine
-  nodeManager.receive(message);
-}
-
-// receiveTime
-void receiveTime(unsigned long ts) {
-  // call NodeManager receiveTime routine
-  nodeManager.receiveTime(ts);
-}
-~~~
+Examples and sample code is provided from within the main sketch.
 
 ## Contributing
 
@@ -1429,3 +738,5 @@ v1.6:
 * Added safeguard (automatic off) to SensorDigitalOutput
 * Any sensor can now access all NodeManager's functions
 * DHT sensor now using MySensors' DHT library
+
+v1.7:
\ No newline at end of file

From f85dc1c0b4e50acb97c42f844b8a0c373b4d6c12 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Sun, 17 Dec 2017 18:11:46 +0100
Subject: [PATCH 50/51] Tested random sensors and fixed issues

---
 NodeManager.ino        | 17 ++++++------
 NodeManagerLibrary.h   |  3 +++
 NodeManagerLibrary.ino | 61 +++++++++++++++++++++++++++++++-----------
 README.md              |  1 +
 4 files changed, 57 insertions(+), 25 deletions(-)

diff --git a/NodeManager.ino b/NodeManager.ino
index 833990a..5ef34f7 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -28,7 +28,6 @@
 #define SKETCH_NAME "NodeManager"
 #define SKETCH_VERSION "1.0"
 
-
 /**********************************
  * MySensors node configuration
  */
@@ -131,7 +130,7 @@
  * NodeManager configuration
  */
 
-// if enabled, enable debug messages on serial port
+// enable NodeManager's debug on serial port
 #define DEBUG 1
 
 // Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SensorRain, SensorSoilMoisture
@@ -183,7 +182,7 @@
 // Enable this module to use one of the following sensors: SensorDimmer
 #define MODULE_DIMMER 0
 // Enable this module to use one of the following sensors: SensorRainGauge, SensorPowerMeter, SensorWaterMeter
-#define MODULE_PULSE_METER 1
+#define MODULE_PULSE_METER 0
 
 /***********************************
  * Load NodeManager Library
@@ -197,7 +196,7 @@ NodeManager node;
  */
 
 //SensorBattery battery(node);
-SensorConfiguration configuration(node);
+//SensorConfiguration configuration(node);
 //SensorSignal signal(node);
 //PowerManager power(5,6);
 
@@ -219,24 +218,24 @@ SensorConfiguration configuration(node);
 //SensorSwitch sensorSwitch(node,3);
 //SensorDoor door(node,3);
 //SensorMotion motion(node,3);
-//SensorDs18b20 ds18b20(node,4);
+//SensorDs18b20 ds18b20(node,6);
 //SensorBH1750 bh1750(node);
 //SensorMLX90614 mlx90614(node);
 //SensorBME280 bme280(node);
 //SensorBMP085 bmp085(node);
 //SensorBMP280 bmp280(node);
 //SensorSonoff sonoff(node);
-//SensorHCSR04 hcsr04(node,4);
+//SensorHCSR04 hcsr04(node,6);
 //SensorMCP9808 mcp9808(node);
 //SensorMQ mq(node,A0);
 //SensorMHZ19 mhz19(node,6);
 //SensorAM2320 am2320(node);
 //SensorTSL2561 tsl2561(node);
-//SensorPT100 pt100(node,4);
+//SensorPT100 pt100(node,6);
 //SensorDimmer dimmer(node,A0);
 //SensorRainGauge rainGauge(node,3);
 //SensorPowerMeter powerMeter(node,3);
-SensorWaterMeter waterMeter(node,3);
+//SensorWaterMeter waterMeter(node,3);
 
 /***********************************
  * Main Sketch
@@ -251,7 +250,7 @@ void before() {
  * Configure your sensors below
  */
 
-  node.setReportIntervalSeconds(20);
+  node.setReportIntervalSeconds(10);
   //battery.setReportIntervalSeconds(10);
   //node.setSleepSeconds(20);
   
diff --git a/NodeManagerLibrary.h b/NodeManagerLibrary.h
index 8fcd97c..fe8f3dc 100644
--- a/NodeManagerLibrary.h
+++ b/NodeManagerLibrary.h
@@ -959,6 +959,7 @@ class SensorBME280: public SensorBosch {
     SensorBME280(const NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
+    void onSetup();
     void onLoop(Child* child);
   protected:
     Adafruit_BME280* _bm;
@@ -974,6 +975,7 @@ class SensorBMP085: public SensorBosch {
     SensorBMP085(const NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
+    void onSetup();
     void onLoop(Child* child);
   protected:
     Adafruit_BMP085* _bm;
@@ -989,6 +991,7 @@ class SensorBMP280: public SensorBosch {
     SensorBMP280(const NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
+    void onSetup();
     void onLoop(Child* child);
   protected:
     Adafruit_BMP280* _bm;
diff --git a/NodeManagerLibrary.ino b/NodeManagerLibrary.ino
index b919f14..db4a865 100644
--- a/NodeManagerLibrary.ino
+++ b/NodeManagerLibrary.ino
@@ -1425,8 +1425,6 @@ void SensorDigitalOutput::setWaitAfterSet(int value) {
 
 // main task
 void SensorDigitalOutput::onLoop(Child* child) {
-  // set the value to -1 so to avoid reporting to the gateway during loop
-  ((ChildInt*)child)->setValueInt(-1);
   // if a safeguard is set, check if it is time for it
   if (_safeguard_timer->isRunning()) {
     // update the timer
@@ -1834,7 +1832,7 @@ void SensorSwitch::onInterrupt() {
     if (_trigger_time > 0) _node->sleepOrWait(_trigger_time);
   } else {
     // invalid
-    ((ChildInt*)child)->setValueInt(-1);
+    ((ChildInt*)child)->setValueInt(-255);
   }
 }
 
@@ -1864,6 +1862,7 @@ void SensorMotion::onBefore() {
 
 // what to do during setup
 void SensorMotion::onSetup() {
+  SensorSwitch::onSetup();
   // set initial value to LOW
   setInitial(LOW);
 }
@@ -1882,7 +1881,7 @@ SensorDs18b20::SensorDs18b20(const NodeManager& node_manager, int pin): Sensor(n
 void SensorDs18b20::onBefore() {
   // initialize the library
   OneWire* oneWire = new OneWire(_pin);
-  DallasTemperature* _sensors = new DallasTemperature(oneWire);
+  _sensors = new DallasTemperature(oneWire);
   // initialize the sensors
   _sensors->begin();
   // register a new child for each sensor on the bus
@@ -2063,6 +2062,8 @@ void SensorMLX90614::onInterrupt() {
 // contructor
 SensorBosch::SensorBosch(const NodeManager& node_manager): Sensor(node_manager) {
   _name = "BOSH";
+  // initialize the forecast samples array
+  _forecast_samples = new float[_forecast_samples_count];
 }
 
 // setter/getter
@@ -2076,8 +2077,6 @@ void SensorBosch::onBefore() {
 
 // what to do during setup
 void SensorBosch::onSetup() {
-  // initialize the forecast samples array
-  _forecast_samples = new float[_forecast_samples_count];
 }
 
 // what to do during loop
@@ -2220,6 +2219,16 @@ void SensorBME280::onBefore() {
   new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
+// what to do during setup
+void SensorBME280::onSetup() {
+  _bm = new Adafruit_BME280();
+  if (! _bm->begin(SensorBosch::GetI2CAddress(0x60))) {
+    #if DEBUG == 1
+      Serial.println(F("ERR"));
+    #endif
+  }
+}
+
 void SensorBME280::onLoop(Child* child) {
   // temperature sensor
   if (child->type == V_TEMP) {
@@ -2290,6 +2299,16 @@ void SensorBMP085::onBefore() {
   new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
+// what to do during setup
+void SensorBMP085::onSetup() {
+  _bm = new Adafruit_BMP085();
+  if (! _bm->begin(SensorBosch::GetI2CAddress(0x55))) {
+    #if DEBUG == 1
+      Serial.println(F("ERR"));
+    #endif
+  }
+}
+
 // what to do during loop
 void SensorBMP085::onLoop(Child* child) {
   // temperature sensor
@@ -2346,6 +2365,16 @@ void SensorBMP280::onBefore() {
   new ChildString(this,_node->getAvailableChildId(),S_BARO,V_FORECAST);
 }
 
+// what to do during setup
+void SensorBMP280::onSetup() {
+  _bm = new Adafruit_BMP280();
+  if (! _bm->begin(SensorBosch::GetI2CAddress(0x58))) {
+    #if DEBUG == 1
+      Serial.println(F("ERR"));
+    #endif
+  }
+}
+
 void SensorBMP280::onLoop(Child* child) {
   // temperature sensor
   if (child->type == V_TEMP) {
@@ -3711,8 +3740,6 @@ void NodeManager::before() {
     // call each sensor's before()
     sensor->before();
   }
-  // setup the interrupt pins
-  setupInterrupts();
 }
 
 // present NodeManager and its sensors
@@ -3753,6 +3780,8 @@ void NodeManager::setup() {
     // call each sensor's setup()
     sensor->setup();
   }
+  // setup the interrupt pins
+  setupInterrupts();
 }
 
 // run the main function for all the register sensors
@@ -4057,21 +4086,21 @@ void NodeManager::_sendMessage(int child_id, int type) {
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
     #if DEBUG == 1
       Serial.print(F("SEND D="));
-		  Serial.print(_message.destination);
+      Serial.print(_message.destination);
       Serial.print(F(" I="));
-		  Serial.print(_message.sensor);
+      Serial.print(_message.sensor);
       Serial.print(F(" C="));
-		  Serial.print(_message.getCommand());
+      Serial.print(_message.getCommand());
       Serial.print(F(" T="));
-		  Serial.print(_message.type);
+      Serial.print(_message.type);
       Serial.print(F(" S="));
-		  Serial.print(_message.getString());
+      Serial.print(_message.getString());
       Serial.print(F(" I="));
-		  Serial.print(_message.getInt());
+      Serial.print(_message.getInt());
       Serial.print(F(" F="));
-		  Serial.println(_message.getFloat());
+      Serial.println(_message.getFloat());
     #endif
-		send(_message, _ack);
+    send(_message, _ack);
   }
 }
 
diff --git a/README.md b/README.md
index 315f277..61d1089 100755
--- a/README.md
+++ b/README.md
@@ -125,6 +125,7 @@ The sensor will be then registered automatically with NodeManager which will tak
 NodeManager will assign a child id automatically, present each sensor for you to the controller, query each sensor and report the measure back to the gateway/controller. For actuators (e.g. relays) those can be triggered by sending a `REQ` message with the expected type to their assigned child id.
 
 For your convenience, NodeManager makes available additional special sensors which can be added in the same way as other built-in sensors:
+
 Special Sensor  | Description
  ------------- | -------------
 SensorBattery | Add it to enable automatic battery reporting

From 588d767e6330366ff924e5c78c07f7ad169af450 Mon Sep 17 00:00:00 2001
From: user2684 <email@example.com>
Date: Mon, 25 Dec 2017 17:13:18 +0100
Subject: [PATCH 51/51] Tested, reviewed, integrated kainhofer fixes and
 updated docs

---
 NodeManager.ino        |  183 ++--
 NodeManagerLibrary.h   |  239 +++---
 NodeManagerLibrary.ino | 1850 ++++++++++++++++++----------------------
 README.md              |  421 +++++++--
 4 files changed, 1387 insertions(+), 1306 deletions(-)

diff --git a/NodeManager.ino b/NodeManager.ino
index 5ef34f7..db2f9d9 100755
--- a/NodeManager.ino
+++ b/NodeManager.ino
@@ -17,25 +17,77 @@
  * version 2 as published by the Free Software Foundation.
  *
  *******************************
- *
- * DESCRIPTION
- *
- * NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, 
- * speeding up the development cycle of your projects.
- * Documentation available on: https://github.com/mysensors/NodeManager
+
+ DESCRIPTION
+
+NodeManager is intended to take care on your behalf of all those common tasks a MySensors node has to accomplish, 
+speeding up the development cycle of your projects.
+Documentation available on: https://github.com/mysensors/NodeManager
+NodeManager provides built-in implementation of a number of sensors through ad-hoc classes. 
+
+To use a buil-in sensor:
+* Install the required library if any
+* Enable the corresponding module (uncomment it) in the main sketch
+* Declare the sensor (uncomment it) in the main sketch
+
+Once created, the sensor will automatically present one or more child to the gateway and controller.
+A list of buil-in sensors, module to enable, required dependencies and the number of child automatically created is presented below:
+
+Sensor Name         |#Child | Module to enable      | Description                                                                                       | Dependencies
+--------------------|-------|-----------------------|---------------------------------------------------------------------------------------------------|----------------------------------------------------------
+SensorBattery       | 1     | -                     | Built-in sensor for automatic battery reporting                                                   | - 
+SensorSignal        | 1     | -                     | Built-in sensor for automatic signal level reporting                                              | -
+SensorConfiguration | 1     | -                     | Built-in sensor for OTA remote configuration of any registered sensor                             | -
+SensorAnalogInput   | 1     | MODULE_ANALOG_INPUT   | Generic analog sensor, return a pin's analog value or its percentage                              | -
+SensorLDR           | 1     | MODULE_ANALOG_INPUT   | LDR sensor, return the light level of an attached light resistor in percentage                    | -
+SensorRain          | 1     | MODULE_ANALOG_INPUT   | Rain sensor, return the percentage of rain from an attached analog sensor                         | -
+SensorSoilMoisture  | 1     | MODULE_ANALOG_INPUT   | Soil moisture sensor, return the percentage of moisture from an attached analog sensor            | -
+SensorThermistor    | 1     | MODULE_THERMISTOR     | Thermistor sensor, return the temperature based on the attached thermistor                        | -
+SensorML8511        | 1     | MODULE_ML8511         | ML8511 sensor, return UV intensity                                                                | -
+SensorACS712        | 1     | MODULE_ACS712         | ACS712 sensor, measure the current going through the attached module                              | -
+SensorDigitalInput  | 1     | MODULE_DIGITAL_INPUT  | Generic digital sensor, return a pin's digital value                                              | -
+SensorDigitalOutput | 1     | MODULE_DIGITAL_OUTPUT | Generic digital output sensor, allows setting the digital output of a pin to the requested value  | -
+SensorRelay         | 1     | MODULE_DIGITAL_OUTPUT | Relay sensor, allows activating the relay                                                         | -
+SensorLatchingRelay | 1     | MODULE_DIGITAL_OUTPUT | Latching Relay sensor, allows activating the relay with a pulse                                   | -
+SensorDHT11         | 2     | MODULE_DHT            | DHT11 sensor, return temperature/humidity based on the attached DHT sensor                        | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/DHT
+SensorDHT22         | 2     | MODULE_DHT            | DHT22 sensor, return temperature/humidity based on the attached DHT sensor                        | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/DHT
+SensorSHT21         | 2     | MODULE_SHT21          | SHT21 sensor, return temperature/humidity based on the attached SHT21 sensor                      | https://github.com/SodaqMoja/Sodaq_SHT2x
+SensorHTU21D        | 2     | MODULE_SHT21          | HTU21D sensor, return temperature/humidity based on the attached HTU21D sensor                    | https://github.com/SodaqMoja/Sodaq_SHT2x
+SensorSwitch        | 1     | MODULE_SWITCH         | Generic switch, wake up the board when a pin changes status                                       | -
+SensorDoor          | 1     | MODULE_SWITCH         | Door sensor, wake up the board and report when an attached magnetic sensor has been opened/closed | -
+SensorMotion        | 1     | MODULE_SWITCH         | Motion sensor, wake up the board and report when an attached PIR has triggered                    | -
+SensorDs18b20       | 1+    |  MODULE_DS18B20       | DS18B20 sensor, return the temperature based on the attached sensor                               | https://github.com/milesburton/Arduino-Temperature-Control-Library
+SensorBH1750        | 1     | MODULE_BH1750         | BH1750 sensor, return light level in lux                                                          | https://github.com/claws/BH1750
+SensorMLX90614      | 2     | MODULE_MLX90614       | MLX90614 contactless temperature sensor, return ambient and object temperature                    | https://github.com/adafruit/Adafruit-MLX90614-Library
+SensorBME280        | 4     | MODULE_BME280         | BME280 sensor, return temperature/humidity/pressure based on the attached BME280 sensor           | https://github.com/adafruit/Adafruit_BME280_Library
+SensorBMP085        | 3     | MODULE_BMP085         | BMP085/BMP180 sensor, return temperature and pressure                                             | https://github.com/adafruit/Adafruit-BMP085-Library
+SensorBMP280        | 3     | MODULE_BMP280         | BMP280 sensor, return temperature/pressure based on the attached BMP280 sensor                    | https://github.com/adafruit/Adafruit_BMP280_Library
+SensorSonoff        | 1     | MODULE_SONOFF         | Sonoff wireless smart switch                                                                      | https://github.com/thomasfredericks/Bounce2
+SensorHCSR04        | 1     | MODULE_HCSR04         | HC-SR04 sensor, return the distance between the sensor and an object                              | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/NewPing
+SensorMCP9808       | 1     | MODULE_MCP9808        | MCP9808 sensor, measure the temperature through the attached module                               | https://github.com/adafruit/Adafruit_MCP9808_Library
+SensorMQ            | 1     | MODULE_MQ             | MQ sensor, return ppm of the target gas                                                           | -
+SensorMHZ19         | 1     | MODULE_MHZ19          | MH-Z19 CO2 sensor via UART (SoftwareSerial, default on pins 6(Rx) and 7(Tx)                       | -
+SensorAM2320        | 2     | MODULE_AM2320         | AM2320 sensors, return temperature/humidity based on the attached AM2320 sensor                   | https://github.com/thakshak/AM2320
+SensorTSL2561       | 1     | MODULE_TSL2561        | TSL2561 sensor, return light in lux                                                               | https://github.com/adafruit/TSL2561-Arduino-Library
+SensorPT100         | 1     | MODULE_PT100          | DFRobot Driver high temperature sensor, return the temperature from the attached PT100 sensor     | -
+SensorDimmer        | 1     | MODULE_DIMMER         | Generic dimmer sensor used to drive a pwm output                                                  | -
+SensorRainGauge     | 1     | MODULE_PULSE_METER    | Rain gauge sensor                                                                                 | -
+SensorPowerMeter    | 1     | MODULE_PULSE_METER    | Power meter pulse sensor                                                                          | -
+SensorWaterMeter    | 1     | MODULE_PULSE_METER    | Water meter pulse sensor                                                                          | -
+SensorPlantowerPMS  | 3     | MODULE_PMS            | Plantower PMS particulate matter sensors (reporting PM<=1.0, PM<=2.5 and PM<=10.0 in g/m)       | https://github.com/fu-hsi/pms
+
 */
- 
-#define SKETCH_NAME "NodeManager"
-#define SKETCH_VERSION "1.0"
 
 /**********************************
  * MySensors node configuration
  */
 
 // General settings
+#define SKETCH_NAME "NodeManager"
+#define SKETCH_VERSION "1.0"
 #define MY_BAUD_RATE 9600
 //#define MY_DEBUG
-#define MY_NODE_ID 99
+//#define MY_NODE_ID 99
 //#define MY_SMART_SLEEP_WAIT_DURATION_MS 500
 #define MY_SPLASH_SCREEN_DISABLED
 
@@ -44,7 +96,7 @@
 //#define MY_RF24_ENABLE_ENCRYPTION
 //#define MY_RF24_CHANNEL 125
 //#define MY_RF24_PA_LEVEL RF24_PA_HIGH
-//#define MY_DEBUG_VERBOSE_RF24
+//#define MY_NODEMANAGER_DEBUG_VERBOSE_RF24
 //#define MY_RF24_DATARATE RF24_250KBPS
 
 // RFM69 radio settings
@@ -55,7 +107,7 @@
 //#define MY_RFM69_NEW_DRIVER
 //#define MY_RFM69_ENABLE_ENCRYPTION
 //#define MY_RFM69_NETWORKID 100
-//#define MY_DEBUG_VERBOSE_RFM69
+//#define MY_NODEMANAGER_DEBUG_VERBOSE_RFM69
 //#define MY_RF69_IRQ_PIN D1
 //#define MY_RF69_IRQ_NUM MY_RF69_IRQ_PIN
 //#define MY_RF69_SPI_CS D2
@@ -83,6 +135,7 @@
 /**********************************
  * MySensors gateway configuration
  */
+ 
 // Common gateway settings
 //#define MY_REPEATER_FEATURE
 
@@ -127,67 +180,43 @@
 //#define MY_DEFAULT_TX_LED_PIN  6
 
 /***********************************
- * NodeManager configuration
+ * NodeManager modules
  */
 
-// enable NodeManager's debug on serial port
-#define DEBUG 1
-
-// Enable this module to use one of the following sensors: SensorAnalogInput, SensorLDR, SensorRain, SensorSoilMoisture
-#define MODULE_ANALOG_INPUT 0
-// Enable this module to use one of the following sensors: SensorThermistor
-#define MODULE_THERMISTOR 0
-// Enable this module to use one of the following sensors: SensorML8511
-#define MODULE_ML8511 0
-// Enable this module to use one of the following sensors: SensorACS712
-#define MODULE_ACS712 0
-// Enable this module to use one of the following sensors: SensorDigitalInput
-#define MODULE_DIGITAL_INPUT 0
-// Enable this module to use one of the following sensors: SensorDigitalOutput, SensorRelay, SensorLatchingRelay
-#define MODULE_DIGITAL_OUTPUT 0
-// Enable this module to use one of the following sensors: SensorDHT11, SensorDHT22
-#define MODULE_DHT 0
-// Enable this module to use one of the following sensors: SensorSHT21, SensorHTU21D
-#define MODULE_SHT21 0
-// Enable this module to use one of the following sensors: SensorSwitch, SensorDoor, SensorMotion
-#define MODULE_SWITCH 0
-// Enable this module to use one of the following sensors: SensorDs18b20
-#define MODULE_DS18B20 0
-// Enable this module to use one of the following sensors: SensorBH1750
-#define MODULE_BH1750 0
-// Enable this module to use one of the following sensors: SensorMLX90614
-#define MODULE_MLX90614 0
-// Enable this module to use one of the following sensors: SensorBME280
-#define MODULE_BME280 0
-// Enable this module to use one of the following sensors: SensorBMP085
-#define MODULE_BMP085 0
-// Enable this module to use one of the following sensors: SensorBMP280
-#define MODULE_BMP280 0
-// Enable this module to use one of the following sensors: SensorSonoff
-#define MODULE_SONOFF 0
-// Enable this module to use one of the following sensors: SensorHCSR04
-#define MODULE_HCSR04 0
-// Enable this module to use one of the following sensors: SensorMCP9808
-#define MODULE_MCP9808 0
-// Enable this module to use one of the following sensors: SensorMQ
-#define MODULE_MQ 0
-// Enable this module to use one of the following sensors: SensorMHZ19
-#define MODULE_MHZ19 0
-// Enable this module to use one of the following sensors: SensorAM2320    
-#define MODULE_AM2320 0
-// Enable this module to use one of the following sensors: SensorTSL2561    
-#define MODULE_TSL2561 0
-// Enable this module to use one of the following sensors: SensorPT100
-#define MODULE_PT100 0
-// Enable this module to use one of the following sensors: SensorDimmer
-#define MODULE_DIMMER 0
-// Enable this module to use one of the following sensors: SensorRainGauge, SensorPowerMeter, SensorWaterMeter
-#define MODULE_PULSE_METER 0
+//#define MODULE_ANALOG_INPUT
+//#define MODULE_THERMISTOR
+//#define MODULE_ML8511
+//#define MODULE_ACS712
+//#define MODULE_DIGITAL_INPUT
+//#define MODULE_DIGITAL_OUTPUT
+//#define MODULE_DHT
+//#define MODULE_SHT21
+//#define MODULE_SWITCH
+//#define MODULE_DS18B20
+//#define MODULE_BH1750
+//#define MODULE_MLX90614
+//#define MODULE_BME280
+//#define MODULE_BMP085
+//#define MODULE_BMP280
+//#define MODULE_SONOFF
+//#define MODULE_HCSR04
+//#define MODULE_MCP9808
+//#define MODULE_MQ
+//#define MODULE_MHZ19
+//#define MODULE_AM2320
+//#define MODULE_TSL2561
+//#define MODULE_PT100
+//#define MODULE_DIMMER
+//#define MODULE_PULSE_METER
+//#define MODULE_PMS
 
 /***********************************
  * Load NodeManager Library
  */
- 
+
+// enable NodeManager's debug on serial port
+#define NODEMANAGER_DEBUG
+// include NodeManager's library
 #include "NodeManagerLibrary.h"
 NodeManager node;
 
@@ -228,7 +257,7 @@ NodeManager node;
 //SensorHCSR04 hcsr04(node,6);
 //SensorMCP9808 mcp9808(node);
 //SensorMQ mq(node,A0);
-//SensorMHZ19 mhz19(node,6);
+//SensorMHZ19 mhz19(node,6,7);
 //SensorAM2320 am2320(node);
 //SensorTSL2561 tsl2561(node);
 //SensorPT100 pt100(node,6);
@@ -236,6 +265,7 @@ NodeManager node;
 //SensorRainGauge rainGauge(node,3);
 //SensorPowerMeter powerMeter(node,3);
 //SensorWaterMeter waterMeter(node,3);
+//SensorPlantowerPMS pms(node,6,7);
 
 /***********************************
  * Main Sketch
@@ -246,21 +276,20 @@ void before() {
   // setup the serial port baud rate
   Serial.begin(MY_BAUD_RATE);
 
-  /***********************************
- * Configure your sensors below
- */
+  /*
+  * Configure your sensors below
+  */
 
-  node.setReportIntervalSeconds(10);
-  //battery.setReportIntervalSeconds(10);
-  //node.setSleepSeconds(20);
+  //node.setReportIntervalMinutes(5);
+  //node.setSleepMinutes(5);
   
   //node.setPowerManager(power);
-  //battery.setReportIntervalSeconds(10);
+  //battery.setReportIntervalMinutes(30);
   //sht.children.get(1)->child_id = 5;
 
   
   /*
-   * Configure your sensors above
+  * Configure your sensors above
   */
   node.before();
 }
@@ -284,7 +313,7 @@ void loop() {
 }
 
 // receive
-void receive(const MyMessage &message) {
+void receive(MyMessage &message) {
   // call NodeManager receive routine
   node.receive(message);
 }
diff --git a/NodeManagerLibrary.h b/NodeManagerLibrary.h
index fe8f3dc..d75dea7 100644
--- a/NodeManagerLibrary.h
+++ b/NodeManagerLibrary.h
@@ -47,11 +47,6 @@
 /***********************************
    Default configuration settings
 */
-// if enabled, enable debug messages on serial port
-#ifndef DEBUG
-  #define DEBUG 1
-#endif
-
 // if enabled, allow modifying the configuration remotely by interacting with the configuration child id
 // the child id used to allow remote configuration
 #ifndef CONFIGURATION_CHILD_ID
@@ -88,67 +83,71 @@
 #include <MySensors.h>
 
 // include third party libraries
-#if MODULE_DHT == 1
+#ifdef MODULE_DHT
   #include <DHT.h>
 #endif
-#if MODULE_SHT21 == 1
+#ifdef MODULE_SHT21
   #include <Wire.h>
   #include <Sodaq_SHT2x.h>
 #endif
-#if MODULE_DS18B20 == 1
+#ifdef MODULE_DS18B20
   #include <OneWire.h>
   #include <DallasTemperature.h>
 #endif
-#if MODULE_BH1750 == 1
+#ifdef MODULE_BH1750
   #include <BH1750.h>
   #include <Wire.h>
 #endif
-#if MODULE_MLX90614 == 1
+#ifdef MODULE_MLX90614
   #include <Wire.h>
   #include <Adafruit_MLX90614.h>
 #endif
-#if MODULE_BME280 == 1
+#ifdef MODULE_BME280
   #include <Wire.h>
   #include <SPI.h>
   #include <Adafruit_Sensor.h>
   #include <Adafruit_BME280.h>
 #endif
-#if MODULE_SONOFF == 1
+#ifdef MODULE_SONOFF
   #include <Bounce2.h>
 #endif
-#if MODULE_BMP085 == 1
+#ifdef MODULE_BMP085
   #include <Wire.h>
   #include <Adafruit_BMP085.h>
 #endif
-#if MODULE_HCSR04 == 1
+#ifdef MODULE_HCSR04
   #include <NewPing.h>
 #endif
-#if MODULE_MCP9808 == 1
+#ifdef MODULE_MCP9808
   #include <Wire.h>
   #include "Adafruit_MCP9808.h"
 #endif
-#if MODULE_MHZ19 == 1
+#ifdef MODULE_MHZ19
   #include <SoftwareSerial.h>
 #endif
-#if MODULE_AM2320 == 1
+#ifdef MODULE_AM2320
   #include <Wire.h>
   #include <AM2320.h>
 #endif
-#if MODULE_TSL2561 == 1
+#ifdef MODULE_TSL2561
   #include <TSL2561.h>
   #include <Wire.h>
 #endif
-#if MODULE_PT100 == 1
+#ifdef MODULE_PT100
   #include <DFRobotHighTemperatureSensor.h>
 #endif
-#if MODULE_BMP280 == 1
+#ifdef MODULE_BMP280
   #include <Wire.h>
   #include <Adafruit_Sensor.h>
   #include <Adafruit_BMP280.h>
 #endif
-#if MODULE_DIMMER == 1
+#ifdef MODULE_DIMMER
   #include <math.h>
 #endif
+#ifdef MODULE_PMS
+  #include <PMS.h>
+  #include <SoftwareSerial.h> 
+#endif
 
 /*******************************************************************
    Classes
@@ -383,7 +382,7 @@ class ChildString: public Child {
 class Sensor {
   public:
     Sensor();
-    Sensor(const NodeManager& node_manager, int pin);
+    Sensor(NodeManager& node_manager, int pin);
     // return the name of the sensor
     char* getName();
     // [1] where the sensor is attached to (default: not set)
@@ -418,7 +417,7 @@ class Sensor {
     // listen for interrupts on the given pin so interrupt() will be called when occurring
     void setInterrupt(int pin, int mode, int initial);
     // set a previously configured PowerManager to the sensor so to powering it up with custom pins
-    void setPowerManager(const PowerManager& powerManager);
+    void setPowerManager(PowerManager& powerManager);
     // list of configured child
     List<Child*> children;
     // define what to do at each stage of the sketch
@@ -427,7 +426,7 @@ class Sensor {
     void setup();
     void loop(MyMessage* message);
     void interrupt();
-    void receive(const MyMessage & message);
+    void receive(MyMessage &message);
     // abstract functions, subclasses need to implement
     virtual void onBefore();
     virtual void onSetup();
@@ -439,7 +438,7 @@ class Sensor {
     void registerChild(Child* child);
     NodeManager* _node;
   protected:
-    const char* _name = "";
+    char* _name = "";
     int _pin = -1;
     int _samples = 1;
     int _samples_interval = 0;
@@ -454,7 +453,7 @@ class Sensor {
 */
 class SensorBattery: public Sensor {
   public:
-    SensorBattery(const NodeManager& nodeManager);
+    SensorBattery(NodeManager& nodeManager);
     // [102] the expected vcc when the batter is fully discharged, used to calculate the percentage (default: 2.7)
     void setMinVoltage(float value);
     // [103] the expected vcc when the batter is fully charged, used to calculate the percentage (default: 3.3)
@@ -470,7 +469,6 @@ class SensorBattery: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
       float _battery_min = 2.6;
       float _battery_max = 3.3;
@@ -484,7 +482,7 @@ class SensorBattery: public Sensor {
 */
 class SensorSignal: public Sensor {
   public:
-    SensorSignal(const NodeManager& nodeManager);
+    SensorSignal(NodeManager& nodeManager);
     // [101] define which signal report to send. Possible values are SR_UPLINK_QUALITY, SR_TX_POWER_LEVEL, SR_TX_POWER_PERCENT, SR_TX_RSSI, SR_RX_RSSI, SR_TX_SNR, SR_RX_SNR (default: SR_RX_RSSI)
     void setSignalCommand(int value);
     // define what to do at each stage of the sketch
@@ -492,7 +490,6 @@ class SensorSignal: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     int _signal_command = SR_RX_RSSI;
 };
@@ -502,23 +499,22 @@ class SensorSignal: public Sensor {
 */
 class SensorConfiguration: public Sensor {
   public:
-    SensorConfiguration(const NodeManager& nodeManager);
+    SensorConfiguration(NodeManager& nodeManager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
 };
 
-#if MODULE_ANALOG_INPUT == 1
+#ifdef MODULE_ANALOG_INPUT
 /*
    SensorAnalogInput: read the analog input of a configured pin
 */
 class SensorAnalogInput: public Sensor {
   public:
-    SensorAnalogInput(const NodeManager& node_manager, int pin);
+    SensorAnalogInput(NodeManager& node_manager, int pin);
     // [101] the analog reference to use (default: not set, can be either INTERNAL or DEFAULT)
     void setReference(int value);
     // [102] reverse the value or the percentage (e.g. 70% -> 30%) (default: false)
@@ -534,7 +530,6 @@ class SensorAnalogInput: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     int _reference = -1;
     bool _reverse = false;
@@ -550,7 +545,7 @@ class SensorAnalogInput: public Sensor {
 */
 class SensorLDR: public SensorAnalogInput {
   public:
-    SensorLDR(const NodeManager& node_manager, int pin);
+    SensorLDR(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -561,7 +556,7 @@ class SensorLDR: public SensorAnalogInput {
 */
 class SensorRain: public SensorAnalogInput {
   public:
-    SensorRain(const NodeManager& node_manager, int pin);
+    SensorRain(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -572,20 +567,20 @@ class SensorRain: public SensorAnalogInput {
 */
 class SensorSoilMoisture: public SensorAnalogInput {
   public:
-    SensorSoilMoisture(const NodeManager& node_manager, int pin);
+    SensorSoilMoisture(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
 };
 #endif
 
-#if MODULE_THERMISTOR == 1
+#ifdef MODULE_THERMISTOR
 /*
    SensorThermistor: read the temperature from a thermistor
 */
 class SensorThermistor: public Sensor {
   public:
-    SensorThermistor(const NodeManager& node_manager, int pin);
+    SensorThermistor(NodeManager& node_manager, int pin);
     // [101] resistance at 25 degrees C (default: 10000)
     void setNominalResistor(long value);
     // [102] temperature for nominal resistance (default: 25)
@@ -601,7 +596,6 @@ class SensorThermistor: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     long _nominal_resistor = 10000;
     int _nominal_temperature = 25;
@@ -611,33 +605,32 @@ class SensorThermistor: public Sensor {
 };
 #endif
 
-#if MODULE_ML8511 == 1
+#ifdef MODULE_ML8511
 /*
     SensorML8511
 */
 
 class SensorML8511: public Sensor {
   public:
-    SensorML8511(const NodeManager& node_Manager, int pin);
+    SensorML8511(NodeManager& node_Manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     float _mapfloat(float x, float in_min, float in_max, float out_min, float out_max);
 };
 #endif
 
-#if MODULE_ACS712 == 1
+#ifdef MODULE_ACS712
 /*
     SensorACS712
 */
 
 class SensorACS712: public Sensor {
   public:
-    SensorACS712(const NodeManager& node_manager, int pin);
+    SensorACS712(NodeManager& node_manager, int pin);
     // [101] set how many mV are equivalent to 1 Amp. The value depends on the module (100 for 20A Module, 66 for 30A Module) (default: 185);
     void setmVPerAmp(int value);
     // [102] set ACS offset (default: 2500);
@@ -647,36 +640,34 @@ class SensorACS712: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     int _ACS_offset = 2500;
     int _mv_per_amp = 185;
 };
 #endif
 
-#if MODULE_DIGITAL_INPUT == 1
+#ifdef MODULE_DIGITAL_INPUT
 /*
    SensorDigitalInput: read the digital input of the configured pin
 */
 class SensorDigitalInput: public Sensor {
   public:
-    SensorDigitalInput(const NodeManager& node_manager, int pin);
+    SensorDigitalInput(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
 };
 #endif
 
-#if MODULE_DIGITAL_OUTPUT == 1
+#ifdef MODULE_DIGITAL_OUTPUT
 /*
    SensorDigitalOutput: control a digital output of the configured pin
 */
 class SensorDigitalOutput: public Sensor {
   public:
-    SensorDigitalOutput(const NodeManager& node_manager, int pin);
+    SensorDigitalOutput(NodeManager& node_manager, int pin);
     // [103] define which value to set to the output when set to on (default: HIGH)
     void setOnValue(int value);
     // [104] when legacy mode is enabled expect a REQ message to trigger, otherwise the default SET (default: false)
@@ -696,7 +687,6 @@ class SensorDigitalOutput: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     int _on_value = HIGH;
     int _status = OFF;
@@ -714,7 +704,7 @@ class SensorDigitalOutput: public Sensor {
 */
 class SensorRelay: public SensorDigitalOutput {
   public:
-    SensorRelay(const NodeManager& node_manager, int pin);
+    SensorRelay(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
 };
@@ -724,7 +714,7 @@ class SensorRelay: public SensorDigitalOutput {
 */
 class SensorLatchingRelay: public SensorRelay {
   public:
-    SensorLatchingRelay(const NodeManager& node_manager, int pin);
+    SensorLatchingRelay(NodeManager& node_manager, int pin);
     // [201] set the duration of the pulse to send in ms to activate the relay (default: 50)
     void setPulseWidth(int value);
     // [202] set the pin which turns the relay off (default: the pin provided while registering the sensor)
@@ -745,16 +735,15 @@ class SensorLatchingRelay: public SensorRelay {
 /*
    SensorDHT
 */
-#if MODULE_DHT == 1
+#ifdef MODULE_DHT
 class SensorDHT: public Sensor {
   public:
-    SensorDHT(const NodeManager& node_manager, int pin);
+    SensorDHT(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     DHT* _dht;
     int _dht_type;
@@ -766,7 +755,7 @@ class SensorDHT: public Sensor {
 */
 class SensorDHT11: public SensorDHT {
   public:
-    SensorDHT11(const NodeManager& node_manager, int pin);
+    SensorDHT11(NodeManager& node_manager, int pin);
 };
 
 /*
@@ -774,23 +763,22 @@ class SensorDHT11: public SensorDHT {
 */
 class SensorDHT22: public SensorDHT {
   public:
-    SensorDHT22(const NodeManager& node_manager, int pin);
+    SensorDHT22(NodeManager& node_manager, int pin);
 };
 #endif
 
 /*
    SensorSHT21: temperature and humidity sensor
 */
-#if MODULE_SHT21 == 1
+#ifdef MODULE_SHT21
 class SensorSHT21: public Sensor {
   public:
-    SensorSHT21(const NodeManager& node_manager);
+    SensorSHT21(NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
 };
 
@@ -807,10 +795,10 @@ class SensorHTU21D: public SensorSHT21 {
 /*
  * SensorSwitch
  */
-#if MODULE_SWITCH == 1
+#ifdef MODULE_SWITCH
 class SensorSwitch: public Sensor {
   public:
-    SensorSwitch(const NodeManager& node_manager, int pin);
+    SensorSwitch(NodeManager& node_manager, int pin);
     // [101] set the interrupt mode. Can be CHANGE, RISING, FALLING (default: CHANGE)
     void setMode(int value);
     // [102] milliseconds to wait before reading the input (default: 0)
@@ -837,7 +825,7 @@ class SensorSwitch: public Sensor {
  */
 class SensorDoor: public SensorSwitch {
   public:
-    SensorDoor(const NodeManager& node_manager, int pin);
+    SensorDoor(NodeManager& node_manager, int pin);
     void onBefore();
 };
 
@@ -846,7 +834,7 @@ class SensorDoor: public SensorSwitch {
  */
 class SensorMotion: public SensorSwitch {
   public:
-    SensorMotion(const NodeManager& node_manager, int pin);
+    SensorMotion(NodeManager& node_manager, int pin);
     void onBefore();
     void onSetup();
 };
@@ -854,10 +842,10 @@ class SensorMotion: public SensorSwitch {
 /*
    SensorDs18b20
 */
-#if MODULE_DS18B20 == 1
+#ifdef MODULE_DS18B20
 class SensorDs18b20: public Sensor {
   public:
-    SensorDs18b20(const NodeManager& node_manager, int pin);
+    SensorDs18b20(NodeManager& node_manager, int pin);
     // returns the sensor's resolution in bits
     int getResolution();
     // [101] set the sensor's resolution in bits
@@ -869,7 +857,6 @@ class SensorDs18b20: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     bool _sleep_during_conversion = false;
     DallasTemperature* _sensors;
@@ -879,10 +866,10 @@ class SensorDs18b20: public Sensor {
 /*
    SensorBH1750
 */
-#if MODULE_BH1750 == 1
+#ifdef MODULE_BH1750
 class SensorBH1750: public Sensor {
   public:
-    SensorBH1750(const NodeManager& node_manager);
+    SensorBH1750(NodeManager& node_manager);
     // [101] set sensor reading mode, e.g. BH1750_ONE_TIME_HIGH_RES_MODE
     void setMode(uint8_t mode);
     // define what to do at each stage of the sketch
@@ -890,7 +877,6 @@ class SensorBH1750: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     BH1750* _lightSensor;
 };
@@ -899,19 +885,15 @@ class SensorBH1750: public Sensor {
 /*
    SensorMLX90614
 */
-#if MODULE_MLX90614 == 1
+#ifdef MODULE_MLX90614
 class SensorMLX90614: public Sensor {
   public:
-    SensorMLX90614(const NodeManager& node_manager);
+    SensorMLX90614(NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
-    // constants
-    const static int TEMPERATURE_AMBIENT = 0;
-    const static int TEMPERATURE_OBJECT = 1;
   protected:
     Adafruit_MLX90614* _mlx;
     int _sensor_type;
@@ -923,10 +905,10 @@ class SensorMLX90614: public Sensor {
  * SensorBosch
 */
 
-#if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
+#if defined(MODULE_BME280) || defined(MODULE_BMP085) || defined(MODULE_BMP280)
 class SensorBosch: public Sensor {
   public:
-    SensorBosch(const NodeManager& node_manager);
+    SensorBosch(NodeManager& node_manager);
     // [101] define how many pressure samples to keep track of for calculating the forecast (default: 5)
     void setForecastSamplesCount(int value);
     // define what to do at each stage of the sketch
@@ -934,7 +916,6 @@ class SensorBosch: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
     static uint8_t GetI2CAddress(uint8_t chip_id);
   protected:
     char* _weather[6] = { "stable", "sunny", "cloudy", "unstable", "thunderstorm", "unknown" };
@@ -953,10 +934,10 @@ class SensorBosch: public Sensor {
 /*
    SensorBME280
 */
-#if MODULE_BME280 == 1
+#ifdef MODULE_BME280
 class SensorBME280: public SensorBosch {
   public:
-    SensorBME280(const NodeManager& node_manager);
+    SensorBME280(NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -969,10 +950,10 @@ class SensorBME280: public SensorBosch {
 /*
    SensorBMP085
 */
-#if MODULE_BMP085 == 1
+#ifdef MODULE_BMP085
 class SensorBMP085: public SensorBosch {
   public:
-    SensorBMP085(const NodeManager& node_manager);
+    SensorBMP085(NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -985,10 +966,10 @@ class SensorBMP085: public SensorBosch {
 /*
    SensorBMP280
 */
-#if MODULE_BMP280 == 1
+#ifdef MODULE_BMP280
 class SensorBMP280: public SensorBosch {
   public:
-    SensorBMP280(const NodeManager& node_manager);
+    SensorBMP280(NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
@@ -1001,10 +982,10 @@ class SensorBMP280: public SensorBosch {
 /*
    SensorSonoff
 */
-#if MODULE_SONOFF == 1
+#ifdef MODULE_SONOFF
 class SensorSonoff: public Sensor {
   public:
-    SensorSonoff(const NodeManager& node_manager);
+    SensorSonoff(NodeManager& node_manager);
     // [101] set the button's pin (default: 0)
     void setButtonPin(int value);
     // [102] set the relay's pin (default: 12)
@@ -1016,7 +997,6 @@ class SensorSonoff: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     Bounce _debouncer = Bounce();
     int _button_pin = 0;
@@ -1036,10 +1016,10 @@ class SensorSonoff: public Sensor {
 /*
    SensorHCSR04
 */
-#if MODULE_HCSR04 == 1
+#ifdef MODULE_HCSR04
 class SensorHCSR04: public Sensor {
   public:
-    SensorHCSR04(const NodeManager& node_manager, int pin);
+    SensorHCSR04(NodeManager& node_manager, int pin);
     // [101] Arduino pin tied to trigger pin on the ultrasonic sensor (default: the pin set while registering the sensor)
     void setTriggerPin(int value);
     // [102] Arduino pin tied to echo pin on the ultrasonic sensor (default: the pin set while registering the sensor)
@@ -1052,7 +1032,6 @@ class SensorHCSR04: public Sensor {
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
     void onProcess(Request & request);
-    void onInterrupt();
   protected:
     int _trigger_pin;
     int _echo_pin;
@@ -1064,16 +1043,15 @@ class SensorHCSR04: public Sensor {
 /*
    SensorMCP9808
 */
-#if MODULE_MCP9808 == 1
+#ifdef MODULE_MCP9808
 class SensorMCP9808: public Sensor {
   public:
-    SensorMCP9808(const NodeManager& node_manager);
+    SensorMCP9808(NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     Adafruit_MCP9808* _mcp;
 };
@@ -1082,10 +1060,10 @@ class SensorMCP9808: public Sensor {
 /*
     SensorMQ
  */
- #if MODULE_MQ == 1
+ #ifdef MODULE_MQ
 class SensorMQ: public Sensor {
   public:
-    SensorMQ(const NodeManager& node_manager, int pin);
+    SensorMQ(NodeManager& node_manager, int pin);
     // [101] define the target gas whose ppm has to be returned. 0: LPG, 1: CO, 2: Smoke (default: 1);
     void setTargetGas(int value);
     // [102] define the load resistance on the board, in kilo ohms (default: 1);
@@ -1113,7 +1091,6 @@ class SensorMQ: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     float _rl_value = 1.0;
     float _ro_clean_air_factor = 9.83;
@@ -1143,16 +1120,15 @@ class SensorMQ: public Sensor {
 /*
    SensorMHZ19
 */
-#if MODULE_MHZ19 == 1
+#ifdef MODULE_MHZ19
 class SensorMHZ19: public Sensor {
   public:
-    SensorMHZ19(const NodeManager& node_manager, int pin);
+    SensorMHZ19(NodeManager& node_manager, int rxpin, int txpin);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     int _readCO2();
     SoftwareSerial* _ser;
@@ -1164,16 +1140,15 @@ class SensorMHZ19: public Sensor {
 /*
    SensorAM2320
 */
-#if MODULE_AM2320 == 1
+#ifdef MODULE_AM2320
 class SensorAM2320: public Sensor {
   public:
-    SensorAM2320(const NodeManager& node_manager);
+    SensorAM2320(NodeManager& node_manager);
     // define what to do at each stage of the sketch
     void onBefore();
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     AM2320* _th;
 };
@@ -1182,10 +1157,10 @@ class SensorAM2320: public Sensor {
 /*
    SensorTSL2561
 */
-#if MODULE_TSL2561 == 1
+#ifdef MODULE_TSL2561
 class SensorTSL2561: public Sensor {
   public:
-    SensorTSL2561(const NodeManager& node_manager);
+    SensorTSL2561(NodeManager& node_manager);
     // [101] set the gain, possible values are SensorTSL2561::GAIN_0X (0), SensorTSL2561::GAIN_16X (1) (default 16x)
     void setGain(int value);
     // [102] set the timing, possible values are SensorTSL2561::INTEGRATIONTIME_13MS (0), SensorTSL2561::INTEGRATIONTIME_101MS (1), SensorTSL2561::INTEGRATIONTIME_402MS (2) (default: 13ms)
@@ -1200,7 +1175,6 @@ class SensorTSL2561: public Sensor {
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
     void onProcess(Request & request);
-    void onInterrupt();
     // constants
     const static int ADDR_FLOAT = 0;
     const static int ADDR_LOW = 1;
@@ -1226,10 +1200,10 @@ class SensorTSL2561: public Sensor {
 /*
     SensorPT100
 */
-#if MODULE_PT100 == 1
+#ifdef MODULE_PT100
 class SensorPT100: public Sensor {
   public:
-    SensorPT100(const NodeManager& node_manager, int pin);
+    SensorPT100(NodeManager& node_manager, int pin);
     // [101] set the voltageRef used to compare with analog measures
     void setVoltageRef(float value);
     // define what to do at each stage of the sketch
@@ -1237,7 +1211,6 @@ class SensorPT100: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     DFRobotHighTemperature* _PT100;
     float _voltageRef = 3.3;
@@ -1247,10 +1220,10 @@ class SensorPT100: public Sensor {
 /*
     SensorPT100
 */
-#if MODULE_DIMMER == 1
+#ifdef MODULE_DIMMER
 class SensorDimmer: public Sensor {
   public:
-    SensorDimmer(const NodeManager& node_manager, int pin);
+    SensorDimmer(NodeManager& node_manager, int pin);
     // [101] set the effect to use for a smooth transition, can be one of SensorDimmer::EASE_LINEAR, SensorDimmer::EASE_INSINE, SensorDimmer::EASE_OUTSINE, SensorDimmer::EASE_INOUTSINE (default: EASE_LINEAR)
     void setEasing(int value);
     // [102] the duration of entire the transition in seconds (default: 1)
@@ -1262,7 +1235,6 @@ class SensorDimmer: public Sensor {
     void onSetup();
     void onLoop(Child* child);
     void onReceive(MyMessage* message);
-    void onInterrupt();
   protected:
     // fade the output from the current value to the target provided in the range 0-100
     void _fadeTo(Child* child, int value);
@@ -1283,10 +1255,10 @@ class SensorDimmer: public Sensor {
 /*
     SensorPulseMeter
 */
-#if MODULE_PULSE_METER == 1
+#ifdef MODULE_PULSE_METER
 class SensorPulseMeter: public Sensor {
   public:
-    SensorPulseMeter(const NodeManager& node_manager, int pin);
+    SensorPulseMeter(NodeManager& node_manager, int pin);
     // [102] set how many pulses for each unit (e.g. 1000 pulses for 1 kwh of power, 9 pulses for 1 mm of rain, etc.)
     void setPulseFactor(float value);
     // set initial value - internal pull up (default: HIGH)
@@ -1313,7 +1285,7 @@ class SensorPulseMeter: public Sensor {
 */
 class SensorRainGauge: public SensorPulseMeter {
   public:
-    SensorRainGauge(const NodeManager& node_manager, int pin);
+    SensorRainGauge(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
 };
@@ -1323,7 +1295,7 @@ class SensorRainGauge: public SensorPulseMeter {
 */
 class SensorPowerMeter: public SensorPulseMeter {
   public:
-    SensorPowerMeter(const NodeManager& node_manager, int pin);
+    SensorPowerMeter(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
   protected:
@@ -1335,7 +1307,7 @@ class SensorPowerMeter: public SensorPulseMeter {
 */
 class SensorWaterMeter: public SensorPulseMeter {
   public:
-    SensorWaterMeter(const NodeManager& node_manager, int pin);
+    SensorWaterMeter(NodeManager& node_manager, int pin);
     // define what to do at each stage of the sketch
     void onBefore();
   protected:
@@ -1343,6 +1315,31 @@ class SensorWaterMeter: public SensorPulseMeter {
 };
 #endif
 
+/*
+   SensorPlantowerPMS
+*/
+#ifdef MODULE_PMS
+class SensorPlantowerPMS: public Sensor {
+  public:
+    SensorPlantowerPMS(NodeManager& node_manager, int rxpin, int txpin);
+    // define what to do at each stage of the sketch
+    void onBefore();
+    void onSetup();
+    void loop(MyMessage* message);
+    void onLoop(Child* child);
+    void onReceive(MyMessage* message);
+  protected:
+    int _readSensorValues();
+    SoftwareSerial* _ser;
+    int _tx_pin = 4;
+    int _rx_pin = 3;
+    PMS *_pms;
+    PMS::DATA _data;
+    bool _valuesRead = false;
+    bool _valuesReadError = false;
+};
+#endif
+
 /***************************************
    NodeManager: manages all the aspects of the node
 */
@@ -1433,7 +1430,7 @@ class NodeManager {
     void presentation();
     void setup();
     void loop();
-    void receive(const MyMessage & msg);
+    void receive(MyMessage & msg);
     void receiveTime(unsigned long ts);
     // handle interrupts
     static void _onInterrupt_1();
@@ -1443,7 +1440,7 @@ class NodeManager {
     void sendMessage(int child_id, int type, float value);
     void sendMessage(int child_id, int type, double value);
     void sendMessage(int child_id, int type, const char* value);
-    void setPowerManager(const PowerManager& powerManager);
+    void setPowerManager(PowerManager& powerManager);
     int getAvailableChildId();
     List<Sensor*> sensors;
     Child* getChild(int child_id);
diff --git a/NodeManagerLibrary.ino b/NodeManagerLibrary.ino
index db4a865..e642b49 100644
--- a/NodeManagerLibrary.ino
+++ b/NodeManagerLibrary.ino
@@ -14,7 +14,7 @@ PowerManager::PowerManager(int ground_pin, int vcc_pin, int wait_time) {
 void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
   _ground_pin = ground_pin;
   _vcc_pin = vcc_pin;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("PWR G="));
     Serial.print(_ground_pin);
     Serial.print(F(" V="));
@@ -37,7 +37,7 @@ void PowerManager::setPowerPins(int ground_pin, int vcc_pin, int wait_time) {
 // turn on the sensor by activating its power pins
 void PowerManager::powerOn() {
   if (_vcc_pin == -1) return;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("ON P="));
     Serial.println(_vcc_pin);
   #endif
@@ -50,7 +50,7 @@ void PowerManager::powerOn() {
 // turn off the sensor
 void PowerManager::powerOff() {
   if (_vcc_pin == -1) return;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("OFF P="));
     Serial.println(_vcc_pin);
   #endif
@@ -169,12 +169,12 @@ Request::Request(int recipient_child_id, const char* string) {
   _recipient_child_id = recipient_child_id;
   char* ptr;
   // tokenize the string and get child id
-  _child_id = atoi(strtok_r(string, ",", &ptr));
+  _child_id = atoi(strtok_r(const_cast<char*>(string), ",", &ptr));
   // tokenize the string and get function id
   _function = atoi(strtok_r(NULL, ",", &ptr));
   // tokenize the string and get the value
   _value = atof(strtok_r(NULL, ",", &ptr));
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("REQ C="));
     Serial.print(_child_id);
     Serial.print(F(" F="));
@@ -378,7 +378,7 @@ bool ChildString::isNewValue() {
 // constructor
 Sensor::Sensor() {  
 }
-Sensor::Sensor(const NodeManager& node_manager, int pin = -1) {
+Sensor::Sensor(NodeManager& node_manager, int pin = -1) {
   _node = &node_manager;
   _pin = pin;
   _report_timer = new Timer(_node);
@@ -469,7 +469,7 @@ void Sensor::registerChild(Child* child) {
 void Sensor::presentation() {
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(F("PRES I="));
       Serial.print(child->child_id);
       Serial.print(F(" T="));
@@ -485,7 +485,7 @@ void Sensor::before() {
   onBefore();
   for (List<Child*>::iterator itr = children.begin(); itr != children.end(); ++itr) {
     Child* child = *itr;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -554,7 +554,7 @@ void Sensor::interrupt() {
 }
 
 // receive a message from the radio network
-void Sensor::receive(const MyMessage &message) {
+void Sensor::receive(MyMessage &message) {
   // a request would make the sensor executing its main task passing along the message
   loop(&message);
 }
@@ -568,7 +568,7 @@ Child* Sensor::getChild(int child_id) {
   return nullptr;
 }
 
-void Sensor::setPowerManager(const PowerManager& powerManager) {
+void Sensor::setPowerManager(PowerManager& powerManager) {
   _powerManager = &powerManager;
 }
 
@@ -583,9 +583,10 @@ void Sensor::onInterrupt(){}
 /*
    SensorBattery
 */
+#ifndef MY_GATEWAY_ESP8266
 // contructor
-SensorBattery::SensorBattery(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "BAT";
+SensorBattery::SensorBattery(NodeManager& node_manager): Sensor(node_manager) {
+  _name = "BATTERY";
   // report battery level every 60 minutes by default
   setReportIntervalMinutes(60);
 }
@@ -613,7 +614,12 @@ void SensorBattery::onBefore() {
 // what to do during setup
 void SensorBattery::onSetup() {
   // when measuring the battery from a pin, analog reference must be internal
-  if (! _battery_internal_vcc && _battery_pin > -1) analogReference(INTERNAL);
+  if (! _battery_internal_vcc && _battery_pin > -1)
+    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+      analogReference(INTERNAL1V1);
+    #else
+      analogReference(INTERNAL);
+    #endif
 }
 
 // what to do during loop
@@ -626,7 +632,7 @@ void SensorBattery::onLoop(Child* child) {
   int percentage = ((volt - _battery_min) / (_battery_max - _battery_min)) * 100;
   if (percentage > 100) percentage = 100;
   if (percentage < 0) percentage = 0;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" V="));
     Serial.print(volt);
@@ -644,17 +650,15 @@ void SensorBattery::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorBattery::onInterrupt() {
-}
+#endif
 
 /*
    SensorSignal
 */
+#ifndef MY_GATEWAY_ESP8266
 // contructor
-SensorSignal::SensorSignal(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "SIG";
+SensorSignal::SensorSignal(NodeManager& node_manager): Sensor(node_manager) {
+  _name = "SIGNAL";
   // report signal level every 60 minutes by default
   setReportIntervalMinutes(60);
 }
@@ -675,8 +679,8 @@ void SensorSignal::onSetup() {
 
 // what to do during loop
 void SensorSignal::onLoop(Child* child) {
-  int16_t value = transportGetSignalReport(_signal_command);
-  #if DEBUG == 1
+  int16_t value = transportGetSignalReport((signalReport_t)_signal_command);
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" V="));
     Serial.println(value);
@@ -690,515 +694,230 @@ void SensorSignal::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
+#endif
 
-// what to do when receiving an interrupt
-void SensorSignal::onInterrupt() {
+#ifdef MODULE_ANALOG_INPUT
+/*
+   SensorAnalogInput
+*/
+
+// contructor
+SensorAnalogInput::SensorAnalogInput(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "ANALOG_I";
+}
+
+// setter/getter
+void SensorAnalogInput::setReference(int value) {
+  _reference = value;
+}
+void SensorAnalogInput::setReverse(bool value) {
+  _reverse = value;
+}
+void SensorAnalogInput::setOutputPercentage(bool value) {
+  _output_percentage = value;
+}
+void SensorAnalogInput::setRangeMin(int value) {
+  _range_min = value;
+}
+void SensorAnalogInput::setRangeMax(int value) {
+  _range_max = value;
+}
+
+// what to do during before
+void SensorAnalogInput::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorAnalogInput::onSetup() {
+  // prepare the pin for input
+  pinMode(_pin, INPUT);
+}
+
+// what to do during loop
+void SensorAnalogInput::onLoop(Child* child) {
+  // read the input
+  int adc = _getAnalogRead();
+  // calculate the percentage
+  int percentage = 0;
+  if (_output_percentage) percentage = _getPercentage(adc);
+  #ifdef NODEMANAGER_DEBUG
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.print(adc);
+    Serial.print(F(" %="));
+    Serial.println(percentage);
+  #endif
+  // store the result
+  ((ChildInt*)child)->setValueInt(_output_percentage ? percentage : adc);
+}
+
+// what to do during loop
+void SensorAnalogInput::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+
+// read the analog input
+int SensorAnalogInput::_getAnalogRead() {
+  #ifndef MY_GATEWAY_ESP8266
+    // set the reference
+    if (_reference != -1) {
+      analogReference(_reference);
+      wait(100);
+    }
+  #endif
+  // read and return the value
+  int value = analogRead(_pin);
+  if (_reverse) value = _range_max - value;
+  return value;
+}
+
+// return a percentage from an analog value
+int SensorAnalogInput::_getPercentage(int adc) {
+  float value = (float)adc;
+  // restore the original value
+  if (_reverse) value = _range_max - value;
+  // scale the percentage based on the range provided
+  float percentage = ((value - _range_min) / (_range_max - _range_min)) * 100;
+  if (_reverse) percentage = 100 - percentage;
+  if (percentage > 100) percentage = 100;
+  if (percentage < 0) percentage = 0;
+  return (int)percentage;
 }
 
 /*
-   SensorConfiguration
+   SensorLDR
 */
+
 // contructor
-SensorConfiguration::SensorConfiguration(const NodeManager& node_manager): Sensor(node_manager) {
-  _name = "CONF";
+SensorLDR::SensorLDR(NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "LDR";
 }
 
 // what to do during before
-void SensorConfiguration::onBefore() {
-  new ChildInt(this,CONFIGURATION_CHILD_ID,S_CUSTOM,V_CUSTOM);
+void SensorLDR::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
 }
 
 // what to do during setup
-void SensorConfiguration::onSetup() {
+void SensorLDR::onSetup() {
+  setReverse(true);
+}
+
+/*
+   SensorRain
+*/
+
+// contructor
+SensorRain::SensorRain(NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "RAIN";
+}
+
+// what to do during before
+void SensorRain::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_RAIN,V_RAINRATE);
+}
+
+// what to do during setup
+void SensorRain::onSetup() {
+  setReference(DEFAULT);
+  setOutputPercentage(true);
+  setReverse(true);
+  setRangeMin(100);
+}
+
+/*
+   SensorSoilMoisture
+*/
+
+// contructor
+SensorSoilMoisture::SensorSoilMoisture(NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
+  _name = "SOIL";
+}
+
+// what to do during before
+void SensorSoilMoisture::onBefore() {
+  new ChildInt(this,_node->getAvailableChildId(),S_MOISTURE,V_LEVEL);
+}
+
+// what to do during setup
+void SensorSoilMoisture::onSetup() {
+  setReverse(true);
+  setReference(DEFAULT);
+  setOutputPercentage(true);
+  setReverse(true);
+  setRangeMin(100);
+}
+#endif
+
+#ifdef MODULE_THERMISTOR
+/*
+   SensorThermistor
+*/
+
+// contructor
+SensorThermistor::SensorThermistor(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "THERMISTOR";
+}
+
+// setter/getter
+void SensorThermistor::setNominalResistor(long value) {
+  _nominal_resistor = value;
+}
+void SensorThermistor::setNominalTemperature(int value) {
+  _nominal_temperature = value;
+}
+void SensorThermistor::setBCoefficient(int value) {
+  _b_coefficient = value;
+}
+void SensorThermistor::setSeriesResistor(long value) {
+  _series_resistor = value;
+}
+void SensorThermistor::setOffset(float value) {
+  _offset = value;
+}
+
+// what to do during before
+void SensorThermistor::onBefore() {
+  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
+}
 
+// what to do during setup
+void SensorThermistor::onSetup() {
+  // set the pin as input
+  pinMode(_pin, INPUT);
 }
 
 // what to do during loop
-void SensorConfiguration::onLoop(Child* child) {
-}
-
-// what to do as the main task when receiving a message
-void SensorConfiguration::onReceive(MyMessage* message) {
-  // expect a REQ, V_CUSTOM message
-  if (message->getCommand() != C_REQ && message->type != V_CUSTOM) return;
-  // parse the request
-  Request request = Request(message->sensor,message->getString());
-  int function = request.getFunction();
-  int child_id = request.getChildId();
-  // if the message is for the board itself
-  if (child_id == 0) {
-    switch(function) {
-      case 1: _node->hello(); break;
-      case 3: _node->setSleepSeconds(request.getValueInt()); break;
-      case 4: _node->setSleepMinutes(request.getValueInt()); break;
-      case 5: _node->setSleepHours(request.getValueInt()); break;
-      case 29: _node->setSleepDays(request.getValueInt()); break;
-      #ifndef MY_GATEWAY_ESP8266
-        case 6: _node->reboot(); return;
-      #endif
-      case 7: _node->clearEeprom(); break;
-      case 8: _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,VERSION); return;
-      case 9: _node->wakeup(); break;
-      case 10: _node->setRetries(request.getValueInt()); break;
-      case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
-      case 20: _node->setSleepBetweenSend(request.getValueInt()); break;
-      case 21: _node->setAck(request.getValueInt()); break;
-      case 22: _node->setIsMetric(request.getValueInt()); break;
-      case 24: _node->powerOn(); break;
-      case 25: _node->powerOff(); break;
-      case 27: _node->saveToMemory(0,request.getValueInt()); break;
-      case 28: _node->setInterruptMinDelta(request.getValueInt()); break;
-      case 30: _node->setSleepOrWait(request.getValueInt()); break;
-      case 31: _node->setRebootPin(request.getValueInt()); break;
-      case 32: _node->setADCOff(); break;
-      case 36: _node->setReportIntervalSeconds(request.getValueInt()); break;
-      case 37: _node->setReportIntervalMinutes(request.getValueInt()); break;
-      case 38: _node->setReportIntervalHours(request.getValueInt()); break;
-      case 39: _node->setReportIntervalDays(request.getValueInt()); break;
-      default: return; 
-    }
-  // the request is for a sensor
-  } else {
-    // retrieve the sensor the child is belonging to
-    Sensor* sensor = _node->getSensorWithChild(child_id);
-    if (sensor == nullptr) return;
-    // if the message is for a function common to all the sensors
-    if (request.getFunction() < 100) {
-      switch(function) {
-        case 1: sensor->setPin(request.getValueInt()); break;
-        case 5: sensor->setSamples(request.getValueInt()); break;
-        case 6: sensor->setSamplesInterval(request.getValueInt()); break;
-        case 7: sensor->setTrackLastValue(request.getValueInt()); break;
-        case 9: sensor->setForceUpdateMinutes(request.getValueInt()); break;
-        case 13: sensor->powerOn(); break;
-        case 14: sensor->powerOff(); break;
-        case 16: sensor->setReportIntervalMinutes(request.getValueInt()); break;
-        case 17: sensor->setReportIntervalSeconds(request.getValueInt()); break;
-        case 19: sensor->setReportIntervalHours(request.getValueInt()); break;
-        case 20: sensor->setReportIntervalDays(request.getValueInt()); break;
-        default: return;
-      }
-    } else {
-      // the message is for a function specific to a sensor
-      if (strcmp(sensor->getName(),"BAT") == 0) {
-        SensorBattery* custom_sensor = (SensorBattery*)sensor;
-        switch(function) {
-          case 102: custom_sensor->setMinVoltage(request.getValueFloat()); break;
-          case 103: custom_sensor->setMaxVoltage(request.getValueFloat()); break;
-          case 104: custom_sensor->setBatteryInternalVcc(request.getValueInt()); break;
-          case 105: custom_sensor->setBatteryPin(request.getValueInt()); break;
-          case 106: custom_sensor->setBatteryVoltsPerBit(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      if (strcmp(sensor->getName(),"SIG") == 0) {
-        SensorSignal* custom_sensor = (SensorSignal*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setSignalCommand(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #if MODULE_SHT21 == 1
-      if (strcmp(sensor->getName(),"SHT21") == 0 || strcmp(sensor->getName(),"HTU21") == 0) {
-        SensorSHT21* custom_sensor = (SensorSHT21*)sensor;
-        switch(function) {
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_ANALOG_INPUT == 1
-      if (strcmp(sensor->getName(),"A-IN") == 0 || strcmp(sensor->getName(),"LDR") == 0 || strcmp(sensor->getName(),"RAIN") == 0 || strcmp(sensor->getName(),"SOIL") == 0) {
-        SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setReference(request.getValueInt()); break;
-          case 102: custom_sensor->setReverse(request.getValueInt()); break;
-          case 103: custom_sensor->setOutputPercentage(request.getValueInt()); break;
-          case 104: custom_sensor->setRangeMin(request.getValueInt()); break;
-          case 105: custom_sensor->setRangeMax(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_THERMISTOR == 1
-      if (strcmp(sensor->getName(),"THER") == 0) {
-        SensorThermistor* custom_sensor = (SensorThermistor*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setNominalResistor((long)request.getValueInt()); break;
-          case 102: custom_sensor->setNominalTemperature(request.getValueInt()); break;
-          case 103: custom_sensor->setBCoefficient(request.getValueInt()); break;
-          case 104: custom_sensor->setSeriesResistor((long)request.getValueInt()); break;
-          case 105: custom_sensor->setOffset(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_ACS712 == 1
-      if (strcmp(sensor->getName(),"ACS") == 0) {
-        SensorACS712* custom_sensor = (SensorACS712*)sensor;
-        switch(function) {
-          case 100: custom_sensor->setmVPerAmp(request.getValueInt()); break;
-          case 102: custom_sensor->setOffset(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_DIGITAL_OUTPUT == 1
-      if (strcmp(sensor->getName(),"DOUT") == 0 || strcmp(sensor->getName(),"REL") == 0 || strcmp(sensor->getName(),"LATC") == 0) {
-        SensorDigitalOutput* custom_sensor = (SensorDigitalOutput*)sensor;
-        switch(function) {
-            case 103: custom_sensor->setOnValue(request.getValueInt()); break;
-            case 104: custom_sensor->setLegacyMode(request.getValueInt()); break;
-            case 105: custom_sensor->setSafeguard(request.getValueInt()); break;
-            case 106: custom_sensor->setInputIsElapsed(request.getValueInt()); break;
-            case 107: custom_sensor->setWaitAfterSet(request.getValueInt()); break;
-          default: return;
-        }
-        if (function > 200 && strcmp(sensor->getName(),"LATC") == 0) {
-          SensorLatchingRelay* custom_sensor_2 = (SensorLatchingRelay*)sensor;
-          switch(function) {
-            case 201: custom_sensor_2->setPulseWidth(request.getValueInt()); break;
-            case 202: custom_sensor_2->setPinOff(request.getValueInt()); break;
-            case 203: custom_sensor_2->setPinOn(request.getValueInt()); break;
-          default: return;
-        }
-        }
-      }
-      #endif
-      #if MODULE_SWITCH == 1
-      if (strcmp(sensor->getName(),"SWITCH") == 0 || strcmp(sensor->getName(),"DOOR") == 0 || strcmp(sensor->getName(),"MOTION") == 0) {
-        SensorSwitch* custom_sensor = (SensorSwitch*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setMode(request.getValueInt()); break;
-          case 102: custom_sensor->setDebounce(request.getValueInt()); break;
-          case 103: custom_sensor->setTriggerTime(request.getValueInt()); break;
-          case 104: custom_sensor->setInitial(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_DS18B20 == 1
-      if (strcmp(sensor->getName(),"DS18B20") == 0) {
-        SensorDs18b20* custom_sensor = (SensorDs18b20*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setResolution(request.getValueInt()); break;
-          case 102: custom_sensor->setSleepDuringConversion(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_BH1750 == 1
-      if (strcmp(sensor->getName(),"BH1750") == 0) {
-        SensorBH1750* custom_sensor = (SensorBH1750*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setMode(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
-      if (strcmp(sensor->getName(),"BME280") == 0) {
-        SensorBosch* custom_sensor = (SensorBosch*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setForecastSamplesCount(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_SONOFF == 1
-      if (strcmp(sensor->getName(),"SONOFF") == 0) {
-        SensorSonoff* custom_sensor = (SensorSonoff*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setButtonPin(request.getValueInt()); break;
-          case 102: custom_sensor->setRelayPin(request.getValueInt()); break;
-          case 103: custom_sensor->setLedPin(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_HCSR04 == 1
-      if (strcmp(sensor->getName(),"HCSR04") == 0) {
-        SensorHCSR04* custom_sensor = (SensorHCSR04*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setTriggerPin(request.getValueInt()); break;
-          case 102: custom_sensor->setEchoPin(request.getValueInt()); break;
-          case 103: custom_sensor->setMaxDistance(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_MQ == 1
-      if (strcmp(sensor->getName(),"MQ") == 0) {
-        SensorMQ* custom_sensor = (SensorMQ*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setTargetGas(request.getValueInt()); break;
-          case 102: custom_sensor->setRlValue(request.getValueFloat()); break;
-          case 103: custom_sensor->setRoValue(request.getValueFloat()); break;
-          case 104: custom_sensor->setCleanAirFactor(request.getValueFloat()); break;
-          case 105: custom_sensor->setCalibrationSampleTimes(request.getValueInt()); break;
-          case 106: custom_sensor->setCalibrationSampleInterval(request.getValueInt()); break;
-          case 107: custom_sensor->setReadSampleTimes(request.getValueInt()); break;
-          case 108: custom_sensor->setReadSampleInterval(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_TSL2561 == 1
-      if (strcmp(sensor->getName(),"TSL2561") == 0) {
-        SensorTSL2561* custom_sensor = (SensorTSL2561*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setGain(request.getValueInt()); break;
-          case 102: custom_sensor->setTiming(request.getValueInt()); break;
-          case 103: custom_sensor->setSpectrum(request.getValueInt()); break;
-          case 104: custom_sensor->setAddress(request.getValueInt()); break;
-          default: return;
-        }
-      }
-      #endif
-      #if MODULE_PT100 == 1
-      if (strcmp(sensor->getName(),"PT100") == 0) {
-        SensorPT100* custom_sensor = (SensorPT100*)sensor;
-        switch(function) {
-          case 101: custom_sensor->setVoltageRef(request.getValueFloat()); break;
-          default: return;
-        }
-      }
-      #endif
-    }
-  }
-  _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
-}
-
-// what to do when receiving an interrupt
-void SensorConfiguration::onInterrupt() {
-}
-
-
-#if MODULE_ANALOG_INPUT == 1
-/*
-   SensorAnalogInput
-*/
-
-// contructor
-SensorAnalogInput::SensorAnalogInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "A-IN";
-}
-
-// setter/getter
-void SensorAnalogInput::setReference(int value) {
-  _reference = value;
-}
-void SensorAnalogInput::setReverse(bool value) {
-  _reverse = value;
-}
-void SensorAnalogInput::setOutputPercentage(bool value) {
-  _output_percentage = value;
-}
-void SensorAnalogInput::setRangeMin(int value) {
-  _range_min = value;
-}
-void SensorAnalogInput::setRangeMax(int value) {
-  _range_max = value;
-}
-
-// what to do during before
-void SensorAnalogInput::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_CUSTOM,V_CUSTOM);
-}
-
-// what to do during setup
-void SensorAnalogInput::onSetup() {
-  // prepare the pin for input
-  pinMode(_pin, INPUT);
-}
-
-// what to do during loop
-void SensorAnalogInput::onLoop(Child* child) {
-  // read the input
-  int adc = _getAnalogRead();
-  // calculate the percentage
-  int percentage = 0;
-  if (_output_percentage) percentage = _getPercentage(adc);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.print(adc);
-    Serial.print(F(" %="));
-    Serial.println(percentage);
-  #endif
-  // store the result
-  ((ChildInt*)child)->setValueInt(_output_percentage ? percentage : adc);
-}
-
-// what to do during loop
-void SensorAnalogInput::onReceive(MyMessage* message) {
-  Child* child = getChild(message->sensor);
-  if (child == nullptr) return;
-  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
-}
-
-// what to do when receiving an interrupt
-void SensorAnalogInput::onInterrupt() {
-}
-
-// read the analog input
-int SensorAnalogInput::_getAnalogRead() {
-  #ifndef MY_GATEWAY_ESP8266
-    // set the reference
-    if (_reference != -1) {
-      analogReference(_reference);
-      wait(100);
-    }
-  #endif
-  // read and return the value
-  int value = analogRead(_pin);
-  if (_reverse) value = _range_max - value;
-  return value;
-}
-
-// return a percentage from an analog value
-int SensorAnalogInput::_getPercentage(int adc) {
-  float value = (float)adc;
-  // restore the original value
-  if (_reverse) value = 1024 - value;
-  // scale the percentage based on the range provided
-  float percentage = ((value - _range_min) / (_range_max - _range_min)) * 100;
-  if (_reverse) percentage = 100 - percentage;
-  if (percentage > 100) percentage = 100;
-  if (percentage < 0) percentage = 0;
-  return (int)percentage;
-}
-
-/*
-   SensorLDR
-*/
-
-// contructor
-SensorLDR::SensorLDR(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "LDR";
-}
-
-// what to do during before
-void SensorLDR::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_LIGHT_LEVEL,V_LIGHT_LEVEL);
-}
-
-// what to do during setup
-void SensorLDR::onSetup() {
-  setReverse(true);
-}
-
-/*
-   SensorRain
-*/
-
-// contructor
-SensorRain::SensorRain(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "RAIN";
-}
-
-// what to do during before
-void SensorRain::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_RAIN,V_RAINRATE);
-}
-
-// what to do during setup
-void SensorRain::onSetup() {
-  setReference(DEFAULT);
-  setOutputPercentage(true);
-  setReverse(true);
-  setRangeMin(100);
-}
-
-/*
-   SensorSoilMoisture
-*/
-
-// contructor
-SensorSoilMoisture::SensorSoilMoisture(const NodeManager& node_manager, int pin): SensorAnalogInput(node_manager, pin) {
-  _name = "SOIL";
-}
-
-// what to do during before
-void SensorSoilMoisture::onBefore() {
-  new ChildInt(this,_node->getAvailableChildId(),S_MOISTURE,V_LEVEL);
-}
-
-// what to do during setup
-void SensorSoilMoisture::onSetup() {
-  setReverse(true);
-  setReference(DEFAULT);
-  setOutputPercentage(true);
-  setReverse(true);
-  setRangeMin(100);
-}
-#endif
-
-#if MODULE_THERMISTOR == 1
-/*
-   SensorThermistor
-*/
-
-// contructor
-SensorThermistor::SensorThermistor(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "THER";
-}
-
-// setter/getter
-void SensorThermistor::setNominalResistor(long value) {
-  _nominal_resistor = value;
-}
-void SensorThermistor::setNominalTemperature(int value) {
-  _nominal_temperature = value;
-}
-void SensorThermistor::setBCoefficient(int value) {
-  _b_coefficient = value;
-}
-void SensorThermistor::setSeriesResistor(long value) {
-  _series_resistor = value;
-}
-void SensorThermistor::setOffset(float value) {
-  _offset = value;
-}
-
-// what to do during before
-void SensorThermistor::onBefore() {
-  new ChildFloat(this,_node->getAvailableChildId(),S_TEMP,V_TEMP);
-}
-
-// what to do during setup
-void SensorThermistor::onSetup() {
-  // set the pin as input
-  pinMode(_pin, INPUT);
-}
-
-// what to do during loop
-void SensorThermistor::onLoop(Child* child) {
-  // read the voltage across the thermistor
-  float adc = analogRead(_pin);
-  // calculate the temperature
-  float reading = (1023 / adc)  - 1;
-  reading = _series_resistor / reading;
-  float temperature;
-  temperature = reading / _nominal_resistor;     // (R/Ro)
-  temperature = log(temperature);                  // ln(R/Ro)
-  temperature /= _b_coefficient;                   // 1/B * ln(R/Ro)
-  temperature += 1.0 / (_nominal_temperature + 273.15); // + (1/To)
-  temperature = 1.0 / temperature;                 // Invert
-  temperature -= 273.15;                         // convert to C
-  temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.print(F(" I="));
-    Serial.print(child->child_id);
-    Serial.print(F(" V="));
-    Serial.print(adc);
-    Serial.print(F(" T="));
-    Serial.println(temperature);
-  #endif
-  // store the value
-  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
+void SensorThermistor::onLoop(Child* child) {
+  // read the voltage across the thermistor
+  float adc = analogRead(_pin);
+  // calculate the temperature
+  float reading = (1023 / adc)  - 1;
+  reading = _series_resistor / reading;
+  float temperature;
+  temperature = reading / _nominal_resistor;     // (R/Ro)
+  temperature = log(temperature);                  // ln(R/Ro)
+  temperature /= _b_coefficient;                   // 1/B * ln(R/Ro)
+  temperature += 1.0 / (_nominal_temperature + 273.15); // + (1/To)
+  temperature = 1.0 / temperature;                 // Invert
+  temperature -= 273.15;                         // convert to C
+  temperature = _node->celsiusToFahrenheit(temperature);
+  #ifdef NODEMANAGER_DEBUG
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" V="));
+    Serial.print(adc);
+    Serial.print(F(" T="));
+    Serial.println(temperature);
+  #endif
+  // store the value
+  if (! isnan(temperature)) ((ChildFloat*)child)->setValueFloat(temperature);
 }
 
 // what to do as the main task when receiving a message
@@ -1207,20 +926,16 @@ void SensorThermistor::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorThermistor::onInterrupt() {
-}
 #endif
 
-#if MODULE_ML8511 == 1
+#ifdef MODULE_ML8511
 /*
    SensorML8511
 */
 
 // contructor
-SensorML8511::SensorML8511(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "UV";
+SensorML8511::SensorML8511(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "ML8511";
 }
 
 // what to do during before
@@ -1243,7 +958,7 @@ void SensorML8511::onLoop(Child* child) {
   float outputVoltage = 3.3 / refLevel * uvLevel;
   //Convert the voltage to a UV intensity level
   float uvIntensity = _mapfloat(outputVoltage, 0.99, 2.8, 0.0, 15.0); 
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -1263,24 +978,20 @@ void SensorML8511::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorML8511::onInterrupt() {
-}
-
 // The Arduino Map function but for floats
 float SensorML8511::_mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
   return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 }
 #endif
 
-#if MODULE_ACS712 == 1
+#ifdef MODULE_ACS712
 /*
    SensorACS712
 */
 
 // contructor
-SensorACS712::SensorACS712(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "ACS";
+SensorACS712::SensorACS712(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "ACS712";
 }
 
 // setter/getter
@@ -1309,7 +1020,7 @@ void SensorACS712::onLoop(Child* child) {
   double voltage = (value / 1024.0) * 5000; 
   // convert voltage in amps
   float value_float = ((voltage - _ACS_offset) / _mv_per_amp);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -1326,19 +1037,16 @@ void SensorACS712::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorACS712::onInterrupt() {
-}
 #endif
 
-#if MODULE_DIGITAL_INPUT == 1
+#ifdef MODULE_DIGITAL_INPUT
 /*
    SensorDigitalInput
 */
 
 // contructor
-SensorDigitalInput::SensorDigitalInput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "D-IN";
+SensorDigitalInput::SensorDigitalInput(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DIGITAL_I";
 }
 
 // what to do during before
@@ -1357,7 +1065,7 @@ void SensorDigitalInput::onSetup() {
 void SensorDigitalInput::onLoop(Child* child) {
   // read the value
   int value = digitalRead(_pin);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -1376,20 +1084,16 @@ void SensorDigitalInput::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorDigitalInput::onInterrupt() {
-}
 #endif
 
 
-#if MODULE_DIGITAL_OUTPUT == 1
+#ifdef MODULE_DIGITAL_OUTPUT
 /*
    SensorDigitalOutput
 */
 
-SensorDigitalOutput::SensorDigitalOutput(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
-  _name = "DOUT";
+SensorDigitalOutput::SensorDigitalOutput(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+  _name = "DIGITAL_O";
 }
 
 // what to do during before
@@ -1430,7 +1134,7 @@ void SensorDigitalOutput::onLoop(Child* child) {
     // update the timer
     _safeguard_timer->update();
     // if the time is over, turn the output off
-    if (_safeguard_timer->isOver()) setStatus(child->child_id,OFF);
+    if (_safeguard_timer->isOver()) setStatus(child,OFF);
   }
 }
 
@@ -1449,10 +1153,6 @@ void SensorDigitalOutput::onReceive(MyMessage* message) {
   }
 }
 
-// what to do when receiving an interrupt
-void SensorDigitalOutput::onInterrupt() {
-}
-
 // write the value to the output
 void SensorDigitalOutput::setStatus(Child* child, int value) {
   // pre-process the input value
@@ -1496,7 +1196,7 @@ void SensorDigitalOutput::_setStatus(Child* child, int value) {
   int value_to_write = _getValueToWrite(value);
   // set the value to the pin
   digitalWrite(_pin, value_to_write);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -1523,8 +1223,8 @@ int SensorDigitalOutput::_getValueToWrite(int value) {
 */
 
 // contructor
-SensorRelay::SensorRelay(const NodeManager& node_manager, int pin): SensorDigitalOutput(node_manager, pin) {
-  _name = "REL";
+SensorRelay::SensorRelay(NodeManager& node_manager, int pin): SensorDigitalOutput(node_manager, pin) {
+  _name = "RELAY";
 }
 
 // what to do during before
@@ -1537,7 +1237,8 @@ void SensorRelay::onBefore() {
 */
 
 // contructor
-SensorLatchingRelay::SensorLatchingRelay(const NodeManager& node_manager, int pin): SensorRelay(node_manager, pin) {
+SensorLatchingRelay::SensorLatchingRelay(NodeManager& node_manager, int pin): SensorRelay(node_manager, pin) {
+  _name = "LATCHING";
   // set the "off" pin to the provided pin and the "on" pin to the provided pin + 1
   _pin_on = pin;
   _pin_off = pin + 1;
@@ -1574,7 +1275,7 @@ void SensorLatchingRelay::_setStatus(Child* child, int value) {
   // wait for the given time before restoring the value to the original value after the pulse
   _node->sleepOrWait(_pulse_width);
   digitalWrite(pin, ! _on_value);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("LAT I="));
     Serial.print(child->child_id);
     Serial.print(F(" P="));
@@ -1590,13 +1291,13 @@ void SensorLatchingRelay::_setStatus(Child* child, int value) {
 
 #endif
 
-#if MODULE_DHT == 1
+#ifdef MODULE_DHT
 /*
    SensorDHT
 */
 
 // contructor
-SensorDHT::SensorDHT(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorDHT::SensorDHT(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "DHT";
   _dht_type = DHT::DHT11;
 }
@@ -1613,7 +1314,7 @@ void SensorDHT::onSetup() {
   // store the dht object
   _dht = new DHT();
   // initialize the dht library
-  _dht->setup(_pin,_dht_type);
+  _dht->setup(_pin,(DHT::DHT_MODEL_t)_dht_type);
 }
 
 // what to do during loop
@@ -1625,7 +1326,7 @@ void SensorDHT::onLoop(Child* child) {
     // read the temperature
     float temperature = _dht->getTemperature();
     if (! _node->getIsMetric()) temperature = _dht->toFahrenheit(temperature);
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -1639,7 +1340,7 @@ void SensorDHT::onLoop(Child* child) {
   else if (child->type == V_HUM) {
     // read humidity
     float humidity = _dht->getHumidity();
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -1658,16 +1359,12 @@ void SensorDHT::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorDHT::onInterrupt() {
-}
-
 /*
    SensorDHT11
 */
 
 // contructor
-SensorDHT11::SensorDHT11(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
+SensorDHT11::SensorDHT11(NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
   _name = "DHT11";
   _dht_type = DHT::DHT11;
 }
@@ -1677,7 +1374,7 @@ SensorDHT11::SensorDHT11(const NodeManager& node_manager, int pin): SensorDHT(no
 */
 
 // contructor
-SensorDHT22::SensorDHT22(const NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
+SensorDHT22::SensorDHT22(NodeManager& node_manager, int pin): SensorDHT(node_manager, pin) {
   _name = "DHT22";
   _dht_type = DHT::DHT22;
 }
@@ -1686,9 +1383,9 @@ SensorDHT22::SensorDHT22(const NodeManager& node_manager, int pin): SensorDHT(no
 /*
    SensorSHT21
 */
-#if MODULE_SHT21 == 1
+#ifdef MODULE_SHT21
 // contructor
-SensorSHT21::SensorSHT21(const NodeManager& node_manager): Sensor(node_manager) {
+SensorSHT21::SensorSHT21(NodeManager& node_manager): Sensor(node_manager) {
   _name = "SHT21";
 }
 
@@ -1713,7 +1410,7 @@ void SensorSHT21::onLoop(Child* child) {
     float temperature = SHT2x.GetTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -1728,7 +1425,7 @@ void SensorSHT21::onLoop(Child* child) {
     // read humidity
     float humidity = SHT2x.GetHumidity();
     if (isnan(humidity)) return;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -1747,10 +1444,6 @@ void SensorSHT21::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorSHT21::onInterrupt() {
-}
-
 /*
  * SensorHTU21D
  */
@@ -1760,11 +1453,11 @@ SensorHTU21D::SensorHTU21D(NodeManager& nodeManager): SensorSHT21(nodeManager) {
 }
 #endif 
 
-#if MODULE_SWITCH == 1
+#ifdef MODULE_SWITCH
 /*
  * SensorSwitch
  */
-SensorSwitch::SensorSwitch(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorSwitch::SensorSwitch(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "SWITCH";
 }
 
@@ -1818,7 +1511,7 @@ void SensorSwitch::onInterrupt() {
   int value = digitalRead(_pin);
   // process the value
   if ( (_mode == RISING && value == HIGH ) || (_mode == FALLING && value == LOW) || (_mode == CHANGE) )  {
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -1839,7 +1532,7 @@ void SensorSwitch::onInterrupt() {
 /*
  * SensorDoor
  */
-SensorDoor::SensorDoor(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
+SensorDoor::SensorDoor(NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
   _name = "DOOR";
 }
 
@@ -1851,7 +1544,7 @@ void SensorDoor::onBefore() {
 /*
  * SensorMotion
  */
-SensorMotion::SensorMotion(const NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
+SensorMotion::SensorMotion(NodeManager& node_manager, int pin): SensorSwitch(node_manager, pin) {
   _name = "MOTION";
 }
 
@@ -1871,9 +1564,9 @@ void SensorMotion::onSetup() {
 /*
    SensorDs18b20
 */
-#if MODULE_DS18B20 == 1
+#ifdef MODULE_DS18B20
 // contructor
-SensorDs18b20::SensorDs18b20(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorDs18b20::SensorDs18b20(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "DS18B20";
 }
 
@@ -1914,7 +1607,7 @@ void SensorDs18b20::onLoop(Child* child) {
   float temperature = _sensors->getTempCByIndex(index);
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -1932,10 +1625,6 @@ void SensorDs18b20::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorDs18b20::onInterrupt() {
-}
-
 // returns the sensor's resolution in bits
 int SensorDs18b20::getResolution() {
   return _sensors->getResolution();
@@ -1956,9 +1645,9 @@ void SensorDs18b20::setSleepDuringConversion(bool value) {
 /*
    SensorBH1750
 */
-#if MODULE_BH1750 == 1
+#ifdef MODULE_BH1750
 // contructor
-SensorBH1750::SensorBH1750(const NodeManager& node_manager): Sensor(node_manager) {
+SensorBH1750::SensorBH1750(NodeManager& node_manager): Sensor(node_manager) {
   _name = "BH1750";
 }
 // setter/getter
@@ -1981,7 +1670,7 @@ void SensorBH1750::onSetup() {
 void SensorBH1750::onLoop(Child* child) {
   // request the light level
   int value = _lightSensor->readLightLevel();
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -1997,18 +1686,14 @@ void SensorBH1750::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorBH1750::onInterrupt() {
-}
 #endif
 
 /*
    SensorMLX90614
 */
-#if MODULE_MLX90614 == 1
+#ifdef MODULE_MLX90614
 // contructor
-SensorMLX90614::SensorMLX90614(const NodeManager& node_manager): Sensor(node_manager) {
+SensorMLX90614::SensorMLX90614(NodeManager& node_manager): Sensor(node_manager) {
   _name = "MLX90614";
 }
 
@@ -2033,7 +1718,7 @@ void SensorMLX90614::onLoop(Child* child) {
   else temperature = _mlx->readObjectTempC();
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("MLX I="));
     Serial.print(child->child_id);
     Serial.print(F(" T="));
@@ -2048,19 +1733,15 @@ void SensorMLX90614::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorMLX90614::onInterrupt() {
-}
 #endif
 
 
 /*
    SensorBosch
 */
-#if MODULE_BME280 == 1 || MODULE_BMP085 == 1 || MODULE_BMP280 == 1
+#if defined(MODULE_BME280) || defined(MODULE_BMP085) || defined(MODULE_BMP280)
 // contructor
-SensorBosch::SensorBosch(const NodeManager& node_manager): Sensor(node_manager) {
+SensorBosch::SensorBosch(NodeManager& node_manager): Sensor(node_manager) {
   _name = "BOSH";
   // initialize the forecast samples array
   _forecast_samples = new float[_forecast_samples_count];
@@ -2090,13 +1771,9 @@ void SensorBosch::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorBosch::onInterrupt() {
-}
-
 // calculate and send the forecast back
 char* SensorBosch::_forecast(float pressure) {
-  if (isnan(pressure)) return;
+  if (isnan(pressure)) return "";
   // Calculate the average of the last n minutes.
   int index = _minute_count % _forecast_samples_count;
   _forecast_samples[index] = pressure;
@@ -2158,7 +1835,7 @@ char* SensorBosch::_forecast(float pressure) {
   else if ((_dP_dt > 0.05) && (_dP_dt < 0.25)) forecast = 1;
   else if ((_dP_dt >(-0.05)) && (_dP_dt < 0.05)) forecast = 0;
   else forecast = 5;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" M="));
     Serial.print(_minute_count);
@@ -2191,7 +1868,7 @@ uint8_t SensorBosch::GetI2CAddress(uint8_t chip_id) {
     Wire.requestFrom((uint8_t)i2c_address, (byte)1);
     value = Wire.read();
     if (value == chip_id) {
-      #if DEBUG == 1
+      #ifdef NODEMANAGER_DEBUG
         Serial.print(F("I2C=")); 
         Serial.println(i2c_address);
       #endif
@@ -2205,8 +1882,8 @@ uint8_t SensorBosch::GetI2CAddress(uint8_t chip_id) {
 /*
  * SensorBME280
  */
-#if MODULE_BME280 == 1
-SensorBME280::SensorBME280(const NodeManager& node_manager): SensorBosch(node_manager) {
+#ifdef MODULE_BME280
+SensorBME280::SensorBME280(NodeManager& node_manager): SensorBosch(node_manager) {
   _name = "BME280";
 }
 
@@ -2223,7 +1900,7 @@ void SensorBME280::onBefore() {
 void SensorBME280::onSetup() {
   _bm = new Adafruit_BME280();
   if (! _bm->begin(SensorBosch::GetI2CAddress(0x60))) {
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.println(F("ERR"));
     #endif
   }
@@ -2236,7 +1913,7 @@ void SensorBME280::onLoop(Child* child) {
     float temperature = _bm->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2250,7 +1927,7 @@ void SensorBME280::onLoop(Child* child) {
   else if (child->type == V_HUM) {
     // read humidity
     float humidity = _bm->readHumidity();
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2264,7 +1941,7 @@ void SensorBME280::onLoop(Child* child) {
   else if (child->type == V_PRESSURE) {
     // read pressure
     float pressure = _bm->readPressure() / 100.0F;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2285,9 +1962,9 @@ void SensorBME280::onLoop(Child* child) {
 /*
    SensorBMP085
 */
-#if MODULE_BMP085 == 1
+#ifdef MODULE_BMP085
 // contructor
-SensorBMP085::SensorBMP085(const NodeManager& node_manager): SensorBosch(node_manager) {
+SensorBMP085::SensorBMP085(NodeManager& node_manager): SensorBosch(node_manager) {
   _name = "BMP085";
 }
 
@@ -2303,7 +1980,7 @@ void SensorBMP085::onBefore() {
 void SensorBMP085::onSetup() {
   _bm = new Adafruit_BMP085();
   if (! _bm->begin(SensorBosch::GetI2CAddress(0x55))) {
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.println(F("ERR"));
     #endif
   }
@@ -2317,7 +1994,7 @@ void SensorBMP085::onLoop(Child* child) {
     float temperature = _bm->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2331,7 +2008,7 @@ void SensorBMP085::onLoop(Child* child) {
   else if (child->type == V_PRESSURE) {
     // read pressure
     float pressure = _bm->readPressure() / 100.0F;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2352,8 +2029,8 @@ void SensorBMP085::onLoop(Child* child) {
 /*
  * SensorBMP280
  */
-#if MODULE_BMP280 == 1
-SensorBMP280::SensorBMP280(const NodeManager& node_manager): SensorBosch(node_manager) {
+#ifdef MODULE_BMP280
+SensorBMP280::SensorBMP280(NodeManager& node_manager): SensorBosch(node_manager) {
   _name = "BMP280";
 }
 
@@ -2369,7 +2046,7 @@ void SensorBMP280::onBefore() {
 void SensorBMP280::onSetup() {
   _bm = new Adafruit_BMP280();
   if (! _bm->begin(SensorBosch::GetI2CAddress(0x58))) {
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.println(F("ERR"));
     #endif
   }
@@ -2382,7 +2059,7 @@ void SensorBMP280::onLoop(Child* child) {
     float temperature = _bm->readTemperature();
     // convert it
     temperature = _node->celsiusToFahrenheit(temperature);
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2396,7 +2073,7 @@ void SensorBMP280::onLoop(Child* child) {
   else if (child->type == V_PRESSURE) {
     // read pressure
     float pressure = _bm->readPressure() / 100.0F;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2417,9 +2094,9 @@ void SensorBMP280::onLoop(Child* child) {
 /*
    SensorSonoff
 */
-#if MODULE_SONOFF == 1
+#ifdef MODULE_SONOFF
 // contructor
-SensorSonoff::SensorSonoff(const NodeManager& node_manager): Sensor(node_manager) {
+SensorSonoff::SensorSonoff(NodeManager& node_manager): Sensor(node_manager) {
   _name = "SONOFF";
 } 
 
@@ -2485,10 +2162,6 @@ void SensorSonoff::onReceive(MyMessage* message) {
   }
 }
 
-// what to do when receiving an interrupt
-void SensorSonoff::onInterrupt() {
-}
-
 // toggle the state
 void SensorSonoff::_toggle(Child* child) {
   // toggle the state
@@ -2497,7 +2170,7 @@ void SensorSonoff::_toggle(Child* child) {
   digitalWrite(_relay_pin, _state? _relay_on: _relay_off);
   // Change LED state
   digitalWrite(_led_pin, _state? _led_on: _led_off);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -2522,9 +2195,9 @@ void SensorSonoff::_blink() {
 /*
    SensorHCSR04
 */
-#if MODULE_HCSR04 == 1
+#ifdef MODULE_HCSR04
 // contructor
-SensorHCSR04::SensorHCSR04(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorHCSR04::SensorHCSR04(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "HCSR04";
   _trigger_pin = pin;
   _echo_pin = pin;
@@ -2556,7 +2229,7 @@ void SensorHCSR04::onSetup() {
 // what to do during loop
 void SensorHCSR04::onLoop(Child* child) {
   int distance = _node->getIsMetric() ? _sonar->ping_cm() : _sonar->ping_in();
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -2572,18 +2245,14 @@ void SensorHCSR04::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorHCSR04::onInterrupt() {
-}
 #endif
 
 /*
    SensorMCP9808
 */
-#if MODULE_MCP9808 == 1
+#ifdef MODULE_MCP9808
 // contructor
-SensorMCP9808::SensorMCP9808(const NodeManager& node_manager): Sensor(node_manager) {
+SensorMCP9808::SensorMCP9808(NodeManager& node_manager): Sensor(node_manager) {
   _name = "MCP9808";
 }
 
@@ -2602,7 +2271,7 @@ void SensorMCP9808::onLoop(Child* child) {
   float temperature = _mcp->readTempC();
   // convert it
   temperature = _node->celsiusToFahrenheit(temperature);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -2619,23 +2288,18 @@ void SensorMCP9808::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorMCP9808::onInterrupt() {
-}
 #endif
 
-
 /*
  * SensorMQ
  */
-#if MODULE_MQ == 1
+#ifdef MODULE_MQ
 
-static float SensorMQ::_default_LPGCurve[3] = {2.3,0.21,-0.47};
-static float SensorMQ::_default_COCurve[3] = {2.3,0.72,-0.34};
-static float SensorMQ::_default_SmokeCurve[3] = {2.3,0.53,-0.44};
+float SensorMQ::_default_LPGCurve[3] = {2.3,0.21,-0.47};
+float SensorMQ::_default_COCurve[3] = {2.3,0.72,-0.34};
+float SensorMQ::_default_SmokeCurve[3] = {2.3,0.53,-0.44};
 
-SensorMQ::SensorMQ(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorMQ::SensorMQ(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "MQ";
   _LPGCurve = SensorMQ::_default_LPGCurve;
   _COCurve = SensorMQ::_default_COCurve;
@@ -2703,7 +2367,7 @@ void SensorMQ::onLoop(Child* child) {
   if (_target_gas == _gas_lpg) value = lpg;
   if (_target_gas == _gas_co) value = co;
   if (_target_gas == _gas_smoke) value = smoke;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -2727,10 +2391,6 @@ void SensorMQ::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorMQ::onInterrupt() {
-}
-
 // returns the calculated sensor resistance
 float SensorMQ::_MQResistanceCalculation(int raw_adc) {
   return ( ((float)_rl_value*(1023-raw_adc)/raw_adc));
@@ -2788,12 +2448,12 @@ int SensorMQ::_MQGetPercentage(float rs_ro_ratio, float *pcurve) {
 /*
    SensorMHZ19
 */
-#if MODULE_MHZ19 == 1
+#ifdef MODULE_MHZ19
 // contructor
-SensorMHZ19::SensorMHZ19(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorMHZ19::SensorMHZ19(NodeManager& node_manager, int rxpin, int txpin): Sensor(node_manager, rxpin) {
   _name = "MHZ19";
-  _rx_pin = pin;
-  _tx_pin = pin+1;
+  _rx_pin = rxpin;
+  _tx_pin = txpin;
 }
 
 // what to do during before
@@ -2815,7 +2475,7 @@ void SensorMHZ19::onSetup() {
 void SensorMHZ19::onLoop(Child* child) {
   // Read the ppm value
   int co2ppm = _readCO2(); 
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -2834,10 +2494,6 @@ void SensorMHZ19::onReceive(MyMessage* message) {
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
 
-// what to do when receiving an interrupt
-void SensorMHZ19::onInterrupt() {
-}
-
 // Read out the CO2 data
 int SensorMHZ19::_readCO2() {
   while (_ser->read() != -1) {};  //clear serial buffer
@@ -2847,7 +2503,7 @@ int SensorMHZ19::_readCO2() {
   _ser->write(cmd, 9); //request PPM CO2
   // Then for 1 second listen for 9 bytes of data.
   _ser->readBytes(response, 9);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
   for (int i=0; i<9; i++) {
     Serial.print(response[i], HEX);
     Serial.print(F("-"));
@@ -2873,9 +2529,9 @@ int SensorMHZ19::_readCO2() {
 /*
    SensorAM2320
 */
-#if MODULE_AM2320 == 1
+#ifdef MODULE_AM2320
 // constructor
-SensorAM2320::SensorAM2320(const NodeManager& node_manager): Sensor(node_manager) {
+SensorAM2320::SensorAM2320(NodeManager& node_manager): Sensor(node_manager) {
   _name = "AM2320";
 }
 
@@ -2899,7 +2555,7 @@ void SensorAM2320::onLoop(Child* child) {
   // temperature sensor
   if (child->type == V_TEMP) {
     float temperature = _th->t;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2913,7 +2569,7 @@ void SensorAM2320::onLoop(Child* child) {
   else if (child->type == V_HUM) {
     // read humidity
     float humidity = _th->h;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(_name);
       Serial.print(F(" I="));
       Serial.print(child->child_id);
@@ -2931,18 +2587,14 @@ void SensorAM2320::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorAM2320::onInterrupt() {
-}
 #endif
 
 /*
    SensorTSL2561
 */
-#if MODULE_TSL2561 == 1
+#ifdef MODULE_TSL2561
 // contructor
-SensorTSL2561::SensorTSL2561(const NodeManager& node_manager): Sensor(node_manager) {
+SensorTSL2561::SensorTSL2561(NodeManager& node_manager): Sensor(node_manager) {
   _name = "TSL2561";
 }
 
@@ -3001,7 +2653,7 @@ void SensorTSL2561::onSetup() {
     }
   }
   else {
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.println(F("ERROR"));
     #endif
   } 
@@ -3027,7 +2679,7 @@ void SensorTSL2561::onLoop(Child* child) {
       ir = lum >> 16;
       full = lum & 0xFFFF;
       ((ChildInt*)child)->setValueInt(_tsl->calculateLux(full, ir));
-      #if DEBUG == 1
+      #ifdef NODEMANAGER_DEBUG
         Serial.print(_name);
         Serial.print(F(" I="));
         Serial.print(child->child_id);
@@ -3042,7 +2694,7 @@ void SensorTSL2561::onLoop(Child* child) {
       #endif
       break; 
   }
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     if (_tsl_spectrum < 3) {
       Serial.print(_name);
       Serial.print(F(" I="));
@@ -3059,18 +2711,14 @@ void SensorTSL2561::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorTSL2561::onInterrupt() {
-}
 #endif
 
 /*
    SensorPT100
 */
-#if MODULE_PT100 == 1
+#ifdef MODULE_PT100
 // contructor
-SensorPT100::SensorPT100(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorPT100::SensorPT100(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "PT100";
 }
 
@@ -3097,7 +2745,7 @@ void SensorPT100::onSetup() {
 void SensorPT100::onLoop(Child* child) {
   // read the PT100 sensor
   int temperature = _PT100->readTemperature(_pin);  
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -3114,19 +2762,15 @@ void SensorPT100::onReceive(MyMessage* message) {
   if (child == nullptr) return;
   if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
 }
-
-// what to do when receiving an interrupt
-void SensorPT100::onInterrupt() {
-}
 #endif
 
 /*
    SensorDimmer
 */
 
-#if MODULE_DIMMER == 1
+#ifdef MODULE_DIMMER
 // contructor
-SensorDimmer::SensorDimmer(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorDimmer::SensorDimmer(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "DIMMER";
 }
 
@@ -3174,13 +2818,9 @@ void SensorDimmer::onReceive(MyMessage* message) {
   }
 }
 
-// what to do when receiving an interrupt
-void SensorDimmer::onInterrupt() {
-}
-
 // fade to the provided value
 void SensorDimmer::_fadeTo(Child* child, int target_percentage) {
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -3215,9 +2855,9 @@ float SensorDimmer::_getEasing(float t, float b, float c, float d) {
 /*
    SensorPulseMeter
 */
-#if MODULE_PULSE_METER == 1
+#ifdef MODULE_PULSE_METER
 // contructor
-SensorPulseMeter::SensorPulseMeter(const NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
+SensorPulseMeter::SensorPulseMeter(NodeManager& node_manager, int pin): Sensor(node_manager, pin) {
   _name = "PULSE";
 }
 
@@ -3250,7 +2890,7 @@ void SensorPulseMeter::onLoop(Child* child) {
   if (_node->getLastInterruptPin() == _interrupt_pin) return;
   // time to report the rain so far
   _reportTotal(child);
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(_name);
     Serial.print(F(" I="));
     Serial.print(child->child_id);
@@ -3271,77 +2911,441 @@ void SensorPulseMeter::onReceive(MyMessage* message) {
   }
 }
 
-// what to do when receiving an interrupt
-void SensorPulseMeter::onInterrupt() {
-  // increase the counter
-  _count++;
-  #if DEBUG == 1
-    Serial.print(_name);
-    Serial.println(F("+"));
-  #endif
-}
-
-// return the total based on the pulses counted
-void SensorPulseMeter::_reportTotal(Child* child) {
-  ((ChildFloat*)child)->setValueFloat(_count / _pulse_factor);
-}
-
-/*
-   SensorRainGauge
-*/
-// contructor
-SensorRainGauge::SensorRainGauge(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "RAING";
-}
-
-// what to do during before
-void SensorRainGauge::onBefore() {
-  // register the child
-  new ChildFloat(this,_node->getAvailableChildId(),S_RAIN,V_RAIN);
-  setPulseFactor(9.09);
-}
-
-/*
-   SensorPowerMeter
-*/
-// contructor
-SensorPowerMeter::SensorPowerMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "POWER";
-}
-
-// what to do during before
-void SensorPowerMeter::onBefore() {
-  // register the child
-  new ChildDouble(this,_node->getAvailableChildId(),S_POWER,V_KWH);
-  setPulseFactor(1000);
-}
-
-// return the total based on the pulses counted
-void SensorPowerMeter::_reportTotal(Child* child) {
-  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
-}
-
-/*
-   SensorWaterMeter
-*/
-// contructor
-SensorWaterMeter::SensorWaterMeter(const NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
-  _name = "WATER";
-}
-
-// what to do during before
-void SensorWaterMeter::onBefore() {
-  // register the child
-  new ChildDouble(this,_node->getAvailableChildId(),S_WATER,V_VOLUME);
-  setPulseFactor(1000);
-}
-
-// return the total based on the pulses counted
-void SensorWaterMeter::_reportTotal(Child* child) {
-  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
-}
-#endif
-
+// what to do when receiving an interrupt
+void SensorPulseMeter::onInterrupt() {
+  // increase the counter
+  _count++;
+  #ifdef NODEMANAGER_DEBUG
+    Serial.print(_name);
+    Serial.println(F("+"));
+  #endif
+}
+
+// return the total based on the pulses counted
+void SensorPulseMeter::_reportTotal(Child* child) {
+  ((ChildFloat*)child)->setValueFloat(_count / _pulse_factor);
+}
+
+/*
+   SensorRainGauge
+*/
+// contructor
+SensorRainGauge::SensorRainGauge(NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "RAIN_GAUGE";
+}
+
+// what to do during before
+void SensorRainGauge::onBefore() {
+  // register the child
+  new ChildFloat(this,_node->getAvailableChildId(),S_RAIN,V_RAIN);
+  setPulseFactor(9.09);
+}
+
+/*
+   SensorPowerMeter
+*/
+// contructor
+SensorPowerMeter::SensorPowerMeter(NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "POWER";
+}
+
+// what to do during before
+void SensorPowerMeter::onBefore() {
+  // register the child
+  new ChildDouble(this,_node->getAvailableChildId(),S_POWER,V_KWH);
+  setPulseFactor(1000);
+}
+
+// return the total based on the pulses counted
+void SensorPowerMeter::_reportTotal(Child* child) {
+  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
+}
+
+/*
+   SensorWaterMeter
+*/
+// contructor
+SensorWaterMeter::SensorWaterMeter(NodeManager& node_manager, int pin): SensorPulseMeter(node_manager, pin) {
+  _name = "WATER";
+}
+
+// what to do during before
+void SensorWaterMeter::onBefore() {
+  // register the child
+  new ChildDouble(this,_node->getAvailableChildId(),S_WATER,V_VOLUME);
+  setPulseFactor(1000);
+}
+
+// return the total based on the pulses counted
+void SensorWaterMeter::_reportTotal(Child* child) {
+  ((ChildDouble*)child)->setValueDouble(_count / _pulse_factor);
+}
+#endif
+
+/*
+   SensorPlantowerPMS
+*/
+#ifdef MODULE_PMS
+// contructor
+SensorPlantowerPMS::SensorPlantowerPMS(NodeManager& node_manager, int rxpin, int txpin): Sensor(node_manager, rxpin) {
+  _name = "PMS";
+  _rx_pin = rxpin;
+  _tx_pin = txpin;
+}
+
+// what to do during before
+void SensorPlantowerPMS::onBefore() {
+  // register the child
+  new ChildInt(this, _node->getAvailableChildId(), S_AIR_QUALITY, V_LEVEL, "PM1.0");
+  new ChildInt(this, _node->getAvailableChildId(), S_AIR_QUALITY, V_LEVEL, "PM2.5");
+  new ChildInt(this, _node->getAvailableChildId(), S_AIR_QUALITY, V_LEVEL, "PM10.0");
+}
+
+// what to do during setup
+void SensorPlantowerPMS::onSetup() {
+  _ser = new SoftwareSerial(_rx_pin, _tx_pin);
+  _pms = new PMS(*_ser);
+  _ser->begin(9600);
+}
+
+// Clean _valuesRead flag at the beginning so the onLoop function knows when to read values (should be done only once for all children)
+void SensorPlantowerPMS::loop(MyMessage* message) {
+  _valuesRead = false;
+  _valuesReadError = false;
+  Sensor::loop(message);
+}
+
+// what to do during loop
+void SensorPlantowerPMS::onLoop(Child* child) {
+  // Read the ppm values
+  if (!_valuesRead || _valuesReadError) {
+    _valuesReadError = !_pms->read(_data, 1000);
+    if (_valuesReadError) {
+      Serial.println(F("ERR PMS read"));
+      return;
+    }
+    _valuesRead = true;
+  }
+  int val = 0;
+  if (child == children.get(1)) {
+    // PM1.0 values
+    val = _data.PM_AE_UG_1_0;
+  } else if (child == children.get(2)) {
+    // PM 2.5 values
+    val = _data.PM_AE_UG_2_5;
+  } else if (child == children.get(3)) {
+    // PM 10.0 values
+    val = _data.PM_AE_UG_10_0;
+  } else {
+    Serial.println(F("ERR child"));
+    return;
+  }
+  // store the value
+  ((ChildInt*)child)->setValueInt(val);
+  #if DEBUG == 1
+    Serial.print(_name);
+    Serial.print(F(" I="));
+    Serial.print(child->child_id);
+    Serial.print(F(" g/m="));
+    Serial.println(val);
+  #endif
+}
+
+// what to do as the main task when receiving a message
+void SensorPlantowerPMS::onReceive(MyMessage* message) {
+  Child* child = getChild(message->sensor);
+  if (child == nullptr) return;
+  if (message->getCommand() == C_REQ && message->type == child->type) onLoop(child);
+}
+#endif
+
+/*
+   SensorConfiguration
+*/
+// contructor
+SensorConfiguration::SensorConfiguration(NodeManager& node_manager): Sensor(node_manager) {
+  _name = "CONFIG";
+}
+
+// what to do during before
+void SensorConfiguration::onBefore() {
+  new ChildInt(this,CONFIGURATION_CHILD_ID,S_CUSTOM,V_CUSTOM);
+}
+
+// what to do during setup
+void SensorConfiguration::onSetup() {
+
+}
+
+// what to do during loop
+void SensorConfiguration::onLoop(Child* child) {
+}
+
+// what to do as the main task when receiving a message
+void SensorConfiguration::onReceive(MyMessage* message) {
+  // expect a REQ, V_CUSTOM message
+  if (message->getCommand() != C_REQ && message->type != V_CUSTOM) return;
+  // parse the request
+  Request request = Request(message->sensor,message->getString());
+  int function = request.getFunction();
+  int child_id = request.getChildId();
+  // if the message is for the board itself
+  if (child_id == 0) {
+    switch(function) {
+      case 1: _node->hello(); break;
+      case 3: _node->setSleepSeconds(request.getValueInt()); break;
+      case 4: _node->setSleepMinutes(request.getValueInt()); break;
+      case 5: _node->setSleepHours(request.getValueInt()); break;
+      case 29: _node->setSleepDays(request.getValueInt()); break;
+      #ifndef MY_GATEWAY_ESP8266
+        case 6: _node->reboot(); return;
+      #endif
+      case 7: _node->clearEeprom(); break;
+      case 8: _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,VERSION); return;
+      case 9: _node->wakeup(); break;
+      case 10: _node->setRetries(request.getValueInt()); break;
+      case 19: _node->setSleepInterruptPin(request.getValueInt()); break;
+      case 20: _node->setSleepBetweenSend(request.getValueInt()); break;
+      case 21: _node->setAck(request.getValueInt()); break;
+      case 22: _node->setIsMetric(request.getValueInt()); break;
+      case 24: _node->powerOn(); break;
+      case 25: _node->powerOff(); break;
+      case 27: _node->saveToMemory(0,request.getValueInt()); break;
+      case 28: _node->setInterruptMinDelta(request.getValueInt()); break;
+      case 30: _node->setSleepOrWait(request.getValueInt()); break;
+      case 31: _node->setRebootPin(request.getValueInt()); break;
+      case 32: _node->setADCOff(); break;
+      case 36: _node->setReportIntervalSeconds(request.getValueInt()); break;
+      case 37: _node->setReportIntervalMinutes(request.getValueInt()); break;
+      case 38: _node->setReportIntervalHours(request.getValueInt()); break;
+      case 39: _node->setReportIntervalDays(request.getValueInt()); break;
+      default: return; 
+    }
+  // the request is for a sensor
+  } else {
+    // retrieve the sensor the child is belonging to
+    Sensor* sensor = _node->getSensorWithChild(child_id);
+    if (sensor == nullptr) return;
+    // if the message is for a function common to all the sensors
+    if (request.getFunction() < 100) {
+      switch(function) {
+        case 1: sensor->setPin(request.getValueInt()); break;
+        case 5: sensor->setSamples(request.getValueInt()); break;
+        case 6: sensor->setSamplesInterval(request.getValueInt()); break;
+        case 7: sensor->setTrackLastValue(request.getValueInt()); break;
+        case 9: sensor->setForceUpdateMinutes(request.getValueInt()); break;
+        case 13: sensor->powerOn(); break;
+        case 14: sensor->powerOff(); break;
+        case 16: sensor->setReportIntervalMinutes(request.getValueInt()); break;
+        case 17: sensor->setReportIntervalSeconds(request.getValueInt()); break;
+        case 19: sensor->setReportIntervalHours(request.getValueInt()); break;
+        case 20: sensor->setReportIntervalDays(request.getValueInt()); break;
+        default: return;
+      }
+    } else {
+      #ifndef MY_GATEWAY_ESP8266
+      // the message is for a function specific to a sensor
+      if (strcmp(sensor->getName(),"BATTERY") == 0) {
+        SensorBattery* custom_sensor = (SensorBattery*)sensor;
+        switch(function) {
+          case 102: custom_sensor->setMinVoltage(request.getValueFloat()); break;
+          case 103: custom_sensor->setMaxVoltage(request.getValueFloat()); break;
+          case 104: custom_sensor->setBatteryInternalVcc(request.getValueInt()); break;
+          case 105: custom_sensor->setBatteryPin(request.getValueInt()); break;
+          case 106: custom_sensor->setBatteryVoltsPerBit(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      if (strcmp(sensor->getName(),"SIGNAL") == 0) {
+        SensorSignal* custom_sensor = (SensorSignal*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setSignalCommand(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_ANALOG_INPUT
+      if (strcmp(sensor->getName(),"ANALOG_I") == 0 || strcmp(sensor->getName(),"LDR") == 0 || strcmp(sensor->getName(),"RAIN") == 0 || strcmp(sensor->getName(),"SOIL") == 0) {
+        SensorAnalogInput* custom_sensor = (SensorAnalogInput*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setReference(request.getValueInt()); break;
+          case 102: custom_sensor->setReverse(request.getValueInt()); break;
+          case 103: custom_sensor->setOutputPercentage(request.getValueInt()); break;
+          case 104: custom_sensor->setRangeMin(request.getValueInt()); break;
+          case 105: custom_sensor->setRangeMax(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_THERMISTOR
+      if (strcmp(sensor->getName(),"THERMISTOR") == 0) {
+        SensorThermistor* custom_sensor = (SensorThermistor*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setNominalResistor((long)request.getValueInt()); break;
+          case 102: custom_sensor->setNominalTemperature(request.getValueInt()); break;
+          case 103: custom_sensor->setBCoefficient(request.getValueInt()); break;
+          case 104: custom_sensor->setSeriesResistor((long)request.getValueInt()); break;
+          case 105: custom_sensor->setOffset(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_ACS712
+      if (strcmp(sensor->getName(),"ACS712") == 0) {
+        SensorACS712* custom_sensor = (SensorACS712*)sensor;
+        switch(function) {
+          case 100: custom_sensor->setmVPerAmp(request.getValueInt()); break;
+          case 102: custom_sensor->setOffset(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_DIGITAL_OUTPUT
+      if (strcmp(sensor->getName(),"DIGITAL_O") == 0 || strcmp(sensor->getName(),"RELAY") == 0 || strcmp(sensor->getName(),"LATCHING") == 0) {
+        SensorDigitalOutput* custom_sensor = (SensorDigitalOutput*)sensor;
+        switch(function) {
+            case 103: custom_sensor->setOnValue(request.getValueInt()); break;
+            case 104: custom_sensor->setLegacyMode(request.getValueInt()); break;
+            case 105: custom_sensor->setSafeguard(request.getValueInt()); break;
+            case 106: custom_sensor->setInputIsElapsed(request.getValueInt()); break;
+            case 107: custom_sensor->setWaitAfterSet(request.getValueInt()); break;
+          default: return;
+        }
+        if (function > 200 && strcmp(sensor->getName(),"LATCHING") == 0) {
+          SensorLatchingRelay* custom_sensor_2 = (SensorLatchingRelay*)sensor;
+          switch(function) {
+            case 201: custom_sensor_2->setPulseWidth(request.getValueInt()); break;
+            case 202: custom_sensor_2->setPinOff(request.getValueInt()); break;
+            case 203: custom_sensor_2->setPinOn(request.getValueInt()); break;
+          default: return;
+        }
+        }
+      }
+      #endif
+      #ifdef MODULE_SWITCH
+      if (strcmp(sensor->getName(),"SWITCH") == 0 || strcmp(sensor->getName(),"DOOR") == 0 || strcmp(sensor->getName(),"MOTION") == 0) {
+        SensorSwitch* custom_sensor = (SensorSwitch*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setMode(request.getValueInt()); break;
+          case 102: custom_sensor->setDebounce(request.getValueInt()); break;
+          case 103: custom_sensor->setTriggerTime(request.getValueInt()); break;
+          case 104: custom_sensor->setInitial(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_DS18B20
+      if (strcmp(sensor->getName(),"DS18B20") == 0) {
+        SensorDs18b20* custom_sensor = (SensorDs18b20*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setResolution(request.getValueInt()); break;
+          case 102: custom_sensor->setSleepDuringConversion(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_BH1750
+      if (strcmp(sensor->getName(),"BH1750") == 0) {
+        SensorBH1750* custom_sensor = (SensorBH1750*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setMode(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #if defined(MODULE_BME280) || defined(MODULE_BMP085) || defined(MODULE_BMP280)
+      if (strcmp(sensor->getName(),"BMP085") == 0 || strcmp(sensor->getName(),"BME280") == 0 || strcmp(sensor->getName(),"BMP280") == 0) {
+        SensorBosch* custom_sensor = (SensorBosch*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setForecastSamplesCount(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_SONOFF
+      if (strcmp(sensor->getName(),"SONOFF") == 0) {
+        SensorSonoff* custom_sensor = (SensorSonoff*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setButtonPin(request.getValueInt()); break;
+          case 102: custom_sensor->setRelayPin(request.getValueInt()); break;
+          case 103: custom_sensor->setLedPin(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_HCSR04
+      if (strcmp(sensor->getName(),"HCSR04") == 0) {
+        SensorHCSR04* custom_sensor = (SensorHCSR04*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setTriggerPin(request.getValueInt()); break;
+          case 102: custom_sensor->setEchoPin(request.getValueInt()); break;
+          case 103: custom_sensor->setMaxDistance(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_MQ
+      if (strcmp(sensor->getName(),"MQ") == 0) {
+        SensorMQ* custom_sensor = (SensorMQ*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setTargetGas(request.getValueInt()); break;
+          case 102: custom_sensor->setRlValue(request.getValueFloat()); break;
+          case 103: custom_sensor->setRoValue(request.getValueFloat()); break;
+          case 104: custom_sensor->setCleanAirFactor(request.getValueFloat()); break;
+          case 105: custom_sensor->setCalibrationSampleTimes(request.getValueInt()); break;
+          case 106: custom_sensor->setCalibrationSampleInterval(request.getValueInt()); break;
+          case 107: custom_sensor->setReadSampleTimes(request.getValueInt()); break;
+          case 108: custom_sensor->setReadSampleInterval(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_TSL2561
+      if (strcmp(sensor->getName(),"TSL2561") == 0) {
+        SensorTSL2561* custom_sensor = (SensorTSL2561*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setGain(request.getValueInt()); break;
+          case 102: custom_sensor->setTiming(request.getValueInt()); break;
+          case 103: custom_sensor->setSpectrum(request.getValueInt()); break;
+          case 104: custom_sensor->setAddress(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_PT100
+      if (strcmp(sensor->getName(),"PT100") == 0) {
+        SensorPT100* custom_sensor = (SensorPT100*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setVoltageRef(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_DIMMER
+      if (strcmp(sensor->getName(),"DIMMER") == 0) {
+        SensorDimmer* custom_sensor = (SensorDimmer*)sensor;
+        switch(function) {
+          case 101: custom_sensor->setEasing(request.getValueInt()); break;
+          case 102: custom_sensor->setDuration(request.getValueInt()); break;
+          case 103: custom_sensor->setStepDuration(request.getValueInt()); break;
+          default: return;
+        }
+      }
+      #endif
+      #ifdef MODULE_PULSE_METER
+      if (strcmp(sensor->getName(),"RAIN_GAUGE") == 0 || strcmp(sensor->getName(),"POWER") == 0 || strcmp(sensor->getName(),"WATER") == 0) {
+        SensorPulseMeter* custom_sensor = (SensorPulseMeter*)sensor;
+        switch(function) {
+          case 102: custom_sensor->setPulseFactor(request.getValueFloat()); break;
+          default: return;
+        }
+      }
+      #endif
+    }
+  }
+  _node->sendMessage(CONFIGURATION_CHILD_ID,V_CUSTOM,function);
+}
+
 /*******************************************
    NodeManager
 */
@@ -3452,245 +3456,7 @@ bool NodeManager::isSleepingNode() {
   return false;
 }
 
-/*
-// register a sensor to this manager
-int NodeManager::registerSensor(int sensor_type, int pin, int child_id) {
-  // get a child_id if not provided by the user
-  if (child_id < 0) child_id = _getAvailableChildId();
-  // based on the given sensor type instantiate the appropriate class
-  if (sensor_type < 0) return -1;
-  #if MODULE_ANALOG_INPUT == 1
-    else if (sensor_type == SENSOR_ANALOG_INPUT) return registerSensor(new SensorAnalogInput(this,child_id, pin));
-    else if (sensor_type == SENSOR_LDR) return registerSensor(new SensorLDR(this,child_id, pin));
-    else if (sensor_type == SENSOR_THERMISTOR) return registerSensor(new SensorThermistor(this,child_id, pin));
-    else if (sensor_type == SENSOR_ML8511) return registerSensor(new SensorML8511(this,child_id, pin));
-    else if (sensor_type == SENSOR_ACS712) return registerSensor(new SensorACS712(this,child_id, pin));
-    else if (sensor_type == SENSOR_RAIN) return registerSensor(new SensorRain(this,child_id, pin));
-    else if (sensor_type == SENSOR_SOIL_MOISTURE) return registerSensor(new SensorSoilMoisture(this,child_id, pin));
-  #endif
-  #if MODULE_DIGITAL_INPUT == 1
-    else if (sensor_type == SENSOR_DIGITAL_INPUT) return registerSensor(new SensorDigitalInput(this,child_id, pin));
-  #endif
-  #if MODULE_DIGITAL_OUTPUT == 1
-    else if (sensor_type == SENSOR_DIGITAL_OUTPUT) return registerSensor(new SensorDigitalOutput(this,child_id, pin));
-    else if (sensor_type == SENSOR_RELAY) return registerSensor(new SensorRelay(this,child_id, pin));
-    else if (sensor_type == SENSOR_LATCHING_RELAY) return registerSensor(new SensorLatchingRelay(this,child_id, pin));
-  #endif
-  #if MODULE_DHT == 1
-    else if (sensor_type == SENSOR_DHT11 || sensor_type == SENSOR_DHT22) {
-      int dht_type;
-      if (sensor_type == SENSOR_DHT11) dht_type = DHT::DHT11;
-      else if (sensor_type == SENSOR_DHT22) dht_type = DHT::DHT22;
-      DHT* dht = new DHT();
-      // register temperature sensor
-      registerSensor(new SensorDHT(this,child_id,pin,dht,SensorDHT::TEMPERATURE,dht_type));
-      // register humidity sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorDHT(this,child_id,pin,dht,SensorDHT::HUMIDITY,dht_type));
-    }
-  #endif
-  #if MODULE_SHT21 == 1
-    else if (sensor_type == SENSOR_SHT21) {
-      // register temperature sensor
-      //registerSensor(new SensorSHT21(this,child_id,SensorSHT21::TEMPERATURE));
-      // register humidity sensor
-      //child_id = _getAvailableChildId();
-      //return registerSensor(new SensorSHT21(this,child_id,SensorSHT21::HUMIDITY));
-    }
-    else if (sensor_type == SENSOR_HTU21D) {
-      // register temperature sensor
-      //registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::TEMPERATURE));
-      // register humidity sensor
-      child_id = _getAvailableChildId();
-//      return registerSensor(new SensorHTU21D(this,child_id,SensorHTU21D::HUMIDITY));
-    }
-  #endif
-  #if MODULE_SWITCH == 1
-    else if (sensor_type == SENSOR_SWITCH || sensor_type == SENSOR_DOOR || sensor_type == SENSOR_MOTION) {
-      // ensure an interrupt pin is provided
-      if (pin != INTERRUPT_PIN_1 && pin != INTERRUPT_PIN_2) return -1;
-      // register the sensor
-      if (sensor_type == SENSOR_SWITCH) return registerSensor(new SensorSwitch(this,child_id, pin));
-      else if (sensor_type == SENSOR_DOOR) return registerSensor(new SensorDoor(this,child_id, pin));
-      else if (sensor_type == SENSOR_MOTION) return registerSensor(new SensorMotion(this,child_id, pin));
-    }
-  #endif
-  #if MODULE_DS18B20 == 1
-    else if (sensor_type == SENSOR_DS18B20) {
-      // initialize the library
-      OneWire* oneWire = new OneWire(pin);
-      DallasTemperature* sensors = new DallasTemperature(oneWire);
-      // initialize the sensors
-      sensors->begin();
-      int index = 0;
-      // register a new child for each sensor on the bus
-      for(int i = 0; i < sensors->getDeviceCount(); i++) {
-        if (i > 0) child_id = _getAvailableChildId();
-        index = registerSensor(new SensorDs18b20(this,child_id,pin,sensors,i));
-      }
-      return index;
-    }
-  #endif
-  #if MODULE_BH1750 == 1
-    else if (sensor_type == SENSOR_BH1750) return registerSensor(new SensorBH1750(this,child_id));
-  #endif
-  #if MODULE_MLX90614 == 1
-    else if (sensor_type == SENSOR_MLX90614) {
-      Adafruit_MLX90614* mlx = new Adafruit_MLX90614();
-      // register ambient temperature sensor
-      registerSensor(new SensorMLX90614(this,child_id,mlx,SensorMLX90614::TEMPERATURE_AMBIENT));
-      // register object temperature sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorMLX90614(this,child_id,mlx,SensorMLX90614::TEMPERATURE_OBJECT));
-    }
-  #endif
-  #if MODULE_BME280 == 1
-    else if (sensor_type == SENSOR_BME280) {
-      Adafruit_BME280* bme = new Adafruit_BME280();
-      if (! bme->begin(SensorBosch::GetI2CAddress(0x60))) {
-        #if DEBUG == 1
-          Serial.println(F("NO BME"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::TEMPERATURE));
-      child_id = _getAvailableChildId();
-      // register humidity sensor
-      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::HUMIDITY));
-      // register pressure sensor
-      child_id = _getAvailableChildId();
-      registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::PRESSURE));
-      // register forecast sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorBME280(this,child_id,bme,SensorBME280::FORECAST));
-    }
-  #endif
-  #if MODULE_BMP280 == 1
-    else if (sensor_type == SENSOR_BMP280) {
-      Adafruit_BMP280* bmp = new Adafruit_BMP280();
-      if (! bmp->begin(SensorBosch::GetI2CAddress(0x58))) {
-        #if DEBUG == 1
-          Serial.println(F("NO BMP"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::TEMPERATURE));
-      child_id = _getAvailableChildId();
-      // register pressure sensor
-      child_id = _getAvailableChildId();
-      registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::PRESSURE));
-      // register forecast sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorBMP280(this,child_id,bmp,SensorBMP280::FORECAST));
-    }
-  #endif
-  #if MODULE_SONOFF == 1
-    else if (sensor_type == SENSOR_SONOFF) return registerSensor(new SensorSonoff(this,child_id));
-  #endif
-  #if MODULE_BMP085 == 1
-    else if (sensor_type == SENSOR_BMP085) {
-      Adafruit_BMP085* bmp = new Adafruit_BMP085();
-      if (! bmp->begin(SensorBosch::GetI2CAddress(0x55))) {
-        #if DEBUG == 1
-          Serial.println(F("NO BMP"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::TEMPERATURE));
-      // register pressure sensor
-      child_id = _getAvailableChildId();
-      registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::PRESSURE));
-      // register forecast sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorBMP085(this,child_id,bmp,SensorBMP085::FORECAST));
-    }
-  #endif
-  #if MODULE_HCSR04 == 1
-    else if (sensor_type == SENSOR_HCSR04) return registerSensor(new SensorHCSR04(this,child_id, pin));
-  #endif
-  #if MODULE_MCP9808 == 1
-    else if (sensor_type == SENSOR_MCP9808) {
-      Adafruit_MCP9808 * mcp = new Adafruit_MCP9808();
-      if (! mcp->begin()) {
-        #if DEBUG == 1
-          Serial.println(F("NO MCP"));
-        #endif
-        return -1;
-      }
-      // register temperature sensor
-      registerSensor(new SensorMCP9808(this,child_id,mcp));
-    }
-  #endif
-  #if MODULE_MQ == 1
-    else if (sensor_type == SENSOR_MQ) return registerSensor(new SensorMQ(this,child_id, pin));
-  #endif
-  #if MODULE_MHZ19 == 1
-    else if (sensor_type == SENSOR_MHZ19) return registerSensor(new SensorMHZ19(this, child_id, pin));
-  #endif
-  #if MODULE_AM2320 == 1
-    else if (sensor_type == SENSOR_AM2320) {
-      AM2320* th = new AM2320();
-      // register temperature sensor
-      registerSensor(new SensorAM2320(this,child_id,th,SensorAM2320::TEMPERATURE));
-      // register humidity sensor
-      child_id = _getAvailableChildId();
-      return registerSensor(new SensorAM2320(this,child_id,th,SensorAM2320::HUMIDITY));
-    }
-  #endif
-  #if MODULE_TSL2561 == 1 
-    else if (sensor_type == SENSOR_TSL2561) return registerSensor(new SensorTSL2561(this,child_id));
-  #endif
-  #if MODULE_PT100 == 1 
-    else if (sensor_type == SENSOR_PT100) return registerSensor(new SensorPT100(this,child_id,pin));
-  #endif
-  #if MODULE_DIMMER == 1 
-    else if (sensor_type == SENSOR_DIMMER) return registerSensor(new SensorDimmer(this,child_id,pin));
-  #endif
-  #if MODULE_PULSE_METER == 1 
-    else if (sensor_type == SENSOR_RAIN_GAUGE) return registerSensor(new SensorRainGauge(this,child_id,pin));
-    else if (sensor_type == SENSOR_POWER_METER) return registerSensor(new SensorPowerMeter(this,child_id,pin));
-    else if (sensor_type == SENSOR_WATER_METER) return registerSensor(new SensorWaterMeter(this,child_id,pin));
-  #endif
-  else {
-    #if DEBUG == 1
-      Serial.print(F("INVALID "));
-      Serial.println(sensor_type);
-    #endif
-    return -1;
-  };
-}
-/*
-
-
-
-/*
-// attach a built-in or custom sensor to this manager
-int NodeManager::registerSensorOLD(Sensor* sensor) {
-  if (sensor->getChildId() > MAX_SENSORS) return;
-  #if DEBUG == 1
-    Serial.print(F("REG I="));
-    Serial.print(sensor->getChildId());
-    Serial.print(F(" P="));
-    Serial.print(sensor->getPin());
-    Serial.print(F(" P="));
-    Serial.print(sensor->getPresentation());
-    Serial.print(F(" T="));
-    Serial.println(sensor->getType());
-  #endif
-  #if POWER_MANAGER == 1
-    // set auto power pin
-    sensor->setAutoPowerPins(_auto_power_pins);
-  #endif
-  // add the sensor to the array of registered sensors
-  _sensors[sensor->getChildId()] = sensor;
-  // return the child_id
-  return sensor->getChildId();
-}
-*/
-
+// register a sensor against NodeManager
 void NodeManager::registerSensor(Sensor* sensor) {
   sensors.push(sensor);
 }
@@ -3698,13 +3464,13 @@ void NodeManager::registerSensor(Sensor* sensor) {
 // setup NodeManager
 void NodeManager::before() {
   // print out the version
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("NodeManager v"));
     Serial.println(VERSION);
   #endif
   // setup the reboot pin if needed
   if (_reboot_pin > -1) {
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print("REB P=");
       Serial.println(_reboot_pin);
     #endif
@@ -3712,7 +3478,7 @@ void NodeManager::before() {
     digitalWrite(_reboot_pin, HIGH);
   }
   // print out MySensors' library capabilities
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("LIB V="));
     Serial.print(MYSENSORS_LIBRARY_VERSION);
     Serial.print(F(" R="));
@@ -3744,7 +3510,7 @@ void NodeManager::before() {
 
 // present NodeManager and its sensors
 void NodeManager::presentation() {
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.println(F("RADIO OK"));
   #endif
   // Send the sketch version information to the gateway and Controller
@@ -3757,7 +3523,7 @@ void NodeManager::presentation() {
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
     sensor->presentation();
   }
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.println(F("READY"));
     Serial.println("");
   #endif
@@ -3768,7 +3534,7 @@ void NodeManager::presentation() {
 void NodeManager::setup() {
   // retrieve and store isMetric from the controller
   if (_get_controller_config) _is_metric = getControllerConfig().isMetric;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("MY I="));
     Serial.print(getNodeId());
     Serial.print(F(" M="));
@@ -3812,8 +3578,8 @@ void NodeManager::loop() {
 }
 
 // dispacth inbound messages
-void NodeManager::receive(const MyMessage &message) {
-  #if DEBUG == 1
+void NodeManager::receive(MyMessage &message) {
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("RECV S="));
     Serial.print(message.sender);
     Serial.print(F(" I="));
@@ -3842,7 +3608,7 @@ long NodeManager::getTimestamp() {
   int retries = 3;
   _timestamp = -1;
   while (_timestamp == -1 && retries > 0) {
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.println(F("TIME"));
     #endif
     // request the time to the controller
@@ -3857,7 +3623,7 @@ long NodeManager::getTimestamp() {
 // receive the time from the controller and save it
 void NodeManager::receiveTime(unsigned long ts) {
   _timestamp = ts;
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("TIME T="));
     Serial.print(_timestamp);
   #endif
@@ -3870,7 +3636,8 @@ void NodeManager::hello() {
 
 // reboot the board
 void NodeManager::reboot() {
-  #if DEBUG == 1
+  #ifndef MY_GATEWAY_ESP8266
+  #ifdef NODEMANAGER_DEBUG
     Serial.println(F("REBOOT"));
   #endif
   if (_reboot_pin > -1) {
@@ -3884,11 +3651,12 @@ void NodeManager::reboot() {
     // Infinite loop until watchdog reset after 16 ms
     while(true){}
   }
+  #endif
 }
 
 // clear the EEPROM
 void NodeManager::clearEeprom() {
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.println(F("CLEAR"));
   #endif
   for (uint16_t i=0; i<EEPROM_LOCAL_CONFIG_ADDRESS; i++) saveState(i, 0xFF);
@@ -3896,7 +3664,7 @@ void NodeManager::clearEeprom() {
 
 // wake up the board
 void NodeManager::wakeup() {
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.println(F("WAKEUP"));
   #endif
   _status = AWAKE;
@@ -3916,7 +3684,7 @@ void NodeManager::saveToMemory(int index, int value) {
 float NodeManager::getVcc() {
   #ifndef MY_GATEWAY_ESP8266
     // Measure Vcc against 1.1V Vref
-    #if defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+    #ifdef defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
       ADMUX = (_BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1));
     #elif defined (__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
       ADMUX = (_BV(MUX5) | _BV(MUX0));
@@ -3957,7 +3725,7 @@ void NodeManager::setupInterrupts() {
     // for non sleeping nodes, we need to handle the interrupt by ourselves  
     if (_status != SLEEP) attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN_2), _onInterrupt_2, _interrupt_2_mode);
   }
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("INT P="));
     Serial.print(INTERRUPT_PIN_1);
     Serial.print(F(" M="));
@@ -4006,10 +3774,12 @@ void NodeManager::setRebootPin(int value) {
 
 // turn the ADC off so to save 0.2 mA
 void NodeManager::setADCOff() {
-  // Disable the ADC by setting the ADEN bit (bit 7) to zero
-  ADCSRA = ADCSRA & B01111111;
-  // Disable the analog comparator by setting the ACD bit (bit 7) to one
-  ACSR = B10000000;
+  #ifndef MY_GATEWAY_ESP8266
+    // Disable the ADC by setting the ADEN bit (bit 7) to zero
+    ADCSRA = ADCSRA & B01111111;
+    // Disable the analog comparator by setting the ACD bit (bit 7) to one
+    ACSR = B10000000;
+  #endif
 }
 
 // sleep if the node is a battery powered or wait if it is not for the given number of milliseconds 
@@ -4034,7 +3804,7 @@ void NodeManager::_onInterrupt_1() {
   long now = millis();
   if ( (now - _last_interrupt_1 > _interrupt_min_delta) || (now < _last_interrupt_1) ) {
     _last_interrupt_pin = INTERRUPT_PIN_1;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(F("INT P="));
       Serial.println(INTERRUPT_PIN_1);
     #endif
@@ -4045,7 +3815,7 @@ void NodeManager::_onInterrupt_2() {
   long now = millis();
   if ( (now - _last_interrupt_2 > _interrupt_min_delta) || (now < _last_interrupt_2) ) {
     _last_interrupt_pin = INTERRUPT_PIN_2;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(F("INT P="));
       Serial.println(INTERRUPT_PIN_2);
     #endif
@@ -4084,7 +3854,7 @@ void NodeManager::_sendMessage(int child_id, int type) {
   for (int i = 0; i < _retries; i++) {
     // if configured, sleep beetween each send
     if (_sleep_between_send > 0) sleep(_sleep_between_send);
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(F("SEND D="));
       Serial.print(_message.destination);
       Serial.print(F(" I="));
@@ -4104,7 +3874,7 @@ void NodeManager::_sendMessage(int child_id, int type) {
   }
 }
 
-void NodeManager::setPowerManager(const PowerManager& powerManager) {
+void NodeManager::setPowerManager(PowerManager& powerManager) {
   _powerManager = &powerManager;
 }
 
@@ -4127,12 +3897,10 @@ Sensor* NodeManager::getSensorWithChild(int child_id) {
 
 // wrapper of smart sleep
 void NodeManager::_sleep() {
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("SLEEP "));
     Serial.print(_sleep_time);
     Serial.println(F("s"));
-  #endif
-  #if DEBUG == 1
     // print a new line to separate the different cycles
     Serial.println("");
   #endif
@@ -4157,7 +3925,7 @@ void NodeManager::_sleep() {
       interrupt_mode = _interrupt_2_mode;
     }
     _last_interrupt_pin = pin_number;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(F("INT P="));
       Serial.print(pin_number);
       Serial.print(F(", M="));
@@ -4167,14 +3935,14 @@ void NodeManager::_sleep() {
     if (_sleep_interrupt_pin == pin_number) _status = AWAKE;
   }
   // coming out of sleep
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.println(F("AWAKE"));
   #endif
 }
 
 // present the service
 void NodeManager::_present(int child_id, int type) {
-  #if DEBUG == 1
+  #ifdef NODEMANAGER_DEBUG
     Serial.print(F("PRES I="));
     Serial.print(child_id);
     Serial.print(F(", T="));
@@ -4192,7 +3960,7 @@ void NodeManager::_loadSleepSettings() {
     int bit_2 = loadState(EEPROM_SLEEP_2);
     int bit_3 = loadState(EEPROM_SLEEP_3);
     _sleep_time = bit_3*255*255 + bit_2*255 + bit_1;
-    #if DEBUG == 1
+    #ifdef NODEMANAGER_DEBUG
       Serial.print(F("LOADSLP T="));
       Serial.println(_sleep_time);
     #endif
diff --git a/README.md b/README.md
index 61d1089..4581a80 100755
--- a/README.md
+++ b/README.md
@@ -24,46 +24,57 @@ NodeManager includes the following main features:
 
 ### Built-in sensors
 
-NodeManager provides built-in implementation of a number of sensors through dedicated classes:
-
-Sensor's class  | Description
- ------------- | -------------
-SensorAnalogInput | Generic analog sensor, return a pin's analog value or its percentage
-SensorLDR | LDR sensor, return the light level of an attached light resistor in percentage
-SensorRain | Rain sensor, return the percentage of rain from an attached analog sensor
-SensorSoilMoisture | Soil moisture sensor, return the percentage of moisture from an attached analog sensor
-SensorThermistor | Thermistor sensor, return the temperature based on the attached thermistor
-SensorML8511 | ML8511 sensor, return UV intensity
-SensorACS712 | ACS712 sensor, measure the current going through the attached module
-SensorDigitalInput |  Generic digital sensor, return a pin's digital value
-SensorDigitalOutput | Generic digital output sensor, allows setting the digital output of a pin to the requested value
-SensorRelay | Relay sensor, allows activating the relay
-SensorLatchingRelay| Latching Relay sensor, allows activating the relay with a pulse
-SensorDHT11 | DHT11 sensor, return temperature/humidity based on the attached DHT sensor
-SensorDHT22 | DHT22 sensor, return temperature/humidity based on the attached DHT sensor
-SensorSHT21 | SHT21 sensor, return temperature/humidity based on the attached SHT21 sensor
-SensorHTU21D | HTU21D sensor, return temperature/humidity based on the attached HTU21D sensor
-SensorSwitch | Generic switch, wake up the board when a pin changes status
-SensorDoor | Door sensor, wake up the board and report when an attached magnetic sensor has been opened/closed
-SensorMotion | Motion sensor, wake up the board and report when an attached PIR has triggered
-SensorDs18b20 | DS18B20 sensor, return the temperature based on the attached sensor
-SensorBH1750 | BH1750 sensor, return light level in lux
-SensorMLX90614 | MLX90614 contactless temperature sensor, return ambient and object temperature
-SensorBME280 | BME280 sensor, return temperature/humidity/pressure based on the attached BME280 sensor
-SensorBMP085 | BMP085/BMP180 sensor, return temperature and pressure
-SensorBMP280 | BMP280 sensor, return temperature/pressure based on the attached BMP280 sensor
-SensorSonoff | Sonoff wireless smart switch
-SensorHCSR04 | HC-SR04 sensor, return the distance between the sensor and an object
-SensorMCP9808 | MCP9808 sensor, measure the temperature through the attached module
-SensorMQ | MQ sensor, return ppm of the target gas
-SensorMHZ19 | MH-Z19 CO2 sensor via UART (SoftwareSerial, default on pins 6(Rx) and 7(Tx)
-SensorAM2320 | AM2320 sensors, return temperature/humidity based on the attached AM2320 sensor
-SensorTSL2561 | TSL2561 sensor, return light in lux
-SensorPT100 | High temperature sensor associated with DFRobot Driver, return the temperature in C from the attached PT100 sensor
-SensorDimmer | Generic dimmer sensor used to drive a pwm output
-SensorRainGauge | Rain gauge sensor
-SensorPowerMeter | Power meter pulse sensor
-SensorWaterMeter | Water meter pulse sensor
+NodeManager provides built-in implementation of a number of sensors through ad-hoc classes. 
+To use a buil-in sensor:
+* Install the required library if any
+* Enable the corresponding module (uncomment it) in the main sketch
+* Declare the sensor (uncomment it) in the main sketch
+
+Once created, the sensor will automatically present one or more child to the gateway and controller.
+A list of buil-in sensors, module to enable, required dependencies and the number of child automatically created is presented below:
+
+Sensor Name         |#Child | Module to enable      | Description                                                                                       | Dependencies
+--------------------|-------|-----------------------|---------------------------------------------------------------------------------------------------|----------------------------------------------------------
+SensorBattery       | 1     | -                     | Built-in sensor for automatic battery reporting                                                   | - 
+SensorSignal        | 1     | -                     | Built-in sensor for automatic signal level reporting                                              | -
+SensorConfiguration | 1     | -                     | Built-in sensor for OTA remote configuration of any registered sensor                             | -
+SensorAnalogInput   | 1     | MODULE_ANALOG_INPUT   | Generic analog sensor, return a pin's analog value or its percentage                              | -
+SensorLDR           | 1     | MODULE_ANALOG_INPUT   | LDR sensor, return the light level of an attached light resistor in percentage                    | -
+SensorRain          | 1     | MODULE_ANALOG_INPUT   | Rain sensor, return the percentage of rain from an attached analog sensor                         | -
+SensorSoilMoisture  | 1     | MODULE_ANALOG_INPUT   | Soil moisture sensor, return the percentage of moisture from an attached analog sensor            | -
+SensorThermistor    | 1     | MODULE_THERMISTOR     | Thermistor sensor, return the temperature based on the attached thermistor                        | -
+SensorML8511        | 1     | MODULE_ML8511         | ML8511 sensor, return UV intensity                                                                | -
+SensorACS712        | 1     | MODULE_ACS712         | ACS712 sensor, measure the current going through the attached module                              | -
+SensorDigitalInput  | 1     | MODULE_DIGITAL_INPUT  | Generic digital sensor, return a pin's digital value                                              | -
+SensorDigitalOutput | 1     | MODULE_DIGITAL_OUTPUT | Generic digital output sensor, allows setting the digital output of a pin to the requested value  | -
+SensorRelay         | 1     | MODULE_DIGITAL_OUTPUT | Relay sensor, allows activating the relay                                                         | -
+SensorLatchingRelay | 1     | MODULE_DIGITAL_OUTPUT | Latching Relay sensor, allows activating the relay with a pulse                                   | -
+SensorDHT11         | 2     | MODULE_DHT            | DHT11 sensor, return temperature/humidity based on the attached DHT sensor                        | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/DHT
+SensorDHT22         | 2     | MODULE_DHT            | DHT22 sensor, return temperature/humidity based on the attached DHT sensor                        | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/DHT
+SensorSHT21         | 2     | MODULE_SHT21          | SHT21 sensor, return temperature/humidity based on the attached SHT21 sensor                      | https://github.com/SodaqMoja/Sodaq_SHT2x
+SensorHTU21D        | 2     | MODULE_SHT21          | HTU21D sensor, return temperature/humidity based on the attached HTU21D sensor                    | https://github.com/SodaqMoja/Sodaq_SHT2x
+SensorSwitch        | 1     | MODULE_SWITCH         | Generic switch, wake up the board when a pin changes status                                       | -
+SensorDoor          | 1     | MODULE_SWITCH         | Door sensor, wake up the board and report when an attached magnetic sensor has been opened/closed | -
+SensorMotion        | 1     | MODULE_SWITCH         | Motion sensor, wake up the board and report when an attached PIR has triggered                    | -
+SensorDs18b20       | 1+    |  MODULE_DS18B20       | DS18B20 sensor, return the temperature based on the attached sensor                               | https://github.com/milesburton/Arduino-Temperature-Control-Library
+SensorBH1750        | 1     | MODULE_BH1750         | BH1750 sensor, return light level in lux                                                          | https://github.com/claws/BH1750
+SensorMLX90614      | 2     | MODULE_MLX90614       | MLX90614 contactless temperature sensor, return ambient and object temperature                    | https://github.com/adafruit/Adafruit-MLX90614-Library
+SensorBME280        | 4     | MODULE_BME280         | BME280 sensor, return temperature/humidity/pressure based on the attached BME280 sensor           | https://github.com/adafruit/Adafruit_BME280_Library
+SensorBMP085        | 3     | MODULE_BMP085         | BMP085/BMP180 sensor, return temperature and pressure                                             | https://github.com/adafruit/Adafruit-BMP085-Library
+SensorBMP280        | 3     | MODULE_BMP280         | BMP280 sensor, return temperature/pressure based on the attached BMP280 sensor                    | https://github.com/adafruit/Adafruit_BMP280_Library
+SensorSonoff        | 1     | MODULE_SONOFF         | Sonoff wireless smart switch                                                                      | https://github.com/thomasfredericks/Bounce2
+SensorHCSR04        | 1     | MODULE_HCSR04         | HC-SR04 sensor, return the distance between the sensor and an object                              | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/NewPing
+SensorMCP9808       | 1     | MODULE_MCP9808        | MCP9808 sensor, measure the temperature through the attached module                               | https://github.com/adafruit/Adafruit_MCP9808_Library
+SensorMQ            | 1     | MODULE_MQ             | MQ sensor, return ppm of the target gas                                                           | -
+SensorMHZ19         | 1     | MODULE_MHZ19          | MH-Z19 CO2 sensor via UART (SoftwareSerial, default on pins 6(Rx) and 7(Tx)                       | -
+SensorAM2320        | 2     | MODULE_AM2320         | AM2320 sensors, return temperature/humidity based on the attached AM2320 sensor                   | https://github.com/thakshak/AM2320
+SensorTSL2561       | 1     | MODULE_TSL2561        | TSL2561 sensor, return light in lux                                                               | https://github.com/adafruit/TSL2561-Arduino-Library
+SensorPT100         | 1     | MODULE_PT100          | DFRobot Driver high temperature sensor, return the temperature from the attached PT100 sensor     | -
+SensorDimmer        | 1     | MODULE_DIMMER         | Generic dimmer sensor used to drive a pwm output                                                  | -
+SensorRainGauge     | 1     | MODULE_PULSE_METER    | Rain gauge sensor                                                                                 | -
+SensorPowerMeter    | 1     | MODULE_PULSE_METER    | Power meter pulse sensor                                                                          | -
+SensorWaterMeter    | 1     | MODULE_PULSE_METER    | Water meter pulse sensor                                                                          | -
+SensorPlantowerPMS  | 3     | MODULE_PMS            | Plantower PMS particulate matter sensors (reporting PM<=1.0, PM<=2.5 and PM<=10.0 in g/m)       | https://github.com/fu-hsi/pms
 
 ## Installation
 
@@ -75,23 +86,8 @@ Please note NodeManager cannot be used as an arduino library since requires acce
 
 ### Installing the dependencies
 
-Some of the sensors rely on third party libraries. Those libraries are not included within NodeManager and have to be installed from the Arduino IDE Library Manager (Sketch -> Include Library -> Manager Libraries) or manually. You need to install the library ONLY if you are planning to enable to use the sensor:
-
-Sensor  | Required Library
- ------------- | -------------
-SensorSHT21, SensorHTU21D | https://github.com/SodaqMoja/Sodaq_SHT2x
-SensorDHT11, SensorDHT22 | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/DHT
-SensorDs18b20 | https://github.com/milesburton/Arduino-Temperature-Control-Library
-SensorBH1750 | https://github.com/claws/BH1750
-SensorMLX90614 | https://github.com/adafruit/Adafruit-MLX90614-Library
-SensorBME280 | https://github.com/adafruit/Adafruit_BME280_Library
-SensorSonoff | https://github.com/thomasfredericks/Bounce2
-SensorBMP085 | https://github.com/adafruit/Adafruit-BMP085-Library
-SensorHCSR04 | https://github.com/mysensors/MySensorsArduinoExamples/tree/master/libraries/NewPing
-SensorMCP9808 | https://github.com/adafruit/Adafruit_MCP9808_Library
-SensorAM2320 | https://github.com/thakshak/AM2320
-SensorTSL2561 | https://github.com/adafruit/TSL2561-Arduino-Library
-SensorBMP280 | https://github.com/adafruit/Adafruit_BMP280_Library
+Some of the sensors rely on third party libraries. Those libraries are not included within NodeManager and have to be installed from the Arduino IDE Library Manager (Sketch -> Include Library -> Manager Libraries) or manually. 
+You need to install the library ONLY if you are planning to enable to use the sensor.
 
 ### Upgrade
 
@@ -110,7 +106,7 @@ Please note you don't necessarily need a NodeManager gateway to interact with a
 
 ### NodeManager configuration
 
-The next step is to enable NodeManager's modules required for your sensors. When a module is enabled, the required library will be loaded and the corresponding sensor will be made available. To enable it, set it to 1. Enabled only what you need to ensure enough storage is left for your custom code.
+The next step is to enable NodeManager's modules required for your sensors. When a module is enabled, the required library will be loaded and the corresponding sensor will be made available. To enable it, uncomment the line. Enabled only what you need to ensure enough storage is left for your custom code.
 
 ### Add your sensors
 
@@ -124,14 +120,6 @@ SensorSHT21 sht21(node);
 The sensor will be then registered automatically with NodeManager which will take care of it all along its lifecycle. Please ensure the corresponding module has been previously enabled for a successful compilation of the code.
 NodeManager will assign a child id automatically, present each sensor for you to the controller, query each sensor and report the measure back to the gateway/controller. For actuators (e.g. relays) those can be triggered by sending a `REQ` message with the expected type to their assigned child id.
 
-For your convenience, NodeManager makes available additional special sensors which can be added in the same way as other built-in sensors:
-
-Special Sensor  | Description
- ------------- | -------------
-SensorBattery | Add it to enable automatic battery reporting
-SensorSignal | Add it to enable automatic signal level reporting
-SensorConfiguration | Add it to enable OTA remote configuration of any registered sensor
-
 ### Configuring your sensors
 
 NodeManager and all the sensors can be configured from within `before()` in the main sketch. Find `Configure your sensors below` to customize the behavior of any sensor by calling one of the functions available.
@@ -608,7 +596,306 @@ If the sensor implements a remote API, this has to be made available in SensorCo
 
 ## Examples
 
-Examples and sample code is provided from within the main sketch.
+* Analog Light and Temperature Sensor
+The following sketch can be used to report the temperature and the light level based on a thermistor and LDR sensors attached to two analog pins of the arduino board (A1 and A2). Both the thermistor and the LDR are connected to ground on one side and to vcc via a resistor on the other so to measure the voltage drop across each of them through the analog pins.
+
+The sensor will be put to sleep after startup and will report both the measures every 10 minutes. NodeManager will take care of presenting the sensors, managing the sleep cycle, reporting the battery level every hour and report the measures in the appropriate format. 
+
+Even if the sensor is sleeping most of the time, it can be potentially woke up by sending a V_CUSTOM message to NodeManager service child id (200 by default) just after having reported its heartbeat. At this point the node will report awake and the user can interact with it by e.g. sending REQ messages to its child IDs, changing the duration of a sleep cycle, etc.
+
+~~~c
+*/
+
+/**********************************
+ * MySensors node configuration
+ */
+
+// General settings
+#define SKETCH_NAME "LightTemperatureSensor"
+#define SKETCH_VERSION "1.0"
+#define MY_BAUD_RATE 9600
+#define MY_NODE_ID 99
+#define MY_SPLASH_SCREEN_DISABLED
+
+// NRF24 radio settings
+#define MY_RADIO_NRF24
+
+/***********************************
+ * NodeManager modules
+ */
+
+#define MODULE_ANALOG_INPUT
+#define MODULE_THERMISTOR
+
+/***********************************
+ * Load NodeManager Library
+ */
+
+// enable NodeManager's debug on serial port
+#define NODEMANAGER_DEBUG
+// include NodeManager's library
+#include "NodeManagerLibrary.h"
+NodeManager node;
+
+/***********************************
+ * Add your sensors below
+ */
+
+SensorBattery battery(node);
+SensorConfiguration configuration(node);
+
+SensorLDR ldr(node,A1);
+SensorThermistor thermistor(node,A2);
+
+/***********************************
+ * Main Sketch
+ */
+
+// before
+void before() {
+  // setup the serial port baud rate
+  Serial.begin(MY_BAUD_RATE);
+
+  /*
+  * Configure your sensors below
+  */
+
+  node.setReportIntervalMinutes(10);
+  node.setSleepMinutes(10);
+  
+  /*
+  * Configure your sensors above
+  */
+  node.before();
+}
+
+// presentation
+void presentation() {
+  // call NodeManager presentation routine
+  node.presentation();
+}
+
+// setup
+void setup() {
+  // call NodeManager setup routine
+  node.setup();
+}
+
+// loop
+void loop() {
+  // call NodeManager loop routine
+  node.loop();
+}
+
+// receive
+void receive(MyMessage &message) {
+  // call NodeManager receive routine
+  node.receive(message);
+}
+
+// receiveTime
+void receiveTime(unsigned long ts) {
+  // call NodeManager receiveTime routine
+  node.receiveTime(ts);
+}
+~~~
+
+* Motion Sensor
+The following sketch can be used to report back to the controller when a motion sensor attached to the board's pin 3 triggers. In this example, the board will be put to sleep just after startup and will report a heartbeat every hour. NodeManager will take care of configuring an interrupt associated to the provided pin so automatically wake up when a motion is detected and report a V_TRIPPED message back.
+
+~~~c
+*/
+
+/**********************************
+ * MySensors node configuration
+ */
+
+// General settings
+#define SKETCH_NAME "MotionSensor"
+#define SKETCH_VERSION "1.0"
+#define MY_BAUD_RATE 9600
+#define MY_NODE_ID 99
+#define MY_SPLASH_SCREEN_DISABLED
+
+// NRF24 radio settings
+#define MY_RADIO_NRF24
+
+/***********************************
+ * NodeManager modules
+ */
+
+#define MODULE_SWITCH
+
+/***********************************
+ * Load NodeManager Library
+ */
+
+// enable NodeManager's debug on serial port
+#define NODEMANAGER_DEBUG
+// include NodeManager's library
+#include "NodeManagerLibrary.h"
+NodeManager node;
+
+/***********************************
+ * Add your sensors below
+ */
+
+SensorMotion motion(node,3);
+
+/***********************************
+ * Main Sketch
+ */
+
+// before
+void before() {
+  // setup the serial port baud rate
+  Serial.begin(MY_BAUD_RATE);
+
+  /*
+  * Configure your sensors below
+  */
+
+  node.setSleepMinutes(60);
+  
+  /*
+  * Configure your sensors above
+  */
+  node.before();
+}
+
+// presentation
+void presentation() {
+  // call NodeManager presentation routine
+  node.presentation();
+}
+
+// setup
+void setup() {
+  // call NodeManager setup routine
+  node.setup();
+}
+
+// loop
+void loop() {
+  // call NodeManager loop routine
+  node.loop();
+}
+
+// receive
+void receive(MyMessage &message) {
+  // call NodeManager receive routine
+  node.receive(message);
+}
+
+// receiveTime
+void receiveTime(unsigned long ts) {
+  // call NodeManager receiveTime routine
+  node.receiveTime(ts);
+}
+~~~
+
+* Boiler Sensor
+
+The following sketch controls a latching relay connected to a boiler. A latching relay (requiring only a pulse to switch) has been chosen to minimize the power consumption required by a traditional relay to stay on. This relay has normally two pins, one for closing and the other for opening the controlled circuit, connected to pin 6 and 7 of the arduino board. Since using a SensorLatchingRelay type of sensor, NodeManager will automatically consider the provided pin as the ON pin and the one just after as the OFF pin and will take care of just sending out a single pulse only when a SET command of type V_STATUS is sent to the child id. The appropriate pin will be then used.
+
+In this example, the board also runs at 1Mhz so it can go down to 1.8V: by setting setBatteryMin() and setBatteryMax(), the battery percentage will be calculated and reported (by default, automatically every hour) based on these custom boundaries.
+
+The board will be put to sleep just after startup and will report back to the controller every 5 minutes. It is the controller's responsability to catch when the board reports its heartbeat (using smart sleep behind the scene) and send a command back if needed.
+
+~~~c
+*/
+
+/**********************************
+ * MySensors node configuration
+ */
+
+// General settings
+#define SKETCH_NAME "BoilerSensor"
+#define SKETCH_VERSION "1.0"
+#define MY_BAUD_RATE 9600
+#define MY_NODE_ID 99
+#define MY_SPLASH_SCREEN_DISABLED
+
+// NRF24 radio settings
+#define MY_RADIO_NRF24
+
+/***********************************
+ * NodeManager modules
+ */
+
+#define MODULE_DIGITAL_OUTPUT
+
+/***********************************
+ * Load NodeManager Library
+ */
+
+// enable NodeManager's debug on serial port
+#define NODEMANAGER_DEBUG
+// include NodeManager's library
+#include "NodeManagerLibrary.h"
+NodeManager node;
+
+/***********************************
+ * Add your sensors below
+ */
+
+SensorBattery battery(node);
+SensorLatchingRelay latching(node,6);
+
+/***********************************
+ * Main Sketch
+ */
+
+// before
+void before() {
+  // setup the serial port baud rate
+  Serial.begin(MY_BAUD_RATE);
+
+  /*
+  * Configure your sensors below
+  */
+
+  node.setSleepMinutes(5);
+  
+  battery.setBatteryMin(1.8);
+  battery.setBatteryMax(3.2);
+  
+  /*
+  * Configure your sensors above
+  */
+  node.before();
+}
+
+// presentation
+void presentation() {
+  // call NodeManager presentation routine
+  node.presentation();
+}
+
+// setup
+void setup() {
+  // call NodeManager setup routine
+  node.setup();
+}
+
+// loop
+void loop() {
+  // call NodeManager loop routine
+  node.loop();
+}
+
+// receive
+void receive(MyMessage &message) {
+  // call NodeManager receive routine
+  node.receive(message);
+}
+
+// receiveTime
+void receiveTime(unsigned long ts) {
+  // call NodeManager receiveTime routine
+  node.receiveTime(ts);
+}
+~~~
 
 ## Contributing
 
